<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of solveCobraQP</title>
  <meta name="keywords" content="solveCobraQP">
  <meta name="description" content="solveCobraQP Solve constraint-based QP problems">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2003 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../m2html.css">
</head>
<body>
<a name="_top"></a>
<!-- ../menu.html cobra --><!-- menu.html solvers -->
<h1>solveCobraQP
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>solveCobraQP Solve constraint-based QP problems</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>function solution = solveCobraQP(QPproblem,varargin) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre class="comment">solveCobraQP Solve constraint-based QP problems

 solution = solveCobraQP(QPproblem,parameters)

 % Solves problems of the type 

      min   0.5 x' * F * x + osense * c' * x
      s/t   lb &lt;= x &lt;= ub
            A * x  &lt;=/=/&gt;= b

INPUT
 QPproblem Structure containing the following fields describing the QP
 problem to be solved
  A      LHS matrix
  b      RHS vector
  F      F matrix for quadratic objective (must be positive definite)
  c      Objective coeff vector
  lb     Lower bound vector
  ub     Upper bound vector
  osense Objective sense (-1 max, +1 min)
  csense Constraint senses, a string containting the constraint sense for
         each row in A ('E', equality, 'G' greater than, 'L' less than).

OPTIONAL INPUTS
 Optional parameters can be entered using parameters structure or as
 parameter followed by parameter value: i.e. ,'printLevel',3)

 parameters    Structure containing optional parameters as fields.
  printLevel   Print level for solver
  saveInput    Saves LPproblem to filename specified in field. 
               Setting parameters = 'default' uses default setting set in
               getCobraSolverParameters.

 The solver is defined in the CBT_MILP_SOLVER global variable
 (set using changeCobraSolver). Solvers currently available are
 'tomlab_cplex', 'mosek' and 'qpng' (limited support for small problems)

OUTPUT
 solution  Structure containing the following fields describing a QP
           solution
  full     Full QP solution vector
  obj      Objective value
  solver   Solver used to solve QP problem
  stat     Solver status in standardized form (see below)
  origStat Original status returned by the specific solver 
  time     Solve time in seconds

  stat     Solver status in standardized form
           1   Optimal solution
           2   Unbounded solution
           0   Infeasible
           -1  No solution reported (timelimit, numerical problem etc)

 Markus Herrgard        6/8/07
 Ronan Fleming         12/07/09  Added support for mosek
 Ronan Fleming         18 Jan 10 Added support for pdco
 Josh Lerman           04/17/10 changed def. parameters, THREADS, QPMETHOD</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="getCobraSolverParams.html" class="code" title="function varargout = getCobraSolverParams(solverType, paramNames, parameters)">getCobraSolverParams</a>	This function gets the specified parameters in paramNames from</li><li><a href="solveCobraLPCPLEX.html" class="code" title="function [solution,LPProblem]=solveCobraLPCPLEX(LPProblem,printLevel,basisReuse,conflictResolve,contFunctName,minNorm)">solveCobraLPCPLEX</a>	[solution,LPProblem]=solveCobraLPCPLEX(LPProblem,printLevel,basisReuse,conflictResolve,contFunctName,minNorm)</li></ul>
This function is called by:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="../../cobra/MOMA.html" class="code" title="function [solutionDel,solutionWT,totalFluxDiff,solStatus] =MOMA(modelWT,modelDel,osenseStr,verbFlag,minNormFlag)">MOMA</a>	MOMA Performs a quadratic version of the MOMA (minimization of</li><li><a href="../../cobra/fluxVariability.html" class="code" title="function [minFlux,maxFlux,Vmin,Vmax] = fluxVariability(model,optPercentage,osenseStr,rxnNameList,verbFlag, allowLoops)">fluxVariability</a>	fluxVariability Performs flux variablity analysis</li><li><a href="../../cobra/optimizeCbModel.html" class="code" title="function FBAsolution = optimizeCbModel(model,osenseStr, minNorm, allowLoops)">optimizeCbModel</a>	optimizeCbModel Solve a flux balance analysis problem</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function [obj,grad,hess] = QPObj(x)</a></li></ul>
<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function solution = solveCobraQP(QPproblem,varargin)</a>
0002 <span class="comment">%solveCobraQP Solve constraint-based QP problems</span>
0003 <span class="comment">%</span>
0004 <span class="comment">% solution = solveCobraQP(QPproblem,parameters)</span>
0005 <span class="comment">%</span>
0006 <span class="comment">% % Solves problems of the type</span>
0007 <span class="comment">%</span>
0008 <span class="comment">%      min   0.5 x' * F * x + osense * c' * x</span>
0009 <span class="comment">%      s/t   lb &lt;= x &lt;= ub</span>
0010 <span class="comment">%            A * x  &lt;=/=/&gt;= b</span>
0011 <span class="comment">%</span>
0012 <span class="comment">%INPUT</span>
0013 <span class="comment">% QPproblem Structure containing the following fields describing the QP</span>
0014 <span class="comment">% problem to be solved</span>
0015 <span class="comment">%  A      LHS matrix</span>
0016 <span class="comment">%  b      RHS vector</span>
0017 <span class="comment">%  F      F matrix for quadratic objective (must be positive definite)</span>
0018 <span class="comment">%  c      Objective coeff vector</span>
0019 <span class="comment">%  lb     Lower bound vector</span>
0020 <span class="comment">%  ub     Upper bound vector</span>
0021 <span class="comment">%  osense Objective sense (-1 max, +1 min)</span>
0022 <span class="comment">%  csense Constraint senses, a string containting the constraint sense for</span>
0023 <span class="comment">%         each row in A ('E', equality, 'G' greater than, 'L' less than).</span>
0024 <span class="comment">%</span>
0025 <span class="comment">%OPTIONAL INPUTS</span>
0026 <span class="comment">% Optional parameters can be entered using parameters structure or as</span>
0027 <span class="comment">% parameter followed by parameter value: i.e. ,'printLevel',3)</span>
0028 <span class="comment">%</span>
0029 <span class="comment">% parameters    Structure containing optional parameters as fields.</span>
0030 <span class="comment">%  printLevel   Print level for solver</span>
0031 <span class="comment">%  saveInput    Saves LPproblem to filename specified in field.</span>
0032 <span class="comment">%               Setting parameters = 'default' uses default setting set in</span>
0033 <span class="comment">%               getCobraSolverParameters.</span>
0034 <span class="comment">%</span>
0035 <span class="comment">% The solver is defined in the CBT_MILP_SOLVER global variable</span>
0036 <span class="comment">% (set using changeCobraSolver). Solvers currently available are</span>
0037 <span class="comment">% 'tomlab_cplex', 'mosek' and 'qpng' (limited support for small problems)</span>
0038 <span class="comment">%</span>
0039 <span class="comment">%OUTPUT</span>
0040 <span class="comment">% solution  Structure containing the following fields describing a QP</span>
0041 <span class="comment">%           solution</span>
0042 <span class="comment">%  full     Full QP solution vector</span>
0043 <span class="comment">%  obj      Objective value</span>
0044 <span class="comment">%  solver   Solver used to solve QP problem</span>
0045 <span class="comment">%  stat     Solver status in standardized form (see below)</span>
0046 <span class="comment">%  origStat Original status returned by the specific solver</span>
0047 <span class="comment">%  time     Solve time in seconds</span>
0048 <span class="comment">%</span>
0049 <span class="comment">%  stat     Solver status in standardized form</span>
0050 <span class="comment">%           1   Optimal solution</span>
0051 <span class="comment">%           2   Unbounded solution</span>
0052 <span class="comment">%           0   Infeasible</span>
0053 <span class="comment">%           -1  No solution reported (timelimit, numerical problem etc)</span>
0054 <span class="comment">%</span>
0055 <span class="comment">% Markus Herrgard        6/8/07</span>
0056 <span class="comment">% Ronan Fleming         12/07/09  Added support for mosek</span>
0057 <span class="comment">% Ronan Fleming         18 Jan 10 Added support for pdco</span>
0058 <span class="comment">% Josh Lerman           04/17/10 changed def. parameters, THREADS, QPMETHOD</span>
0059 
0060 <span class="keyword">global</span> CBT_QP_SOLVER;
0061 
0062 <span class="keyword">if</span> (~isempty(CBT_QP_SOLVER))
0063     solver = CBT_QP_SOLVER;
0064 <span class="keyword">else</span>
0065     error(<span class="string">'No solver found'</span>);
0066 <span class="keyword">end</span>
0067 
0068 optParamNames = {<span class="string">'printLevel'</span>,<span class="string">'saveInput'</span>};
0069 parameters = <span class="string">''</span>;
0070 <span class="keyword">if</span> nargin ~=1
0071     <span class="keyword">if</span> mod(length(varargin),2)==0
0072         <span class="keyword">for</span> i=1:2:length(varargin)-1
0073             <span class="keyword">if</span> ismember(varargin{i},optParamNames)
0074                 parameters.(varargin{i}) = varargin{i+1};
0075             <span class="keyword">else</span>
0076                 error([varargin{i} <span class="string">' is not a valid optional parameter'</span>]);
0077             <span class="keyword">end</span>
0078         <span class="keyword">end</span>
0079     <span class="keyword">elseif</span> strcmp(varargin{1},<span class="string">'default'</span>)
0080         parameters = <span class="string">'default'</span>;
0081     <span class="keyword">elseif</span> isstruct(varargin{1})
0082         parameters = varargin{1};
0083     <span class="keyword">else</span>
0084         display(<span class="string">'Warning: Invalid number of parameters/values'</span>)
0085         solution=[];
0086         <span class="keyword">return</span>;
0087     <span class="keyword">end</span>
0088 <span class="keyword">end</span>
0089 
0090 <span class="comment">% Defaults in case the solver does not return anything</span>
0091 x = [];
0092 y = [];
0093 w = [];
0094 f = [];
0095 xInt = [];
0096 xCont = [];
0097 stat = -99;
0098 solStat = -99;
0099 
0100 <span class="comment">%parameters</span>
0101 [printLevel, saveInput] = <a href="getCobraSolverParams.html" class="code" title="function varargout = getCobraSolverParams(solverType, paramNames, parameters)">getCobraSolverParams</a>(<span class="string">'QP'</span>,optParamNames,parameters);
0102 
0103 [A,b,F,c,lb,ub,csense,osense] = <span class="keyword">...</span>
0104     deal(QPproblem.A,QPproblem.b,QPproblem.F,QPproblem.c,QPproblem.lb,QPproblem.ub,<span class="keyword">...</span>
0105     QPproblem.csense,QPproblem.osense);
0106 
0107 t_start = clock;
0108 <span class="keyword">switch</span> solver
0109 <span class="comment">%%</span>
0110     <span class="keyword">case</span> <span class="string">'tomlab_cplex'</span>
0111         <span class="keyword">if</span> (~isempty(csense))
0112             b_L(csense == <span class="string">'E'</span>) = b(csense == <span class="string">'E'</span>);
0113             b_U(csense == <span class="string">'E'</span>) = b(csense == <span class="string">'E'</span>);
0114             b_L(csense == <span class="string">'G'</span>) = b(csense == <span class="string">'G'</span>);
0115             b_U(csense == <span class="string">'G'</span>) = inf;
0116             b_L(csense == <span class="string">'L'</span>) = -inf;
0117             b_U(csense == <span class="string">'L'</span>) = b(csense == <span class="string">'L'</span>);
0118         <span class="keyword">else</span>
0119             b_L = b;
0120             b_U = b;
0121         <span class="keyword">end</span>
0122         tomlabProblem = qpAssign(F,osense*c,A,b_L,b_U,lb,ub,[],<span class="string">'CobraQP'</span>);
0123         
0124         <span class="comment">%optional parameters</span>
0125         tomlabProblem.PriLvl=printLevel;
0126         tomlabProblem.MIP.cpxControl.QPMETHOD = 1;
0127         tomlabProblem.MIP.cpxControl.THREADS = 1;
0128                 
0129         <span class="comment">%Save Input if selected</span>
0130         <span class="keyword">if</span> ~isempty(saveInput)
0131             fileName = saveInput;
0132             <span class="keyword">if</span> ~find(regexp(fileName,<span class="string">'.mat'</span>))
0133                 fileName = [fileName <span class="string">'.mat'</span>];
0134             <span class="keyword">end</span>
0135             display([<span class="string">'Saving QPproblem in '</span> fileName]);
0136             save(fileName,<span class="string">'QPproblem'</span>)
0137         <span class="keyword">end</span>
0138         
0139         Result = tomRun(<span class="string">'cplex'</span>, tomlabProblem);
0140         x = Result.x_k;
0141         f = osense*Result.f_k;
0142         origStat = Result.Inform;
0143         <span class="keyword">if</span> (origStat == 1)
0144             stat = 1; <span class="comment">% Optimal</span>
0145         <span class="keyword">elseif</span> (origStat == 3 || origStat == 4)
0146             stat = 0; <span class="comment">% Infeasible</span>
0147         <span class="keyword">elseif</span> (origStat == 2)
0148             stat = 2; <span class="comment">% Unbounded</span>
0149         <span class="keyword">elseif</span> (origStat &gt;= 10)
0150             stat = -1; <span class="comment">% No optimal solution found (time or other limits reached, other infeasibility problems)</span>
0151         <span class="keyword">else</span>
0152             stat = 3; <span class="comment">% Solution exists, but either scaling problems or not proven to be optimal</span>
0153         <span class="keyword">end</span>
0154         <span class="comment">%%</span>
0155     <span class="keyword">case</span> <span class="string">'cplex_direct'</span>
0156         <span class="comment">%% Tomlab cplex.m direct</span>
0157         <span class="comment">%Used with the current script, only some of the control affoarded with</span>
0158         <span class="comment">%this interface is provided. Primarily, this is to change the print</span>
0159         <span class="comment">%level and whether to minimise the Euclidean Norm of the internal</span>
0160         <span class="comment">%fluxes or not.</span>
0161         <span class="comment">%See solveCobraLPCPLEX.m for more refined control of cplex</span>
0162         <span class="comment">%Ronan Fleming 11/12/2008</span>
0163                
0164         solution=<a href="solveCobraLPCPLEX.html" class="code" title="function [solution,LPProblem]=solveCobraLPCPLEX(LPProblem,printLevel,basisReuse,conflictResolve,contFunctName,minNorm)">solveCobraLPCPLEX</a>(QPproblem,printLevel,[],[],[],minNorm);
0165         <span class="comment">%%</span>
0166    <span class="keyword">case</span> <span class="string">'qpng'</span>
0167         <span class="comment">% qpng.m This file is part of GLPKMEX.</span>
0168         <span class="comment">% Copyright 2006-2007 Nicolo Giorgetti.</span>
0169         <span class="comment">%</span>
0170         <span class="comment">% Solves the general quadratic program</span>
0171         <span class="comment">%      min 0.5 x'*H*x + q'*x</span>
0172         <span class="comment">%       x</span>
0173         <span class="comment">% subject to</span>
0174         <span class="comment">%      A*x [ &quot;=&quot; | &quot;&lt;=&quot; | &quot;&gt;=&quot; ] b</span>
0175         <span class="comment">%      lb &lt;= x &lt;= ub</span>
0176         ctype=csense;
0177         ctype((<span class="string">'G'</span>==csense))=<span class="string">'L'</span>;
0178         ctype((<span class="string">'E'</span>==csense))=<span class="string">'E'</span>;
0179         ctype((<span class="string">'L'</span>==csense))=<span class="string">'U'</span>;
0180         
0181         x0=ones(size(QPproblem.A,2),1);
0182         <span class="comment">%equality constraint matrix must be full row rank</span>
0183         [x, f, y, info] = qpng (QPproblem.F, QPproblem.c*QPproblem.osense, full(QPproblem.A), QPproblem.b, ctype, QPproblem.lb, QPproblem.ub, x0);
0184         
0185         f = 0.5*x'*QPproblem.F*x + c'*x;
0186         
0187         w=[];
0188         
0189         <span class="keyword">if</span> (info.status == 0)
0190             stat = 1;
0191         <span class="keyword">elseif</span> (info.status == 1)
0192             stat = 0;
0193         <span class="keyword">else</span>
0194             stat = -1;
0195         <span class="keyword">end</span>
0196         origStat=info.status;
0197         <span class="comment">%%</span>
0198     <span class="keyword">case</span> <span class="string">'mosek'</span>
0199         <span class="keyword">if</span> (~isempty(csense))
0200             b_L(csense == <span class="string">'E'</span>) = b(csense == <span class="string">'E'</span>);
0201             b_U(csense == <span class="string">'E'</span>) = b(csense == <span class="string">'E'</span>);
0202             b_L(csense == <span class="string">'G'</span>) = b(csense == <span class="string">'G'</span>);
0203             b_U(csense == <span class="string">'G'</span>) = inf;
0204             b_L(csense == <span class="string">'L'</span>) = -inf;
0205             b_U(csense == <span class="string">'L'</span>) = b(csense == <span class="string">'L'</span>);
0206         <span class="keyword">else</span>
0207             b_L = b;
0208             b_U = b;
0209         <span class="keyword">end</span>
0210                 
0211         <span class="keyword">if</span> printLevel&gt;0
0212             cmd=<span class="string">'minimize'</span>;
0213         <span class="keyword">else</span>
0214             cmd=<span class="string">'minimize echo(0)'</span>;
0215         <span class="keyword">end</span>
0216         
0217         <span class="comment">% Optimize the problem.</span>
0218         <span class="comment">% min 0.5*x'*F*x + osense*c'*x</span>
0219         <span class="comment">% st. blc &lt;= A*x &lt;= buc</span>
0220         <span class="comment">%     bux &lt;= x   &lt;= bux</span>
0221         [res] = mskqpopt(F,osense*c,A,b_L,b_U,lb,ub,[],cmd);
0222         
0223         <span class="keyword">if</span> isempty(res)
0224             stat=3;
0225         <span class="keyword">else</span>
0226             <span class="keyword">if</span> isfield(res,<span class="string">'sol'</span>)
0227                 origStat=res.sol.itr.solsta;
0228                 <span class="keyword">if</span> strcmp(res.sol.itr.prosta,<span class="string">'PRIMAL_AND_DUAL_FEASIBLE'</span>) &amp;&amp;  (strcmp(res.sol.itr.solsta,<span class="string">'OPTIMAL'</span>) || strcmp(res.sol.itr.solsta,<span class="string">'NEAR_OPTIMAL'</span>))
0229                     stat=1;
0230                     <span class="comment">% x solution.</span>
0231                     x = res.sol.itr.xx;
0232                     f = 0.5*x'*F*x + c'*x;
0233                     
0234                     <span class="comment">%dual to equality</span>
0235                     y=res.sol.itr.y;
0236                     
0237                     <span class="comment">%dual to lower and upper bounds</span>
0238                     w=res.sol.itr.slx - res.sol.itr.sux;
0239                 <span class="keyword">else</span>
0240                     stat=3;
0241                 <span class="keyword">end</span>
0242             <span class="keyword">else</span>
0243                 stat=3;
0244                 origStat=res.rmsg;
0245             <span class="keyword">end</span>
0246         <span class="keyword">end</span>
0247         <span class="comment">% stat   Solver status</span>
0248         <span class="comment">%           1   Optimal solution found</span>
0249         <span class="comment">%           2   Unbounded solution</span>
0250         <span class="comment">%           0   Infeasible QP</span>
0251         <span class="comment">%           3   Other problem (time limit etc)</span>
0252         <span class="comment">%%</span>
0253       <span class="keyword">case</span> <span class="string">'pdco'</span>
0254         <span class="comment">%-----------------------------------------------------------------------</span>
0255         <span class="comment">% pdco.m: Primal-Dual Barrier Method for Convex Objectives (16 Dec 2008)</span>
0256         <span class="comment">%-----------------------------------------------------------------------</span>
0257         <span class="comment">% AUTHOR:</span>
0258         <span class="comment">%    Michael Saunders, Systems Optimization Laboratory (SOL),</span>
0259         <span class="comment">%    Stanford University, Stanford, California, USA.</span>
0260         <span class="comment">%Interfaced with Cobra toolbox by Ronan Fleming, 18 Jan 2010</span>
0261         [nMet,nRxn]=size(A);
0262         d1=ones(nRxn,1)*1e-4;
0263         <span class="comment">%dont minimise the norm of reactions in linear objective</span>
0264         d1(c~=0)=0;
0265         d2=1e-5;
0266         options = pdcoSet;
0267         
0268         x0 = ones(nRxn,1);
0269         y0 = ones(nMet,1);
0270         z0 = ones(nRxn,1);
0271         xsize = 1000;
0272         zsize = 1000;
0273         options.Method=2; <span class="comment">%QR</span>
0274         options.MaxIter=100;
0275         options.Print=printLevel;
0276         <span class="comment">%get handle to helper function for objective</span>
0277         pdObjHandle = @(x) <a href="#_sub1" class="code" title="subfunction [obj,grad,hess] = QPObj(x)">QPObj</a>(x);
0278         <span class="comment">%solve the QP</span>
0279         [x,y,w,inform,PDitns,CGitns,time] = <span class="keyword">...</span>
0280             pdco(pdObjHandle,A,b,lb,ub,d1,d2,options,x0,y0,z0,xsize,zsize);
0281         f= c'*x + 0.5*x'*F*x;
0282         <span class="comment">% inform = 0 if a solution is found;</span>
0283 <span class="comment">%        = 1 if too many iterations were required;</span>
0284 <span class="comment">%        = 2 if the linesearch failed too often;</span>
0285 <span class="comment">%        = 3 if the step lengths became too small;</span>
0286 <span class="comment">%        = 4 if Cholesky said ADDA was not positive definite.</span>
0287         <span class="keyword">if</span> (inform == 0)
0288             stat = 1;
0289         <span class="keyword">elseif</span> (inform == 1 || inform == 2 || inform == 3)
0290             stat = 0;
0291         <span class="keyword">else</span>
0292             stat = -1;
0293         <span class="keyword">end</span>
0294         origStat=inform;
0295     <span class="comment">%%</span>
0296     <span class="keyword">otherwise</span>
0297         error([<span class="string">'Unknown solver: '</span> solver]);
0298 <span class="keyword">end</span>
0299 <span class="comment">%%</span>
0300 t = etime(clock, t_start);
0301 solution.obj = f;
0302 solution.solver = solver;
0303 solution.stat = stat;
0304 solution.origStat = origStat; 
0305 solution.time = t;
0306 solution.full = x;
0307 solution.dual = y;
0308 solution.rcost = w;
0309 
0310 <span class="comment">%Helper function for pdco</span>
0311 <span class="comment">%%</span>
0312     <span class="keyword">function</span> [obj,grad,hess] = <a href="#_sub1" class="code" title="subfunction [obj,grad,hess] = QPObj(x)">QPObj</a>(x)
0313         obj  = c'*x + 0.5*x'*F*x;
0314         grad = c + F*x;
0315         hess = F;
0316     <span class="keyword">end</span>
0317 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Fri 22-Apr-2011 13:22:54 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" target="_parent">m2html</a></strong> &copy; 2003</address>
</body>
</html>