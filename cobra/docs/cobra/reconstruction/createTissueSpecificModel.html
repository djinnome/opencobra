<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of createTissueSpecificModel</title>
  <meta name="keywords" content="createTissueSpecificModel">
  <meta name="description" content="createTissueSpecificModel Create draft tissue specific model from mRNA expression data">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2003 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../m2html.css">
</head>
<body>
<a name="_top"></a>
<!-- ../menu.html cobra --><!-- menu.html reconstruction -->
<h1>createTissueSpecificModel
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>createTissueSpecificModel Create draft tissue specific model from mRNA expression data</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>function [tissueModel,Rxns] = createTissueSpecificModel(model,expressionData,proceedExp,orphan,exRxnRemove,solver,options,funcModel) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre class="comment">createTissueSpecificModel Create draft tissue specific model from mRNA expression data

 [tissueModel,Rxns] = createTissueSpecificModel(model,expressionData,proceedExp,orphan,exRxnRemove,solver,options,funcModel)

INPUTS
   model               global recon1 model
   expressionData      mRNA expression Data structure
       Locus           Vector containing GeneIDs
       Data            Presence/Absence Calls
                             Use: (1 - Present, 0 - Absent) when proceedExp = 1
                             Use: (2 - Present, 1 - Marginal, 0 - Absent)
                               when proceedExp = 0
       Transcript      RefSeq Accession (only required if proceedExp = 0)
 
OPTINAL INPUTS
   proceedExp          1 - data are processed ; 0 - data need to be
                           processed (Default = 1)
   orphan              1 - leave orphan reactions in model for Shlomi Method
                       0 - remove orphan reactions
                       (Default = 1)
   exRxnRemove         Names of exchange reactions to remove
                       (Default = [])
   solver              Use either 'GIMME' or 'Shlomi' to create tissue
                       specific model
                       (Default = 'GIMME')
   options             If using GIMME, enter objectiveCol here
                       Default: objective function with 90% flux cutoff,
                       written as: [find(model.c) 0.9]
   funcModel           1 - Build a functional model having only reactions
                       that can carry a flux (using FVA), 0 - skip this
                       step (Default = 0)

OUTPUTS
   tissueModel         Model produced by GIMME or Shlomi, containing only
                       reactions carrying flux
   Rxns                Statistics of test
                               ExpressedRxns - predicted by mRNA data
                               UnExpressedRxns - predicted by mRNA data
                               unknown - unable to be predicted by mRNA
                                   data
                               Upregulated - added back into model
                               Downregulated - removed from model
                               UnknownIncluded - orphans added
 
 NOTE: If there are multiple transcripts to one probe that have different
 expression patterns the script will ask what the locus is of the
 expressed and unexpressed transcripts

 Note: GIMME script matches objective functions flux, Shlomi algorithm is
 based on maintaining pathway length comparable to expression data, not flux

 Aarash Bordbar 05/15/2009
 Added proceedExp, IT 10/30/09
 Adjusted manual input for alt. splice form, IT 05/27/10
 Final Corba 2.0 Version, AB 08/05/10</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="../../cobra/convertToIrreversible.html" class="code" title="function [modelIrrev,matchRev,rev2irrev,irrev2rev] = convertToIrreversible(model)">convertToIrreversible</a>	convertToIrreversible Convert model to irreversible format</li><li><a href="../../cobra/findRxnIDs.html" class="code" title="function rxnID = findRxnIDs(model,rxnList)">findRxnIDs</a>	findRxnIDs Find reaction numbers in a model</li><li><a href="../../cobra/optimizeCbModel.html" class="code" title="function FBAsolution = optimizeCbModel(model,osenseStr, minNorm, allowLoops)">optimizeCbModel</a>	optimizeCbModel Solve a flux balance analysis problem</li><li><a href="removeRxns.html" class="code" title="function modelOut = removeRxns(model,rxnRemoveList,irrevFlag,metFlag)">removeRxns</a>	removeRxns Remove reactions from a model</li><li><a href="../../cobra/solvers/solveCobraMILP.html" class="code" title="function solution = solveCobraMILP(MILPproblem,varargin)">solveCobraMILP</a>	solveCobraMILP Solve constraint-based MILP problems</li></ul>
This function is called by:
<ul style="list-style-image:url(../../matlabicon.gif)">
</ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function [reactionActivity,reactionActivityIrrev,model2gimme,gimmeSolution] = solveGimme(model,objectiveCol,expressionCol,cutoff)</a></li><li><a href="#_sub2" class="code">function [rxnExpressed,unExpressed,unknown] = mapProbes(parsedGPR,corrRxn,locus,genePresence)</a></li><li><a href="#_sub3" class="code">function [parsedGPR,corrRxn] = extractGPRs(model)</a></li><li><a href="#_sub4" class="code">function [Results,Transcripts] = charExpData(ExpressionData)</a></li></ul>
<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [tissueModel,Rxns] = createTissueSpecificModel(model,expressionData,proceedExp,orphan,exRxnRemove,solver,options,funcModel)</a>
0002 <span class="comment">%createTissueSpecificModel Create draft tissue specific model from mRNA expression data</span>
0003 <span class="comment">%</span>
0004 <span class="comment">% [tissueModel,Rxns] = createTissueSpecificModel(model,expressionData,proceedExp,orphan,exRxnRemove,solver,options,funcModel)</span>
0005 <span class="comment">%</span>
0006 <span class="comment">%INPUTS</span>
0007 <span class="comment">%   model               global recon1 model</span>
0008 <span class="comment">%   expressionData      mRNA expression Data structure</span>
0009 <span class="comment">%       Locus           Vector containing GeneIDs</span>
0010 <span class="comment">%       Data            Presence/Absence Calls</span>
0011 <span class="comment">%                             Use: (1 - Present, 0 - Absent) when proceedExp = 1</span>
0012 <span class="comment">%                             Use: (2 - Present, 1 - Marginal, 0 - Absent)</span>
0013 <span class="comment">%                               when proceedExp = 0</span>
0014 <span class="comment">%       Transcript      RefSeq Accession (only required if proceedExp = 0)</span>
0015 <span class="comment">%</span>
0016 <span class="comment">%OPTINAL INPUTS</span>
0017 <span class="comment">%   proceedExp          1 - data are processed ; 0 - data need to be</span>
0018 <span class="comment">%                           processed (Default = 1)</span>
0019 <span class="comment">%   orphan              1 - leave orphan reactions in model for Shlomi Method</span>
0020 <span class="comment">%                       0 - remove orphan reactions</span>
0021 <span class="comment">%                       (Default = 1)</span>
0022 <span class="comment">%   exRxnRemove         Names of exchange reactions to remove</span>
0023 <span class="comment">%                       (Default = [])</span>
0024 <span class="comment">%   solver              Use either 'GIMME' or 'Shlomi' to create tissue</span>
0025 <span class="comment">%                       specific model</span>
0026 <span class="comment">%                       (Default = 'GIMME')</span>
0027 <span class="comment">%   options             If using GIMME, enter objectiveCol here</span>
0028 <span class="comment">%                       Default: objective function with 90% flux cutoff,</span>
0029 <span class="comment">%                       written as: [find(model.c) 0.9]</span>
0030 <span class="comment">%   funcModel           1 - Build a functional model having only reactions</span>
0031 <span class="comment">%                       that can carry a flux (using FVA), 0 - skip this</span>
0032 <span class="comment">%                       step (Default = 0)</span>
0033 <span class="comment">%</span>
0034 <span class="comment">%OUTPUTS</span>
0035 <span class="comment">%   tissueModel         Model produced by GIMME or Shlomi, containing only</span>
0036 <span class="comment">%                       reactions carrying flux</span>
0037 <span class="comment">%   Rxns                Statistics of test</span>
0038 <span class="comment">%                               ExpressedRxns - predicted by mRNA data</span>
0039 <span class="comment">%                               UnExpressedRxns - predicted by mRNA data</span>
0040 <span class="comment">%                               unknown - unable to be predicted by mRNA</span>
0041 <span class="comment">%                                   data</span>
0042 <span class="comment">%                               Upregulated - added back into model</span>
0043 <span class="comment">%                               Downregulated - removed from model</span>
0044 <span class="comment">%                               UnknownIncluded - orphans added</span>
0045 <span class="comment">%</span>
0046 <span class="comment">% NOTE: If there are multiple transcripts to one probe that have different</span>
0047 <span class="comment">% expression patterns the script will ask what the locus is of the</span>
0048 <span class="comment">% expressed and unexpressed transcripts</span>
0049 <span class="comment">%</span>
0050 <span class="comment">% Note: GIMME script matches objective functions flux, Shlomi algorithm is</span>
0051 <span class="comment">% based on maintaining pathway length comparable to expression data, not flux</span>
0052 <span class="comment">%</span>
0053 <span class="comment">% Aarash Bordbar 05/15/2009</span>
0054 <span class="comment">% Added proceedExp, IT 10/30/09</span>
0055 <span class="comment">% Adjusted manual input for alt. splice form, IT 05/27/10</span>
0056 <span class="comment">% Final Corba 2.0 Version, AB 08/05/10</span>
0057 
0058 <span class="comment">% Define defaults</span>
0059 <span class="keyword">if</span> ~exist(<span class="string">'proceedExp'</span>,<span class="string">'var'</span>) || isempty(proceedExp)
0060     proceedExp = 1;
0061 <span class="keyword">end</span>
0062 
0063 <span class="keyword">if</span> ~exist(<span class="string">'solver'</span>,<span class="string">'var'</span>) || isempty(solver)
0064     solver = <span class="string">'GIMME'</span>;
0065 <span class="keyword">end</span>
0066 
0067 <span class="keyword">if</span> ~exist(<span class="string">'exRxnRemove'</span>,<span class="string">'var'</span>) || isempty(exRxnRemove)
0068     exRxnRemove = [];
0069 <span class="keyword">end</span>
0070 
0071 <span class="keyword">if</span> ~exist(<span class="string">'orphan'</span>,<span class="string">'var'</span>) || isempty(orphan)
0072     orphan = 1;
0073 <span class="keyword">end</span>
0074 
0075 <span class="keyword">if</span> ~exist(<span class="string">'funcModel'</span>,<span class="string">'var'</span>) || isempty(funcModel)
0076     funcModel = 0;
0077 <span class="keyword">end</span>
0078 
0079 
0080 <span class="comment">% Extracting GPR data from model</span>
0081 [parsedGPR,corrRxn] = <a href="#_sub3" class="code" title="subfunction [parsedGPR,corrRxn] = extractGPRs(model)">extractGPRs</a>(model);
0082 
0083 <span class="keyword">if</span> proceedExp == 0
0084     <span class="comment">% Making presence/absence calls on mRNA expression data</span>
0085     [Results,Transcripts] = <a href="#_sub4" class="code" title="subfunction [Results,Transcripts] = charExpData(ExpressionData)">charExpData</a>(expressionData);
0086     
0087     x = ismember(Transcripts.Locus,[Transcripts.Expressed;Transcripts.UnExpressed]);
0088     unkLocus = find(x==0);
0089     
0090     AltSplice.Locus = Transcripts.Locus(unkLocus);
0091     AltSplice.Transcripts = Transcripts.Data(unkLocus);
0092     AltSplice.Expression = Transcripts.Expression(unkLocus);
0093     
0094     fprintf(<span class="string">'There are some probes that match up with different transcripts and expression patterns\n'</span>);
0095     fprintf(<span class="string">'Please elucidate these discrepancies below\n'</span>);
0096     fprintf(<span class="string">'To do so, look up the transcript in RefSeq and enter the proper locii below\n'</span>);
0097     
0098     cnt1 = 1;
0099     cnt2 = 1;
0100     locusNE =[];
0101     locusE = [];
0102     <span class="keyword">for</span> i = 1:length(AltSplice.Locus)
0103         <span class="keyword">if</span> length(AltSplice.Transcripts{i}) &lt; 1
0104         <span class="keyword">elseif</span> AltSplice.Expression(i) == 0
0105             fprintf(<span class="string">'Probe: %i, Transcript: %s, Expression: %i\n'</span>,AltSplice.Locus(i),AltSplice.Transcripts{i},AltSplice.Expression(i));
0106          <span class="comment">%   locusNE(cnt1,1) = input('What is the proper locii? ');</span>
0107                      locusNE(cnt1,1) = AltSplice.Locus(i);<span class="comment">%input('What is the proper locii? ');</span>
0108             cnt1=cnt1+1;
0109         <span class="keyword">elseif</span> AltSplice.Expression(i) == 1
0110             fprintf(<span class="string">'Probe: %i, Transcript: %s, Expression: %i\n'</span>,AltSplice.Locus(i),AltSplice.Transcripts{i},AltSplice.Expression(i));
0111            <span class="comment">% locusE(cnt2,1) = input('What is the proper locii? ');</span>
0112             locusE(cnt2,1) = AltSplice.Locus(i);<span class="comment">% Hack by Maike %input('What is the proper locii? ');</span>
0113             cnt2=cnt2+1;
0114         <span class="keyword">end</span>
0115     <span class="keyword">end</span>
0116 
0117     locusP = [Results.Expressed;Transcripts.Expressed;locusE];
0118     locusNP = [Results.UnExpressed;Transcripts.UnExpressed;locusNE];
0119     
0120     genePresenceP = ones(length(locusP),1);
0121     genePresenceNP = zeros(length(locusNP),1);
0122     
0123     locus = [locusP;locusNP];
0124     genePresence = [genePresenceP;genePresenceNP];
0125 <span class="keyword">else</span>
0126     locus = expressionData.Locus;
0127     genePresence = zeros(length(locus),1);
0128     genePresence(find(expressionData.Data(:,1))) = 1;
0129 <span class="keyword">end</span>
0130 
0131 <span class="comment">% Mapping probes to reactions in model</span>
0132 [ExpressedRxns,UnExpressedRxns,unknown] = <a href="#_sub2" class="code" title="subfunction [rxnExpressed,unExpressed,unknown] = mapProbes(parsedGPR,corrRxn,locus,genePresence)">mapProbes</a>(parsedGPR,corrRxn,locus,genePresence);
0133 
0134 <span class="comment">% Removing exchange reactions that are not in this specific tissue</span>
0135 <span class="comment">% metabolome</span>
0136 <span class="keyword">if</span> ~isempty(exRxnRemove)
0137     model = <a href="removeRxns.html" class="code" title="function modelOut = removeRxns(model,rxnRemoveList,irrevFlag,metFlag)">removeRxns</a>(model,exRxnRemove);
0138 <span class="keyword">end</span>
0139 
0140 nRxns = length(model.lb);
0141 
0142 <span class="comment">% Determine reaction indices of expressed and unexpressed reactions</span>
0143 RHindex = <a href="../../cobra/findRxnIDs.html" class="code" title="function rxnID = findRxnIDs(model,rxnList)">findRxnIDs</a>(model,ExpressedRxns);
0144 RLindex = <a href="../../cobra/findRxnIDs.html" class="code" title="function rxnID = findRxnIDs(model,rxnList)">findRxnIDs</a>(model,UnExpressedRxns);
0145 
0146 <span class="keyword">switch</span> solver
0147     <span class="keyword">case</span> <span class="string">'Shlomi'</span>
0148         
0149         S = model.S;
0150         lb = model.lb;
0151         ub = model.ub;
0152         eps = 1;
0153         
0154         <span class="comment">% Creating A matrix</span>
0155         A = sparse(size(S,1)+2*length(RHindex)+2*length(RLindex),size(S,2)+2*length(RHindex)+length(RLindex));
0156         [nConstr,nVar] = size(S);
0157         [m,n,s] = find(S);
0158         <span class="keyword">for</span> i = 1:length(m)
0159             A(m(i),n(i)) = s(i);
0160         <span class="keyword">end</span>
0161         
0162         <span class="keyword">for</span> i = 1:length(RHindex)
0163             A(i+size(S,1),RHindex(i)) = 1;
0164             A(i+size(S,1),i+size(S,2)) = lb(RHindex(i)) - eps;
0165             A(i+size(S,1)+length(RHindex),RHindex(i)) = 1;
0166             A(i+size(S,1)+length(RHindex),i+size(S,2)+length(RHindex)+length(RLindex)) = ub(RHindex(i)) + eps;
0167         <span class="keyword">end</span>
0168         
0169         <span class="keyword">for</span> i = 1:length(RLindex)
0170             A(i+size(S,1)+2*length(RHindex),RLindex(i)) = 1;
0171             A(i+size(S,1)+2*length(RHindex),i+size(S,2)+length(RHindex)) = lb(RLindex(i));
0172             A(i+size(S,1)+2*length(RHindex)+length(RLindex),RLindex(i)) = 1;
0173             A(i+size(S,1)+2*length(RHindex)+length(RLindex),i+size(S,2)+length(RHindex)) = ub(RLindex(i));
0174         <span class="keyword">end</span>
0175         
0176         <span class="comment">% Creating csense</span>
0177         csense1(1:size(S,1)) = <span class="string">'E'</span>;
0178         csense2(1:length(RHindex)) = <span class="string">'G'</span>;
0179         csense3(1:length(RHindex)) = <span class="string">'L'</span>;
0180         csense4(1:length(RLindex)) = <span class="string">'G'</span>;
0181         csense5(1:length(RLindex)) = <span class="string">'L'</span>;
0182         csense = [csense1 csense2 csense3 csense4 csense5];
0183         
0184         <span class="comment">% Creating lb and ub</span>
0185         lb_y = zeros(2*length(RHindex)+length(RLindex),1);
0186         ub_y = ones(2*length(RHindex)+length(RLindex),1);
0187         lb = [lb;lb_y];
0188         ub = [ub;ub_y];
0189         
0190         <span class="comment">% Creating c</span>
0191         c_v = zeros(size(S,2),1);
0192         c_y = ones(2*length(RHindex)+length(RLindex),1);
0193         c = [c_v;c_y];
0194         
0195         <span class="comment">% Creating b</span>
0196         b_s = zeros(size(S,1),1);
0197         lb_rh = lb(RHindex);
0198         ub_rh = ub(RHindex);
0199         lb_rl = lb(RLindex);
0200         ub_rl = ub(RLindex);
0201         b = [b_s;lb_rh;ub_rh;lb_rl;ub_rl];
0202         
0203         <span class="comment">% Creating vartype</span>
0204         vartype1(1:size(S,2),1) = <span class="string">'C'</span>;
0205         vartype2(1:2*length(RHindex)+length(RLindex),1) = <span class="string">'B'</span>;
0206         vartype = [vartype1;vartype2];
0207         n_int = length(vartype2);
0208         
0209         MILPproblem.A = A;
0210         MILPproblem.b = b;
0211         MILPproblem.c = c;
0212         MILPproblem.lb = lb;
0213         MILPproblem.ub = ub;
0214         MILPproblem.csense = csense;
0215         MILPproblem.vartype = vartype;
0216         MILPproblem.osense = -1;
0217         MILPproblem.x0 = [];
0218 
0219         verboseFlag = true;
0220         
0221         solution = <a href="../../cobra/solvers/solveCobraMILP.html" class="code" title="function solution = solveCobraMILP(MILPproblem,varargin)">solveCobraMILP</a>(MILPproblem);
0222         
0223         Rxns.solution = solution;
0224         
0225         x = solution.cont;
0226         <span class="keyword">for</span> i = 1:length(x)
0227             <span class="keyword">if</span> abs(x(i)) &lt; 1e-6
0228                 x(i,1) = 0;
0229             <span class="keyword">end</span>
0230         <span class="keyword">end</span>
0231         
0232         removed = find(x==0);
0233         <span class="comment">% option to leave orphan reactions</span>
0234         <span class="keyword">if</span> orphan == 1
0235             orphans = findorphanRxns(model);
0236             removed(find(ismember(model.rxns(removed),orphans)))=[]; 
0237         <span class="keyword">end</span>
0238         rxnRemList = model.rxns(removed);
0239         tissueModel = <a href="removeRxns.html" class="code" title="function modelOut = removeRxns(model,rxnRemoveList,irrevFlag,metFlag)">removeRxns</a>(model,rxnRemList);
0240         
0241         Rxns.Expressed = ExpressedRxns;
0242         Rxns.UnExpressed = UnExpressedRxns;
0243         Rxns.unknown = unknown;
0244         
0245         x = ismember(UnExpressedRxns,tissueModel.rxns);
0246         loc = find(x);
0247         Rxns.UpRegulated = UnExpressedRxns(loc);
0248         
0249         x = ismember(ExpressedRxns,tissueModel.rxns);
0250         loc = find(x==0);
0251         Rxns.DownRegulated = ExpressedRxns(loc);
0252         
0253         x = ismember(model.rxns,[ExpressedRxns;UnExpressedRxns]);
0254         loc = find(x==0);
0255         x = ismember(tissueModel.rxns,model.rxns(loc));
0256         loc = find(x);
0257         Rxns.UnknownIncluded = tissueModel.rxns(loc);
0258         
0259     <span class="keyword">case</span> <span class="string">'GIMME'</span>
0260         x = ismember(model.rxns,[ExpressedRxns;UnExpressedRxns]);
0261         unk = find(x==0);
0262         
0263         expressionCol = zeros(length(model.rxns),1);
0264         <span class="keyword">for</span> i = 1:length(unk)
0265             expressionCol(unk(i)) = -1;
0266         <span class="keyword">end</span>
0267         
0268         <span class="keyword">for</span> i = 1:length(RHindex)
0269             expressionCol(RHindex(i)) = 2;
0270         <span class="keyword">end</span>
0271         
0272         <span class="keyword">if</span> ~exist(<span class="string">'options'</span>,<span class="string">'var'</span>) || isempty(options)
0273             loc = find(model.c);
0274             
0275             sol = <a href="../../cobra/optimizeCbModel.html" class="code" title="function FBAsolution = optimizeCbModel(model,osenseStr, minNorm, allowLoops)">optimizeCbModel</a>(model);
0276             
0277             options = [loc 0.9];
0278         <span class="keyword">end</span>
0279         
0280         cutoff = 1;
0281         [reactionActivity,reactionActivityIrrev,model2gimme,gimmeSolution] = <a href="#_sub1" class="code" title="subfunction [reactionActivity,reactionActivityIrrev,model2gimme,gimmeSolution] = solveGimme(model,objectiveCol,expressionCol,cutoff)">solveGimme</a>(model,options,expressionCol,cutoff);
0282         
0283         remove = model.rxns(find(reactionActivity == 0));
0284         tissueModel = <a href="removeRxns.html" class="code" title="function modelOut = removeRxns(model,rxnRemoveList,irrevFlag,metFlag)">removeRxns</a>(model,remove);
0285         
0286         <span class="keyword">if</span> funcModel ==1
0287             c = tissueModel.c;
0288             
0289             remove = [];
0290             tissueModel.c = zeros(length(tissueModel.c),1);
0291             <span class="keyword">for</span> i = 1:length(tissueModel.rxns)
0292                 tissueModel.c(i) = 1;
0293                 sol1 = <a href="../../cobra/optimizeCbModel.html" class="code" title="function FBAsolution = optimizeCbModel(model,osenseStr, minNorm, allowLoops)">optimizeCbModel</a>(tissueModel,<span class="string">'max'</span>);
0294                 sol2 = <a href="../../cobra/optimizeCbModel.html" class="code" title="function FBAsolution = optimizeCbModel(model,osenseStr, minNorm, allowLoops)">optimizeCbModel</a>(tissueModel,<span class="string">'min'</span>);
0295                 <span class="keyword">if</span> sol1.f == 0 &amp; sol2.f == 0
0296                     remove = [remove tissueModel.rxns(i)];
0297                 <span class="keyword">end</span>
0298                 tissueModel.c(i) = 0;
0299             <span class="keyword">end</span>
0300             
0301             tissueModel.c = c;
0302             tissueModel = <a href="removeRxns.html" class="code" title="function modelOut = removeRxns(model,rxnRemoveList,irrevFlag,metFlag)">removeRxns</a>(tissueModel,remove);
0303         <span class="keyword">end</span>
0304         
0305         Rxns.Expressed = ExpressedRxns;
0306         Rxns.UnExpressed = UnExpressedRxns;
0307         Rxns.unknown = unknown;
0308         
0309         x = ismember(UnExpressedRxns,tissueModel.rxns);
0310         loc = find(x);
0311         Rxns.UpRegulated = UnExpressedRxns(loc);
0312         
0313         x = ismember(ExpressedRxns,tissueModel.rxns);
0314         loc = find(x==0);
0315         Rxns.DownRegulated = ExpressedRxns(loc);
0316         
0317         x = ismember(model.rxns,[ExpressedRxns;UnExpressedRxns]);
0318         loc = find(x==0);
0319         x = ismember(tissueModel.rxns,model.rxns(loc));
0320         loc = find(x);
0321         Rxns.UnknownIncluded = tissueModel.rxns(loc);
0322         
0323 <span class="keyword">end</span>
0324 
0325 <span class="comment">%% Internal Functions</span>
0326 <a name="_sub1" href="#_subfunctions" class="code">function [reactionActivity,reactionActivityIrrev,model2gimme,gimmeSolution] = solveGimme(model,objectiveCol,expressionCol,cutoff)</a>
0327 
0328 nRxns = size(model.S,2);
0329 
0330 <span class="comment">%first make model irreversible</span>
0331 [modelIrrev,matchRev,rev2irrev,irrev2rev] = <a href="../../cobra/convertToIrreversible.html" class="code" title="function [modelIrrev,matchRev,rev2irrev,irrev2rev] = convertToIrreversible(model)">convertToIrreversible</a>(model);
0332 
0333 nExpressionCol = size(expressionCol,1);
0334 <span class="keyword">if</span> (nExpressionCol &lt; nRxns)
0335     display(<span class="string">'Warning: Fewer expression data inputs than reactions'</span>);
0336     expressionCol(nExpressionCol+1:nRxns,:) = zeros(nRxns-nExpressionCol, size(expressionCol,2));
0337 <span class="keyword">end</span>
0338 
0339 nIrrevRxns = size(irrev2rev,1);
0340 expressionColIrrev = zeros(nIrrevRxns,1);
0341 <span class="keyword">for</span> i=1:nIrrevRxns
0342 <span class="comment">%     objectiveColIrrev(i,:) = objectiveCol(irrev2rev(i,1),:);</span>
0343     expressionColIrrev(i,1) = expressionCol(irrev2rev(i,1),1);
0344 <span class="keyword">end</span>
0345     
0346 nObjectives = size(objectiveCol,1);
0347 <span class="keyword">for</span> i=1:nObjectives
0348     objectiveColIrrev(i,:) = [rev2irrev{objectiveCol(i,1),1}(1,1) objectiveCol(i,2)];
0349 <span class="keyword">end</span>
0350 
0351 <span class="comment">%Solve initially to get max for each objective</span>
0352 <span class="keyword">for</span> i=1:size(objectiveCol)
0353     <span class="comment">%define parameters for initial solution</span>
0354     modelIrrev.c=zeros(nIrrevRxns,1);
0355     modelIrrev.c(objectiveColIrrev(i,1),1)=1;
0356     
0357     <span class="comment">%find max objective</span>
0358     FBAsolution = <a href="../../cobra/optimizeCbModel.html" class="code" title="function FBAsolution = optimizeCbModel(model,osenseStr, minNorm, allowLoops)">optimizeCbModel</a>(modelIrrev);
0359     <span class="keyword">if</span> (FBAsolution.stat ~= 1)
0360         not_solved=1;
0361         display(<span class="string">'Failed to solve initial FBA problem'</span>);
0362         <span class="keyword">return</span>
0363     <span class="keyword">end</span>
0364     maxObjective(i)=FBAsolution.f;
0365 <span class="keyword">end</span>
0366 
0367 model2gimme = modelIrrev;
0368 model2gimme.c = zeros(nIrrevRxns,1);
0369 
0370 
0371 <span class="keyword">for</span> i=1:nIrrevRxns
0372     <span class="keyword">if</span> (expressionColIrrev(i,1) &gt; -1)   <span class="comment">%if not absent reaction</span>
0373         <span class="keyword">if</span> (expressionColIrrev(i,1) &lt; cutoff)
0374             model2gimme.c(i,1) = cutoff-expressionColIrrev(i,1);
0375         <span class="keyword">end</span>
0376     <span class="keyword">end</span>
0377 <span class="keyword">end</span>
0378 
0379 <span class="keyword">for</span> i=1:size(objectiveColIrrev,1)
0380     model2gimme.lb(objectiveColIrrev(i,1),1) = objectiveColIrrev(i,2) * maxObjective(i);
0381 <span class="keyword">end</span>
0382 
0383 gimmeSolution = <a href="../../cobra/optimizeCbModel.html" class="code" title="function FBAsolution = optimizeCbModel(model,osenseStr, minNorm, allowLoops)">optimizeCbModel</a>(model2gimme,<span class="string">'min'</span>);
0384 
0385 <span class="keyword">if</span> (gimmeSolution.stat ~= 1)
0386 <span class="comment">%%        gimme_not_solved=1;</span>
0387 <span class="comment">%        display('Failed to solve GIMME problem');</span>
0388 <span class="comment">%        return</span>
0389 gimmeSolution.x = zeros(nIrrevRxns,1);
0390 <span class="keyword">end</span>
0391 
0392 reactionActivityIrrev = zeros(nIrrevRxns,1);
0393 <span class="keyword">for</span> i=1:nIrrevRxns
0394     <span class="keyword">if</span> ((expressionColIrrev(i,1) &gt; cutoff) | (expressionColIrrev(i,1) == -1))
0395         reactionActivityIrrev(i,1)=1;
0396     <span class="keyword">elseif</span> (gimmeSolution.x(i,1) &gt; 0)
0397         reactionActivityIrrev(i,1)=2;
0398     <span class="keyword">end</span>
0399 <span class="keyword">end</span>
0400         
0401 <span class="comment">%Translate reactionActivity to reversible model</span>
0402 reactionActivity = zeros(nRxns,1);
0403 <span class="keyword">for</span> i=1:nRxns
0404     <span class="keyword">for</span> j=1:size(rev2irrev{i,1},2)
0405         <span class="keyword">if</span> (reactionActivityIrrev(rev2irrev{i,1}(1,j)) &gt; reactionActivity(i,1))
0406             reactionActivity(i,1) = reactionActivityIrrev(rev2irrev{i,1}(1,j));
0407         <span class="keyword">end</span>
0408     <span class="keyword">end</span>
0409 <span class="keyword">end</span>
0410 
0411 <a name="_sub2" href="#_subfunctions" class="code">function [rxnExpressed,unExpressed,unknown] = mapProbes(parsedGPR,corrRxn,locus,genePresence)</a>
0412 
0413 rxnExpressed = [];
0414 unExpressed = [];
0415 unknown = [];
0416 <span class="keyword">for</span> i = 1:size(parsedGPR,1)
0417     cnt = 0;
0418     <span class="keyword">for</span> j = 1:size(parsedGPR,2)
0419         <span class="keyword">if</span> length(parsedGPR{i,j}) == 0
0420             <span class="keyword">break</span>
0421         <span class="keyword">end</span>
0422         cnt = cnt+1;
0423     <span class="keyword">end</span>
0424     
0425     test = 0;
0426     cnt2 = 0;
0427     <span class="keyword">for</span> j = 1:cnt
0428         loc = str2num(parsedGPR{i,j});
0429         loc = floor(loc);
0430         x = find(locus == loc);
0431         <span class="keyword">if</span> length(x) &gt; 0 &amp; genePresence(x) == 0
0432             unExpressed = [unExpressed;corrRxn(i)];
0433             test = 1;
0434             <span class="keyword">break</span>
0435         <span class="keyword">elseif</span> length(x) == 0
0436             unknown = [unknown;corrRxn(i)];
0437             test = 1;
0438             <span class="keyword">break</span>
0439         <span class="keyword">end</span>
0440     <span class="keyword">end</span>
0441     
0442     <span class="keyword">if</span> test == 0
0443         rxnExpressed = [rxnExpressed;corrRxn(i)];  
0444     <span class="keyword">end</span>
0445 <span class="keyword">end</span>
0446 
0447 rxnExpressed = unique(rxnExpressed);
0448 unExpressed = unique(unExpressed);
0449 unknown = unique(unknown);
0450 
0451 unknown = setdiff(unknown,rxnExpressed);
0452 unknown = setdiff(unknown,unExpressed);
0453 unExpressed = setdiff(unExpressed,rxnExpressed);
0454 
0455 <a name="_sub3" href="#_subfunctions" class="code">function [parsedGPR,corrRxn] = extractGPRs(model)</a>
0456 
0457 warning off all
0458 
0459 parsedGPR = [];
0460 corrRxn = [];
0461 cnt = 1;
0462 
0463 <span class="keyword">for</span> i = 1:length(model.rxns)
0464     <span class="keyword">if</span> length(model.grRules{i}) &gt; 1
0465         <span class="comment">% Parsing each reactions gpr</span>
0466         [parsing{1,1},parsing{2,1}] = strtok(model.grRules{i},<span class="string">'or'</span>);
0467         <span class="keyword">for</span> j = 2:1000
0468             [parsing{j,1},parsing{j+1,1}] = strtok(parsing{j,1},<span class="string">'or'</span>);
0469             <span class="keyword">if</span> isempty(parsing{j+1,1})==1
0470                 <span class="keyword">break</span>
0471             <span class="keyword">end</span>
0472         <span class="keyword">end</span>
0473         
0474         <span class="keyword">for</span> j = 1:length(parsing)
0475             <span class="keyword">for</span> k = 1:1000
0476                 [parsing{j,k},parsing{j,k+1}] = strtok(parsing{j,k},<span class="string">'and'</span>);
0477                 <span class="keyword">if</span> isempty(parsing{j,k+1})==1
0478                     <span class="keyword">break</span>
0479                 <span class="keyword">end</span>
0480             <span class="keyword">end</span>
0481         <span class="keyword">end</span>
0482         
0483         <span class="keyword">for</span> j = 1:size(parsing,1)
0484             <span class="keyword">for</span> k = 1:size(parsing,2)
0485                 parsing{j,k} = strrep(parsing{j,k},<span class="string">'('</span>,<span class="string">''</span>);
0486                 parsing{j,k} = strrep(parsing{j,k},<span class="string">')'</span>,<span class="string">''</span>);
0487                 parsing{j,k} = strrep(parsing{j,k},<span class="string">' '</span>,<span class="string">''</span>);
0488             <span class="keyword">end</span>
0489         <span class="keyword">end</span>
0490         
0491         <span class="keyword">for</span> j = 1:size(parsing,1)-1
0492             newparsing(j,:) = parsing(j,1:length(parsing(j,:))-1);
0493         <span class="keyword">end</span>
0494         
0495         parsing = newparsing;
0496         
0497      
0498         <span class="keyword">for</span> j = 1:size(parsing,1)
0499             <span class="keyword">for</span> k = 1:size(parsing,2)
0500                 <span class="keyword">if</span> length(parsing{j,k}) == 0
0501                     parsing{j,k} = <span class="string">''</span>;                    
0502                 <span class="keyword">end</span>
0503             <span class="keyword">end</span>
0504         <span class="keyword">end</span>
0505         
0506               
0507         num = size(parsing,1);
0508         <span class="keyword">for</span> j = 1:num
0509             sizeP = length(parsing(j,:));
0510             <span class="keyword">if</span> sizeP &gt; size(parsedGPR,2)
0511                 <span class="keyword">for</span> k = 1:size(parsedGPR,1)
0512                     parsedGPR{k,sizeP} = {<span class="string">''</span>};
0513                 <span class="keyword">end</span>
0514             <span class="keyword">end</span>
0515             
0516             <span class="keyword">for</span> l = 1:sizeP          
0517             parsedGPR{cnt,l} = parsing(j,l);
0518             <span class="keyword">end</span>           
0519             cnt = cnt+1;
0520         <span class="keyword">end</span>
0521         
0522         <span class="keyword">for</span> j = 1:num
0523             corrRxn = [corrRxn;model.rxns(i)];
0524         <span class="keyword">end</span>
0525         
0526         clear parsing newparsing
0527         
0528     <span class="keyword">end</span>
0529     
0530 <span class="keyword">end</span>
0531 
0532 <span class="keyword">for</span> i = 1:size(parsedGPR,1)
0533     <span class="keyword">for</span> j = 1:size(parsedGPR,2)
0534         <span class="keyword">if</span> isempty(parsedGPR{i,j}) == 1
0535             parsedGPR{i,j} = {<span class="string">''</span>};
0536         <span class="keyword">end</span>
0537     <span class="keyword">end</span>
0538 <span class="keyword">end</span>
0539 
0540 i =1 ;
0541 sizeP = size(parsedGPR,1);
0542 <span class="keyword">while</span> i &lt; sizeP
0543     <span class="keyword">if</span> strcmp(parsedGPR{i,1},{<span class="string">''</span>}) == 1
0544         parsedGPR = [parsedGPR(1:i-1,:);parsedGPR(i+1:<span class="keyword">end</span>,:)];
0545         corrRxn = [corrRxn(1:i-1,:);corrRxn(i+1:<span class="keyword">end</span>,:)];
0546         sizeP = sizeP-1;        
0547         i=i-1;
0548     <span class="keyword">end</span>
0549     i = i+1;
0550 <span class="keyword">end</span>
0551 
0552 <span class="keyword">for</span> i = 1:size(parsedGPR,1)
0553     <span class="keyword">for</span> j= 1:size(parsedGPR,2)
0554         parsedGPR2(i,j) = cellstr(parsedGPR{i,j});
0555     <span class="keyword">end</span>
0556 <span class="keyword">end</span>
0557 
0558 parsedGPR = parsedGPR2;
0559 
0560 <a name="_sub4" href="#_subfunctions" class="code">function [Results,Transcripts] = charExpData(ExpressionData)</a>
0561 
0562 n = length(ExpressionData.Locus);
0563 Locus = ExpressionData.Locus;
0564 
0565 ExpThreshold = floor(0.75*size(ExpressionData.Data,2))/size(ExpressionData.Data,2);
0566 UnExpThreshold = ceil(0.25*size(ExpressionData.Data,2))/size(ExpressionData.Data,2);
0567 Results.Expressed = [];
0568 Results.UnExpressed = [];
0569 Results.AltSplice = [];
0570 Results.Total = 0;
0571 <span class="keyword">for</span> i = 1:n
0572     <span class="keyword">if</span> ExpressionData.Locus(i) &gt; 0
0573         
0574         locus = ExpressionData.Locus(i);
0575         loc = find(ExpressionData.Locus == locus);
0576         cap = length(loc)*size(ExpressionData.Data,2)*2;
0577         
0578         <span class="keyword">for</span> j = 1:length(loc)
0579             total(j) = sum(ExpressionData.Data(loc(j),:));
0580             ExpressionData.Locus(loc(j)) = 0;
0581         <span class="keyword">end</span>
0582         
0583         transcripts = {};
0584         <span class="keyword">for</span> j = 1:length(loc)
0585             <span class="keyword">if</span> length(ExpressionData.Transcript{loc(j)}) &gt; 0
0586                 transcripts = [transcripts;ExpressionData.Transcript{loc(j)}];
0587             <span class="keyword">end</span>
0588         <span class="keyword">end</span>
0589         
0590         <span class="keyword">if</span> length(unique(transcripts)) &lt;= 1
0591             
0592             <span class="comment">% Overall expression patterns (&gt; 75% in binary data, Expressed)</span>
0593             <span class="keyword">if</span> sum(total)/cap &gt;= ExpThreshold
0594                 Results.Expressed = [Results.Expressed;locus];
0595             <span class="comment">% If &lt; 25% in binary data, UnExpressed</span>
0596             <span class="keyword">elseif</span> sum(total)/cap &lt;= UnExpThreshold
0597                 Results.UnExpressed = [Results.UnExpressed;locus];
0598             
0599             <span class="comment">% Accounting for different probes and their binding positions</span>
0600             <span class="keyword">else</span>
0601                 cntP = 0;
0602                 <span class="keyword">for</span> j = 1:length(total)
0603                     
0604                     <span class="comment">% Threshold once again, 75%</span>
0605                     <span class="keyword">if</span> total(j) &gt;= floor(0.75*size(ExpressionData.Data,2))*2;
0606                         cntP = cntP+1;
0607                     <span class="keyword">end</span>
0608                 <span class="keyword">end</span>
0609                 
0610                 <span class="comment">% If 50% or more of the probes have met the threshold,</span>
0611                 <span class="comment">% expressed</span>
0612                 <span class="keyword">if</span> cntP/length(total) &gt;= 0.5
0613                     Results.Expressed = [Results.Expressed;locus];
0614                 <span class="keyword">else</span>
0615                     Results.UnExpressed = [Results.UnExpressed;locus];
0616                 <span class="keyword">end</span>
0617             <span class="keyword">end</span>
0618         <span class="keyword">else</span>
0619             
0620             <span class="comment">% If different RefSeq Accession codes, different transcripts,</span>
0621             <span class="comment">% must be manually curated</span>
0622             Results.AltSplice = [Results.AltSplice;locus];
0623         <span class="keyword">end</span>
0624         Results.Total = Results.Total+1;
0625         clear total
0626     <span class="keyword">end</span>
0627 <span class="keyword">end</span>
0628 
0629 <span class="comment">% Setting up different transcripts for manual curation</span>
0630 Transcripts.Locus = [];
0631 Transcripts.Data = {};
0632 <span class="keyword">for</span> i = 1:length(Results.AltSplice)
0633     num = find(Locus==Results.AltSplice(i));
0634     transcripts = unique(ExpressionData.Transcript(num));
0635     <span class="keyword">for</span> j = 1:length(transcripts)
0636         Transcripts.Locus = [Transcripts.Locus;Results.AltSplice(i)];
0637     <span class="keyword">end</span>
0638     Transcripts.Data = [Transcripts.Data;transcripts];
0639 <span class="keyword">end</span>
0640 
0641 <span class="comment">% Determining each transcripts expression using a similar threshold as</span>
0642 <span class="comment">% before</span>
0643 <span class="keyword">for</span> i = 1:length(Transcripts.Data)
0644     loc = strmatch(Transcripts.Data{i},ExpressionData.Transcript,<span class="string">'exact'</span>);
0645     <span class="keyword">for</span> j = 1:length(loc)
0646         total(j) = sum(ExpressionData.Data(loc(j),:));
0647         ExpressionData.Locus(loc(j)) = 0;
0648     <span class="keyword">end</span>
0649     cap = length(loc)*11*2;
0650     <span class="keyword">if</span> sum(total)/cap &gt;= ExpThreshold
0651         Transcripts.Expression(i,1) = 1;
0652     <span class="keyword">else</span>
0653         Transcripts.Expression(i,1) = 0;
0654     <span class="keyword">end</span>
0655 <span class="keyword">end</span>
0656 
0657 <span class="comment">% If expression of transcripts of one locus are the same, added as if no</span>
0658 <span class="comment">% alternative splicing occurs for simplicity</span>
0659 Transcripts.Expressed = [];
0660 Transcripts.UnExpressed = [];
0661 mem_tran = Transcripts.Locus;
0662 <span class="keyword">for</span> i = 1:length(Transcripts.Locus)
0663     <span class="keyword">if</span> Transcripts.Locus(i) &gt; 0
0664         locus = Transcripts.Locus(i);
0665         loc = find(Transcripts.Locus==locus);
0666         sumExp = 0;
0667         <span class="keyword">for</span> j = 1:length(loc)
0668             sumExp = sumExp+Transcripts.Expression(loc(j));
0669             Transcripts.Locus(loc(j)) = 0;
0670         <span class="keyword">end</span>
0671         <span class="keyword">if</span> sumExp == 0
0672             Transcripts.UnExpressed = [Transcripts.UnExpressed;locus];
0673         <span class="keyword">elseif</span> sumExp == length(loc)
0674             Transcripts.Expressed = [Transcripts.Expressed;locus];
0675         <span class="keyword">end</span>
0676     <span class="keyword">end</span>
0677 <span class="keyword">end</span>
0678 Transcripts.Locus = mem_tran;</pre></div>
<hr><address>Generated on Sun 26-Dec-2010 12:06:07 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" target="_parent">m2html</a></strong> &copy; 2003</address>
</body>
</html>