Index: cobra/test/solvers.py
===================================================================
--- cobra/test/solvers.py	(revision 330)
+++ cobra/test/solvers.py	(working copy)
@@ -1,5 +1,6 @@
 from unittest import TestCase, TestLoader, TextTestRunner
 import sys
+from pdb import set_trace
 # deal with absolute imports by adding the appropriate directory to the path
 sys.path.insert(0, "../..")
 from cobra.manipulation import initialize_growth_medium
@@ -14,7 +15,7 @@
         self.model = create_test_model()
         initialize_growth_medium(self.model, 'MgM')
         self.old_solution = 0.320064
-        self.infeasible_problem = Model()
+        self.infeasible_model = Model()
         metabolite_1 = Metabolite("met1")
         metabolite_2 = Metabolite("met2")
         reaction_1 = Reaction("rxn1")
@@ -23,8 +24,8 @@
         reaction_2.add_metabolites({metabolite_2: 1})
         reaction_1.lower_bound = 1
         reaction_2.upper_bound = 2
-        self.infeasible_problem.add_reactions([reaction_1, reaction_2])
-        #self.infeasible_problem.update()
+        self.infeasible_model.add_reactions([reaction_1, reaction_2])
+        #self.infeasible_model.update()
 
 
 def add_new_test(TestCobraSolver, solver_name, solver):
@@ -39,22 +40,128 @@
     def test_setup(self):
         solver.create_problem(self.model)
     def test_solve_feasible(self):
-        solution = solver.solve(self.model)
+        solver.solve(self.model)
+        solution = self.model.solution        
         self.assertEqual(solution.status, "optimal")
         self.assertAlmostEqual(self.old_solution, \
-            solution.objective_value, places=4)
+            solution.f, places=4)
+    def test_solve_minimize(self):
+        solver.solve(self.model, objective_sense='minimize')
+        solution = self.model.solution        
+        self.assertEqual(solution.status, "optimal")
+        self.assertAlmostEqual(0, \
+            solution.f, places=4)
+    def test_solve_mip(self):
+        cone_selling_price = 7.
+        cone_production_cost = 3.
+        popsicle_selling_price = 2.
+        popsicle_production_cost = 1.
+        starting_budget = 100.
+        cobra_model = Model('MILP_implementation_test')
+        cone_out = Metabolite(id='cone_out', compartment='c')
+        cone_in = Metabolite(id='cone_in', compartment='c')
+        cone_consumed = Metabolite(id='cone_consumed', compartment='c')
+
+        popsicle_out = Metabolite(id='popsicle_out', compartment='c')
+        popsicle_in = Metabolite(id='popsicle_in', compartment='c')
+        popsicle_consumed = Metabolite(id='popsicle_consumed', compartment='c')
+
+        the_reactions = []
+
+        # SOURCE
+        Cone_source = Reaction(name='Cone_source')
+        temp_metabolite_dict = {cone_out: 1}
+        Cone_source.add_metabolites(temp_metabolite_dict)
+        the_reactions.append(Cone_source)
+
+        Popsicle_source = Reaction(name='Popsicle_source')
+        temp_metabolite_dict = {popsicle_out: 1}
+        Popsicle_source.add_metabolites(temp_metabolite_dict)
+        the_reactions.append(Popsicle_source)
+
+
+        ## PRODUCTION
+        Cone_production = Reaction(name='Cone_production')
+        temp_metabolite_dict = {cone_out: -1,
+                                cone_in: 1}
+        Cone_production.add_metabolites(temp_metabolite_dict)
+        the_reactions.append(Cone_production)
+
+
+        Popsicle_production = Reaction(name='Popsicle_production')
+        temp_metabolite_dict = {popsicle_out: -1,
+                                popsicle_in: 1}
+        Popsicle_production.add_metabolites(temp_metabolite_dict)
+        the_reactions.append(Popsicle_production)
+
+        ## CONSUMPTION
+        Cone_consumption = Reaction(name='Cone_consumption')
+        temp_metabolite_dict = {cone_in: -1,
+                                cone_consumed: 1}
+        Cone_consumption.add_metabolites(temp_metabolite_dict)
+        the_reactions.append(Cone_consumption)
+
+        Popsicle_consumption = Reaction(name='Popsicle_consumption')
+        temp_metabolite_dict = {popsicle_in: -1,
+                                popsicle_consumed: 1}
+        Popsicle_consumption.add_metabolites(temp_metabolite_dict)
+        the_reactions.append(Popsicle_consumption)
+
+        # SINK
+        Cone_consumed_sink = Reaction(name='Cone_consumed_sink')
+        temp_metabolite_dict = {cone_consumed: -1}
+        Cone_consumed_sink.add_metabolites(temp_metabolite_dict)
+        the_reactions.append(Cone_consumed_sink)
+
+        Popsicle_consumed_sink = Reaction(name='Popsicle_consumed_sink')
+        temp_metabolite_dict = {popsicle_consumed: -1}
+        Popsicle_consumed_sink.add_metabolites(temp_metabolite_dict)
+        the_reactions.append(Popsicle_consumed_sink)
+
+        ## add all reactions
+        cobra_model.add_reactions(the_reactions)
+
+        # set objective coefficients
+        Cone_consumption.objective_coefficient = cone_selling_price
+        Popsicle_consumption.objective_coefficient = popsicle_selling_price
+
+        Cone_production.objective_coefficient = -1*cone_production_cost
+        Popsicle_production.objective_coefficient = -1*popsicle_production_cost
+        
+
+        #Make sure we produce whole cones
+        Cone_production.variable_kind = 'integer'
+        Popsicle_production.variable_kind = 'integer'
+
+
+        production_capacity_constraint = Metabolite(id='production_capacity_constraint')
+        production_capacity_constraint._constraint_sense = 'L'
+        production_capacity_constraint._bound = starting_budget;
+
+        Cone_production.add_metabolites({production_capacity_constraint: cone_production_cost })
+
+        Popsicle_production.add_metabolites({production_capacity_constraint: popsicle_production_cost })
+        cobra_model.optimize()
+        self.assertEqual(133, cobra_model.solution.f)
+
+        
     def test_solve_infeasible(self):
-        solution = solver.solve(self.infeasible_problem)
+        solver.solve(self.infeasible_model)
+        solution = self.infeasible_model.solution
         self.assertEqual(solution.status, "infeasible")
+
     def test_independent_creation(self):
         feasible_lp = solver.create_problem(self.model)
-        infeasible_lp = solver.create_problem(self.infeasible_problem)
-        feasible_solution = solve_problem(lp)
-        infeasible_solution = solve_problem(lp)
+        infeasible_lp = solver.create_problem(self.infeasible_model)
+        solver.solve_problem(feasible_lp)
+        solver.solve_problem(infeasible_lp)
+        feasible_solution = solver.format_solution(feasible_lp, self.model)
+        infeasible_solution = solver.format_solution(infeasible_lp, self.infeasible_model)
         self.assertEqual(feasible_solution.status, "optimal")
         self.assertAlmostEqual(self.old_solution, \
-            feasible_solution.objective_value, places=4)
+            feasible_solution.f, places=4)
         self.assertEqual(infeasible_solution.status, "infeasible")
+
     setattr(TestCobraSolver, "test_%s_create" % solver_name, \
         test_setup)
     setattr(TestCobraSolver, "test_%s_attributes" % solver_name, \
@@ -64,7 +171,11 @@
     setattr(TestCobraSolver, "test_%s_infeasible_solve" % solver_name, \
         test_solve_infeasible)
     setattr(TestCobraSolver, "test_%s_independent_creation" % solver_name, \
-        test_solve_infeasible)
+        test_independent_creation)
+    setattr(TestCobraSolver, "test_%s_solve_minimize" % solver_name, \
+        test_solve_minimize)
+    setattr(TestCobraSolver, "test_%s_solve_mip" % solver_name, \
+        test_solve_mip)
 
 def add_legacy_test(TestCobraSolver, solver_name, solver_function):
     """Creates a test set for each of the installed solvers using the
Index: cobra/test/__init__.py
===================================================================
--- cobra/test/__init__.py	(revision 330)
+++ cobra/test/__init__.py	(working copy)
@@ -1,10 +1,14 @@
+from __future__ import with_statement, absolute_import
 from os import name as __name
-from sys import modules as __modules
 from warnings import warn
-if __name == 'java':
-    raise Exception("%s is not yet supported on jython"%__modules[__name__])
+test_import_string = 'import cobra.test.%s as %s'
+available_tests = ['unit_tests', 'solvers', 'flux_analysis']
+#if not using jython then add the tests that don't currently run through jython
+## if __name != 'java':
+##      available_tests += ['flux_analysis']
+    
 
-del __name, __modules
+del __name
 
 from os.path import abspath as __abspath
 from os.path import join as __join
@@ -24,12 +28,22 @@
 
 def create_test_model(test_pickle=salmonella_pickle):
     """returns the salmonella model for testing"""
+    from os import name as __name
     try:
         from cPickle import load
     except:
         from pickle import load
-    with open(test_pickle, "rb") as infile:
-        model = load(infile)
+
+    try: 
+        with open(test_pickle, "rb") as infile:
+            model = load(infile)
+    except:
+        #if the pickle can't be loaded then load the sbml xml
+        import sys
+        sys.path.insert(0, "../..")
+        from cobra.io import read_sbml_model
+        model = read_sbml_model(salmonella_sbml)
+        sys.path.pop(0)
     return model
 
 
@@ -38,15 +52,11 @@
     import sys
     sys.path.insert(0, "../..")
     import unittest
-    from cobra.test.unit_tests import test_all
-    print '###running general unit tests###'
-    test_all()
-    from cobra.test.flux_analysis import test_all
-    print '\n###running flux_analysis unit tests###'
-    test_all()
-    print '\n###running solver unit tests###'
-    from cobra.test.solvers import test_all
-    test_all()
+    for the_test in available_tests:
+        exec(test_import_string%(the_test, the_test))
+        print '\n\n###running %s tests###'%the_test
+        eval('%s.test_all()'%the_test)
+        
     sys.path.pop(0)
 
 del __abspath, __join, __split, __sep
Index: cobra/test/flux_analysis.py
===================================================================
--- cobra/test/flux_analysis.py	(revision 330)
+++ cobra/test/flux_analysis.py	(working copy)
@@ -1,4 +1,6 @@
 from unittest import TestCase, TestLoader, TextTestRunner
+
+from warnings import warn
 import sys
 sys.path.insert(0, "../..")
 from cobra.test import create_test_model
@@ -44,7 +46,10 @@
     def test_double_deletion(self):
         """
         """
-        
+        from os import name as __name
+        if __name == 'java':
+            warn("cobra.test.flux_analysis.test_double_deletion doesn't yet work with java")
+            return
         cobra_model = self.model
         #turn into a double deletion unit test
         the_problem='return'
@@ -90,7 +95,9 @@
                                             the_reactions=cobra_model.reactions[100:140])
         fva_out = dict([(k.id, v) for k, v in fva_out.items()])
         for the_reaction, the_range in fva_out.iteritems():
+            #print the_reaction
             for k, v in the_range.iteritems():
+                #print " %s: %s vs %s"%(k, repr(fva_results[the_reaction][k]), repr(v))
                 self.assertAlmostEqual(fva_results[the_reaction][k], v, places=3)
         ## blocked_reactions = find_blocked_reactions(cobra_model)
         ## open_ex_blocked = find_blocked_reactions(cobra_model,
@@ -99,15 +106,16 @@
     def test_assess_medium_component_essentiality(self):
         """
 
-        TODO: Add in a numerical value test
+
         """
-        essentiality_results = {'EX_ser__L_e': 0.28511251509333996, 'EX_cobalt2_e': 0.0, 'EX_glu__L_e': 0.18551423955187463, 'EX_glyc_e': 0.02162967396132975, 'EX_h_e': 0.18551423955211313, 'EX_mobd_e': 0.0, 'EX_val__L_e': 0.18004717981556367, 'EX_so4_e': 0.1800471798156284, 'EX_co2_e': 0.18004717981574314, 'EX_k_e': 5.048709793414476e-29, 'EX_fe3_e': -3.4331226595218434e-27, 'EX_na1_e': 0.18004717981556367, 'EX_cl_e': 1.7495455763604752e-28, 'EX_leu__L_e': 0.1762785172191746, 'EX_arg__L_e': 0.13025755872698241, 'EX_nh4_e': 0.09432269135782297, 'EX_lys__L_e': 0.43718843672718055, 'EX_ala__L_e': 0.4371884367334397, 'EX_thr__L_e': 0.43718843673877533, 'EX_pi_e': 4.1028325973665373e-13, 'EX_mn2_e': 0.0, 'EX_phe__L_e': 0.380007972274807, 'EX_h2o_e': 0.38000797227380473, 'EX_mg2_e': 0.0, 'EX_his__L_e': 0.38000797227522415, 'EX_o2_e': 0.3428169207281707, 'EX_pro__L_e': 0.271070547843646, 'EX_asp__L_e': 0.38000797227507915, 'EX_gly_e': 0.3800079722747013, 'EX_cys__L_e': 0.3800079722760569, 'EX_cu2_e': 9.244463733058732e-31, 'EX_ca2_e': 0.0, 'EX_tyr__L_e': 0.38000797227331706, 'EX_zn2_e': 0.0, 'EX_met__L_e': 0.38000797227265026, 'EX_ile__L_e': 0.3800079722724871}
+        essentiality_results = {'EX_ser__L_e': 0.28511251509333996, 'EX_cobalt2_e': 0.0,  'EX_glu__L_e': 0.18551423955187463, 'EX_glyc_e': 0.02162967396132975, 'EX_h_e': 0.18551423955211313, 'EX_mobd_e': 0.0, 'EX_val__L_e': 0.18004717981556367, 'EX_so4_e': 0.1800471798156284, 'EX_co2_e': 0.18004717981574314, 'EX_k_e': 5.048709793414476e-29, 'EX_fe3_e': -3.4331226595218434e-27, 'EX_na1_e': 0.18004717981556367, 'EX_cl_e': 1.7495455763604752e-28, 'EX_leu__L_e': 0.1762785172191746, 'EX_arg__L_e': 0.13025755872698241, 'EX_nh4_e': 0.09432269135782297, 'EX_lys__L_e': 0.43718843672718055, 'EX_ala__L_e': 0.4371884367334397, 'EX_thr__L_e': 0.43718843673877533, 'EX_pi_e': 4.1028325973665373e-13, 'EX_mn2_e': 0.0, 'EX_phe__L_e': 0.380007972274807, 'EX_h2o_e': 0.38000797227380473, 'EX_mg2_e': 0.0, 'EX_his__L_e': 0.38000797227522415, 'EX_o2_e': 0.3428169207281707, 'EX_pro__L_e': 0.271070547843646, 'EX_asp__L_e': 0.38000797227507915, 'EX_gly_e': 0.3800079722747013, 'EX_cys__L_e': 0.3800079722760569, 'EX_cu2_e': 9.244463733058732e-31, 'EX_ca2_e': 0.0, 'EX_tyr__L_e': 0.38000797227331706, 'EX_zn2_e': 0.0, 'EX_met__L_e': 0.38000797227265026, 'EX_ile__L_e': 0.3800079722724871}
         cobra_model = self.model
-        the_problem='return'
+        
         from cobra.flux_analysis import assess_medium_component_essentiality
         essentiality_dict = assess_medium_component_essentiality(cobra_model, None, 'MgM')
-        for k, v in essentiality_dict.iteritems():
-            self.assertAlmostEqual(essentiality_results[k], v, places=3)
+        for k, v in essentiality_results.iteritems():
+            #print "%s expected: %s / simulated: %s"%(k, repr(v), repr(essentiality_dict[k]))
+            self.assertAlmostEqual(essentiality_dict[k], v, places=3)
 
 
 
Index: cobra/test/unit_tests.py
===================================================================
--- cobra/test/unit_tests.py	(revision 330)
+++ cobra/test/unit_tests.py	(working copy)
@@ -1,13 +1,16 @@
+from __future__ import with_statement
 from unittest import TestCase, TestLoader, TextTestRunner
-#skipIf is not in python 2.6
+#skipIf is not in python 2.6 / 2.5
+from warnings import warn
 try:
     from unittest import skipIf
+    from warnings import catch_warnings
 except:
     try:
         from unittest2 import skipIf
     except:
         skipIf = None
-from warnings import catch_warnings
+
 import sys
 from os import unlink
 sys.path.insert(0, "../..")
@@ -19,7 +22,7 @@
 #from .. import flux_analysis
 
 # libraries which may or may not be installed
-libraries = ["libsbml", "glpk", "gurobipy", "cplex"]
+libraries = ["glpk", "gurobipy", "cplex"]
 for library in libraries:
     try:
         exec("import %s" % library)
@@ -60,6 +63,10 @@
         self.assertEqual(len(self.list), 9)
 
     def testAdd(self):
+        from os import name as __name
+        if __name == 'java':
+            warn('\t\n**cobra.test.unit_tests.testAdd does not yet work with %s'%__name)
+            return
         obj_list = [Object("test%d" % (i)) for i in range(2, 10)]
         sum = self.list + obj_list
         self.assertEqual(self.list[0].id, "test1")
@@ -111,34 +118,37 @@
 
 
 class TestCobraIO(CobraTestCase):
-    if skipIf is not None:
-        @skipIf(libsbml is None, "libsbml is required")
+    try:
+        from cobra.io.sbml import SBMLReader as __SBMLReader
+        __test_sbml = True
+    except:
+        __test_sbml = False
+    if __test_sbml:
         def test_sbml_read(self):
-            with catch_warnings(record=True) as w:
-                model = io.read_sbml_model(test_sbml_file)
+            ## with catch_warnings(record=True) as w:
+            model = io.read_sbml_model(test_sbml_file)
             self.assertEqual(len(model.reactions), len(self.model.reactions))
             # make sure that an error is raised when given a nonexistent file
             self.assertRaises(IOError, io.read_sbml_model,
-                "fake_file_which_does_not_exist")
-    if skipIf is not None:
-        @skipIf(libsbml is None, "libsbml is required")
+                              "fake_file_which_does_not_exist")
         def test_sbml_write(self):
             test_output_filename = 'test_sbml_write.xml'
             io.write_sbml_model(self.model, test_output_filename)
             #cleanup the test file
             unlink(test_output_filename)
-    
-    def test_mat_read_write(self):
-        test_output_filename = "test_mat_write.mat"
-        io.save_matlab_model(self.model, test_output_filename)
-        reread = io.load_matlab_model(test_output_filename)
-        self.assertEqual(len(self.model.reactions), len(reread.reactions))
-        self.assertEqual(len(self.model.metabolites), len(reread.metabolites))
-        for i in range(len(self.model.reactions)):
-            self.assertEqual(len(self.model.reactions[i]._metabolites), \
-                len(reread.reactions[i]._metabolites))
-            self.assertEqual(self.model.reactions[i].id, reread.reactions[i].id)
-        unlink(test_output_filename)
+    from os import name as __name
+    if __name != 'java':
+        def test_mat_read_write(self):
+            test_output_filename = "test_mat_write.mat"
+            io.save_matlab_model(self.model, test_output_filename)
+            reread = io.load_matlab_model(test_output_filename)
+            self.assertEqual(len(self.model.reactions), len(reread.reactions))
+            self.assertEqual(len(self.model.metabolites), len(reread.metabolites))
+            for i in range(len(self.model.reactions)):
+                self.assertEqual(len(self.model.reactions[i]._metabolites), \
+                    len(reread.reactions[i]._metabolites))
+                self.assertEqual(self.model.reactions[i].id, reread.reactions[i].id)
+            unlink(test_output_filename)
 
 # make a test suite to run all of the tests
 loader = TestLoader()
Index: cobra/flux_analysis/moma.py
===================================================================
--- cobra/flux_analysis/moma.py	(revision 330)
+++ cobra/flux_analysis/moma.py	(working copy)
@@ -1,9 +1,16 @@
+from __future__ import with_statement
 #cobra.flux_analysis.moma.py: Runs the minimization of metabolic
 #adjustment method described in Segre et al 2002 PNAS 99(23): 15112-7
+from os import name as __name
+from sys import modules as __modules
+from warnings import warn
+if __name == 'java':
+    raise Exception("%s is not yet supported on jython"%__modules[__name__])
 from copy import deepcopy
 from time import time
 from math import ceil, floor
-from numpy import array, zeros, ones, hstack, vstack, matrix, sum
+#The next four imports need to be dealt with to obtain jython compatibilty
+from numpy import array, hstack, vstack, matrix, sum
 from scipy.sparse import eye, lil_matrix, dok_matrix
 from scipy.sparse import hstack as s_hstack
 from scipy.sparse import vstack as s_vstack
Index: cobra/flux_analysis/objective.py
===================================================================
--- cobra/flux_analysis/objective.py	(revision 330)
+++ cobra/flux_analysis/objective.py	(working copy)
@@ -3,20 +3,22 @@
 from ..core.Reaction import Reaction
 from ..manipulation import initialize_growth_medium
 import sys
-if sys.maxsize > 2**32:
-    from numpy import int64, int32
+if hasattr(sys, 'maxsize') and sys.maxsize > 2**32:
+    try:
+        from numpy import int64, int32
+    except:
+        int32 = int64 = int
 else:
     int32 = int
     int64 = int
-def assess_objective( cobra_model, the_objective = None,
-                      objective_cutoff = 0.001, growth_medium = None ):
+def assess_objective(cobra_model, the_objective=None,
+                      objective_cutoff=0.001, growth_medium=None):
     """Assesses the ability of the model to produce all reactants in the_objective on
     an individual basis.  Returns True if the_objective can be realized to exceed
     objective_cutoff.  Otherwise, determines which components of the_objective are
     lagging and returns a dict of the components and their required and realized values.
 
     """
-    raise Exception("This needs to be cleaned up.")
     cobra_model = cobra_model.copy()
     if growth_medium:
         initialize_growth_medium(cobra_model, growth_medium)
@@ -24,45 +26,42 @@
     #If the model cannot achieve the objective then check each component for failure
     #to be produced.
     if the_objective is None:
-        objective_reaction = Reaction()
-        objective_reaction.populate_from_cobra_model(cobra_model, cobra_model._objective_coefficients.nonzero()[0][0])
-    elif (isinstance(the_objective, int) or  isinstance(the_objective, int64)
-           or isinstance(the_objective, int32)  or isinstance(the_objective, str)):
-        #TODO: When Model is updated to contain  Objects just
-        #copy from there
-        #objective_reaction  = deepcopy( the_model.cobra.reaction[ the_objective ] )
-        objective_reaction = Reaction()
-        objective_reaction.populate_from_cobra_model(cobra_model, the_objective)
+        #Assume a single objective reaction
+        objective_reaction = [x for x in cobra_model.reactions if x.objective_coefficient != 0][0]
     elif hasattr(the_objective, 'id'):
-        objective_reaction = the_objective
+        objective_reaction = cobra_model.reactions.get_by_id(the_objective.id) #need to get because we've copied the model
+    elif isinstance(the_objective, str):
+        objective_reaction = cobra_model.reactions.get_by_id(the_objective)
+    else:
+        #assume that it's an index
+        objective_reaction = cobra_model.reactions[the_objective]
     cobra_model.optimize(new_objective = objective_reaction)
     #First see if the model can realize the objective
     if cobra_model.solution.f >= objective_cutoff:
         return {}
     components = objective_reaction.get_reactants()
-    component_indices = map(cobra_model.metabolites.index, components)
     simulation_results = {}
     #TODO:  Speed this section up.  Possibly by modifying Model.optimize() to
     #use and updated S and reuse the basis.
-    for the_component, the_index in zip(components, component_indices):
-        #add in a demand reaction for each component
-        demand_reaction = Reaction('test_demand_' + the_component)
+    for the_component in objective_reaction.get_reactants():
+        #add in a sink reaction for each component
+        sink_reaction = Reaction('test_sink_' + the_component)
         #then simulate ability
         #then check it can exceed objective cutoff * component stoichiometric
         #coefficient.
-        tmp_coeff = objective_reaction.get_coefficient(the_component) 
-        demand_reaction.add_metabolites(the_component, tmp_coeff)
-        demand_reaction.upper_bound = 1000
-        cobra_model.add_reaction(demand_reaction)
-        cobra_model.optimize(new_objective = demand_reaction.id)
+        tmp_coefficient = objective_reaction.get_coefficient(the_component) 
+        sink_reaction.add_metabolites(the_component, tmp_coefficient)
+        sink_reaction.upper_bound = 1000
+        cobra_model.add_reaction(sink_reaction)
+        cobra_model.optimize(new_objective = sink_reaction.id)
         if objective_cutoff > cobra_model.solution.f:
-            simulation_results.update({the_component:{'required':abs(tmp_coeff*objective_cutoff), 'produced':cobra_model.solution.f}})
+            simulation_results.update({the_component:{'required':abs(tmp_coefficient*objective_cutoff), 'produced':cobra_model.solution.f}})
     return simulation_results
+
 def update_objective(cobra_model, the_objectives):
     """Revised to take advantage of the new Reaction classes.
 
     """
-    from numpy import array
     #set the objective coefficients for each reaction to 0
     [setattr(x, 'objective_coefficient', 0.)
      for x in cobra_model.reactions]
@@ -77,7 +76,3 @@
             elif isinstance(the_objective, int):
                 the_objective = cobra_model.reactions[the_objective]
         the_objective.objective_coefficient = 1.
-    #NOTE: _objective_coefficients is deprecated
-    if hasattr(cobra_model, '_objective_coefficients'):
-        cobra_model._objective_coefficients = array([x.objective_coefficient
-                                                     for x in cobra_model.reactions])
Index: cobra/flux_analysis/double_deletion.py
===================================================================
--- cobra/flux_analysis/double_deletion.py	(revision 330)
+++ cobra/flux_analysis/double_deletion.py	(working copy)
@@ -1,13 +1,26 @@
+from __future__ import with_statement
 #cobra.flux_analysis.double_deletion.py
 #runs flux variablity analysis on a Model object.
 from math import floor,ceil
-from numpy import vstack,zeros, nan
-from scipy import sparse
+from numpy import zeros #only item to replace to gain jython compatibility
 from copy import deepcopy
-from .moma import moma
 from warnings import warn
-from cPickle import dump
+from os import name as __name
+nan = float('nan')
+from sys import modules as __modules
+from warnings import warn
+if __name == 'java':
+    raise Exception("%s is not yet supported on jython"%__modules[__name__])
+    warn("moma is not supported on %s"%__name)
+    def moma(**kwargs):
+        warn("moma is not supported on %s"%__name)
+else:
+    from .moma import moma    
 try:
+    from cPickle import dump
+except:
+    from pickle import dump
+try:
     from cobra.external.ppmap import ppmap
     __parallel_mode_available = True
 except:
@@ -154,7 +167,8 @@
     """
     #BUG: Since this might be called from ppmap, the modules need to
     #be imported.  Modify ppmap to take depfuncs
-    from numpy import zeros, nan
+    from numpy import zeros
+    nan = float('nan')
     from cobra.flux_analysis.single_deletion import single_deletion
     from cobra.manipulation import initialize_growth_medium
     from cobra.manipulation import delete_model_genes, undelete_model_genes
@@ -354,6 +368,7 @@
     if not __parallel_mode_available:
         print  'Parallel mode not available is Parallel Python installed'
         return
+    from numpy import vstack
     if the_problem:
         the_problem='return'
     if the_medium:
Index: cobra/flux_analysis/essentiality.py
===================================================================
--- cobra/flux_analysis/essentiality.py	(revision 330)
+++ cobra/flux_analysis/essentiality.py	(working copy)
@@ -1,28 +1,41 @@
+from __future__ import with_statement
 #cobra.flux_analysis.essentiality.py
 #runs flux variablity analysis on a Model object.
+from os import name as __name
 from warnings import warn
 from math import floor,ceil
-from numpy import vstack,zeros
-from scipy import sparse
 from copy import deepcopy
-from cPickle import dump
 from os import path, mkdir
 try:
-    #Allow for parallel simulations if ppmap is available
-    from cobra.external import ppmap
-    from double_deletion import double_deletion_parallel
-    __parallel_mode_available = True
+    from cPickle import dump
 except:
+    from pickle import dump
+if __name == 'java':
     __parallel_mode_available = False
-    from double_deletion import double_deletion
-from cobra.flux_analysis.moma import moma
+    warn("moma is not supported on %s"%__name)
+    warn("flux_analysis.double_deletion is not supported on %s"%__name)
+    def moma(a, **kwargs):
+        raise Exception("moma is not supported on %s"%__name)
+
+    def double_deletion(a, **kwargs):
+        raise Exception("flux_analysis.double_deletion is not supported on %s"%__name)
+else:
+    try:
+        #Allow for parallel simulations if ppmap is available
+        from cobra.external import ppmap
+        from double_deletion import double_deletion_parallel
+        __parallel_mode_available = True
+    except:
+        __parallel_mode_available = False
+        from double_deletion import double_deletion
+    from cobra.flux_analysis.moma import moma
 from cobra.flux_analysis.single_deletion import single_deletion
 from cobra.manipulation import initialize_growth_medium
 def assess_medium_component_essentiality(cobra_model, the_components=None,
                                          the_medium=None, solver='glpk',
                                          the_problem='return',
                                          the_condition=None, method='fba'):
-    """Deterimes which components in an in silico medium are essential for growth in the
+    """Determines which components in an in silico medium are essential for growth in the
     context of the remaining components.
 
     cobra_model: A Model object.
@@ -51,17 +64,14 @@
      each component of the growth medium.
 
     """
-    warn("assess_medium_component_essentiality needs to be updated to " +\
-         "deal with new style reactions")
-    from cobra.core.ArrayBasedModel import ArrayBasedModel
     if method.lower() == 'moma':
-        wt_model = ArrayBasedModel(cobra_model.copy())
+        wt_model = cobra_model.copy()
     if isinstance(cobra_model, tuple):
         if len(cobra_model) == 3:
             the_condition = cobra_model[2]
         the_components = cobra_model[1]
         cobra_model = cobra_model[0]
-    cobra_model = ArrayBasedModel(cobra_model.copy())
+    cobra_model = cobra_model.copy()
     if not the_components:
         if the_medium:
             if hasattr(the_medium, 'keys') or \
@@ -76,15 +86,15 @@
     essentiality_dict = {}
     for the_component in the_components:
         component_index = cobra_model.reactions.index(the_component)
-        tmp_lb = float(cobra_model.lower_bounds[component_index])
-        cobra_model.reactions[component_index].lower_bound = cobra_model.lower_bounds[component_index] = 0
+        tmp_lb = float(cobra_model.reactions[component_index].lower_bound)
+        cobra_model.reactions[component_index].lower_bound = 0
         if method.lower() == 'fba':
             cobra_model.optimize(solver=solver, the_problem=the_problem)
             objective_value = cobra_model.solution.f
         elif method.lower() == 'moma':
            objective_value = moma(wt_model, cobra_model, solver=solver)['objective_value'] 
         essentiality_dict[the_component] = objective_value
-        cobra_model.reactions[component_index].lower_bound = cobra_model.lower_bounds[component_index] = tmp_lb
+        cobra_model.reactions[component_index].lower_bound = tmp_lb
     if the_condition:
         essentiality_dict['the_condition'] = the_condition
     return(essentiality_dict)
Index: cobra/flux_analysis/__init__.py
===================================================================
--- cobra/flux_analysis/__init__.py	(revision 330)
+++ cobra/flux_analysis/__init__.py	(working copy)
@@ -1,19 +1,36 @@
+try:
+    from essentiality import *
+except Exception, e:
+    from warnings import warn
+    warn("essentiality is not accessible: %s"%e)
+try:
+    from variability import *
+except Exception, e:
+    from warnings import warn
+    warn("variability is not accessible: %s"%e)
+try:
+    from single_deletion import single_deletion
+except Exception, e:
+    from warnings import warn
+    warn("single_deletion is not accessible: %s"%e)
+
+
 from os import name as __name
-from sys import modules as __modules
 from warnings import warn
 if __name == 'java':
-    warn("%s is not yet supported on jython"%__modules[__name__])
-
+    warn('double_deletion functions and moma are not yet supported on %s'%__name)
 else:
-    from ..solvers import *
-    from essentiality import *
-    from variability import *
-    from single_deletion import single_deletion
-    from double_deletion import double_deletion, double_deletion_parallel
-del __name, __modules
+    try:
+        from double_deletion import double_deletion, double_deletion_parallel
+    except Exception, e:
+        from warnings import warn
+        warn("double_deletion is not accessible: %s"%e)
 
+    
 
 
 
 
 
+
+
Index: cobra/flux_analysis/variability.py
===================================================================
--- cobra/flux_analysis/variability.py	(revision 330)
+++ cobra/flux_analysis/variability.py	(working copy)
@@ -1,8 +1,7 @@
+from __future__ import with_statement
 #cobra.flux_analysis.variablity.py
 #runs flux variablity analysis on a Model object.
 from math import floor,ceil
-from numpy import hstack,zeros
-from scipy import sparse
 from copy import deepcopy
 from ..core.Metabolite import Metabolite
 try:
@@ -15,7 +14,10 @@
     """Provides an interface to call flux_variability_analysis from ppmap
     
     """
-    from cPickle import dump
+    try:
+        from cPickle import dump
+    except:
+        from pickle import dump
     from .variability import flux_variability_analysis
     results_dict = {}
     new_objective = keywords.pop('new_objective')
@@ -66,7 +68,7 @@
     a float representing the wt_solution
 
     number_of_processes: If greater than 1 then this function will attempt
-    to parallelize the problem.  NOTE: Currently slow
+    to parallelize the problem.  NOTE: Currently not functional
 
 
     TODO: update how Metabolite._bound is handled so we can set a range instead
@@ -100,7 +102,7 @@
         the_reactions = map(cobra_model.reactions.get_by_id, the_reactions)
     #If parallel mode is called for then give it a try
     if number_of_processes > 1 and __parallel_mode_available:
-        print 'running in parallel. currently needs some speed optimizations'
+        warn("Parallel flux variability analysis is still buggy")
         the_problem = wt_solution #Solver objects are not thread safe
         the_reactions = [x.id for x in the_reactions]
         parameter_dict = dict([(x, eval(x))
@@ -226,7 +228,10 @@
     
     """
     from test import salmonella_pickle
-    from cPickle import load
+    try:
+        from cPickle import load
+    except:
+        from pickle import load
     with open(salmonella_pickle) as in_file:
         cobra_model = load(in_file)
     fva_out =  flux_variability_analysis(cobra_model,
Index: cobra/flux_analysis/single_deletion.py
===================================================================
--- cobra/flux_analysis/single_deletion.py	(revision 330)
+++ cobra/flux_analysis/single_deletion.py	(working copy)
@@ -1,11 +1,19 @@
+from __future__ import with_statement
 #cobra.flux_analysis.single_deletion.py
 #run single gene or reaction deletions on the model
-from numpy import nan
+nan = float('nan')
 from time import time
+from warnings import warn
 from copy import deepcopy
 from ..manipulation import initialize_growth_medium
 from ..manipulation import delete_model_genes, undelete_model_genes
-from .moma import moma
+from os import name as __name
+if __name == 'java':
+    warn("moma is not supported on %s"%__name)
+    def moma(**kwargs):
+        warn("moma is not supported on %s"%__name)
+else:
+    from .moma import moma    
 def single_deletion(cobra_model, element_list=None,
                     method='fba', the_problem='return',
                     element_type='gene', solver='glpk',
Index: cobra/__init__.py
===================================================================
--- cobra/__init__.py	(revision 330)
+++ cobra/__init__.py	(working copy)
@@ -4,11 +4,20 @@
 if __name == 'java':
     #raise Exception("Experimental modules of numpy/scipy for java that are" +\
     #"not yet ready for prime time.")
-    import oven.danielhyduke.jython.numpy as numpy
-    import oven.danielhyduke.jython.scipy as scipy
-    from core import Object, Formula, Metabolite, Gene, Reaction, Model
+    #import oven.danielhyduke.jython.numpy as numpy
+    #import oven.danielhyduke.jython.scipy as scipy
+    from warnings import warn
+    warn("COBRA for Python is not optimize for JAVA.  If it's slow or crashes consider increasing JVM memory")
+    from core import Object, Formula, Metabolite, Gene, Reaction, Model, DictList
 else:
-    from core import *
+    #from core import *
+    from core import Object, Formula, Metabolite, Gene, Reaction, Model, DictList
+    try:
+        from core import ArrayBasedModel
+    except Exception, e:
+        from warnings import warn
+        warn("cobra.ArrayBasedModel class is unavailable: %s"%repr(e))
+
 del __name
 __doc__ = """
 """
Index: cobra/core/ArrayBasedModel.py
===================================================================
--- cobra/core/ArrayBasedModel.py	(revision 330)
+++ cobra/core/ArrayBasedModel.py	(working copy)
@@ -114,6 +114,7 @@
 
         """
         Model.add_metabolites(metabolite_list)
+        self.constraint_sense = [x._constraint_sense for x in self.metabolites]
         if self.S is not None and expand_stoichiometric_matrix:
             s_expansion = len(self.metabolites) - self.S.shape[0]
             if s_expansion > 0:
@@ -210,6 +211,7 @@
         self.lower_bounds = array(lower_bounds)
         self.upper_bounds = array(upper_bounds)
         self.objective_coefficients = array(objective_coefficients)
+
     def _update_metabolite_vectors(self):
         """regenerates _b and _constraint_sense
 
@@ -223,10 +225,9 @@
         [(_b.append(x._bound),
           _constraint_sense.append(x._constraint_sense))
          for x in self.metabolites]
-        self._b = array(_b)
-        self._constraint_sense = _constraint_sense
+        self.b = array(_b)
+        self.constraint_sense = _constraint_sense
          
-
     def _update_matrices(self, reaction_list=None):
         """
         reaction_list: None or a list of cobra.Reaction objects that are in
Index: cobra/core/__init__.py
===================================================================
--- cobra/core/__init__.py	(revision 330)
+++ cobra/core/__init__.py	(working copy)
@@ -8,6 +8,9 @@
 from .Model import Model 
 from os import name as __name
 if __name != 'java':
-    from .ArrayBasedModel import ArrayBasedModel 
+    try:
+        from .ArrayBasedModel import ArrayBasedModel 
+    except Exception, e:
+        from warnings import warn
+        warn("ArrayBasedModel is not accessible: %s"%e)
 
-
Index: cobra/core/Model.py
===================================================================
--- cobra/core/Model.py	(revision 330)
+++ cobra/core/Model.py	(working copy)
@@ -180,8 +180,10 @@
             self.reactions[reaction_index] = the_reaction
 
     def update(self):
+        """Non functional.  Model.update is moved to ArrayBasedModel.  Please use
+        the to_array_based_model property to create an ArrayBasedModel.
+        
         """
-        """
         raise Exception("Model.update is moved to ArrayBasedModel.  Please use \n"
                         "the to_array_based_model property to create an ArrayBasedModel.")
                      
Index: cobra/core/Reaction.py
===================================================================
--- cobra/core/Reaction.py	(revision 330)
+++ cobra/core/Reaction.py	(working copy)
@@ -2,6 +2,9 @@
 #######################
 #BEGIN Class Reaction
 #
+#Is it better to restrict a Reaction to a single model or
+#should we allow a Reaction to be associated with multiple models?
+#
 from collections import defaultdict
 import re
 from copy import deepcopy
@@ -62,13 +65,22 @@
         [x._reaction.add(self) for x in self._metabolites]
         [x._reaction.add(self) for x in self._genes]
 
+    def get_model(self):
+        """Returns the Model object that this Reaction is associated with.
+
+        """
+        return self._model
+        
+
     def remove_from_model(self, model=None):
         """Removes the association
 
         model: cobra.Model object.  remove the reaction from this model.
         
         """
-        # why is model being taken in as a parameter?
+        # why is model being taken in as a parameter? This plays
+        #back to the question of allowing a Metabolite to be associated
+        #with multiple Models
         if model != self._model and model is not None:
             raise Exception('%s not in %s ergo it cannot be removed. (%s)'%(self,
                                                                   model,
@@ -133,6 +145,7 @@
         new_reaction = deepcopy(self)
         ## self._model = the_model
         return new_reaction
+
     def guided_copy(self, the_model, metabolite_dict, gene_dict=None):
         """Trying to make a faster copy procedure for cases where large
         numbers of metabolites might be copied.  Such as when copying reactions.
@@ -259,7 +272,13 @@
         return [k for k, v in self._metabolites.items()
                 if v > 0]
 
+    def get_gene(self):
+        """Return a list of reactants for the reaction.
 
+        """
+        return self._genes.keys()
+
+
     def get_coefficient(self, the_metabolite):
         """Return the stoichiometric coefficient for a metabolite in
         the reaction.
Index: cobra/core/Metabolite.py
===================================================================
--- cobra/core/Metabolite.py	(revision 330)
+++ cobra/core/Metabolite.py	(working copy)
@@ -2,6 +2,9 @@
 #######################
 #BEGIN Class Metabolite
 #
+#Is it better to restrict a Metabolite to a single model or
+#should we allow a Metabolite to be associated with multiple models?
+#
 from copy import deepcopy
 import re
 from .Formula import Formula
@@ -10,7 +13,7 @@
     """Metabolite is a class for holding information regarding
     a metabolite in a cobra.Reaction object.
 
-    TODO: Clean up.  Allow for creation of empty metabolite
+        
     """
     ## __slots__ = ['id', 'formula', 'name', 'compartment',
     ##              'charge']
@@ -18,6 +21,7 @@
     ##    from cobra.core.Metabolite import Metabolite
     ##    Object.__setstate__(self, the_dict)
     ##    [self.__setattr__(k, v) for k, v in the_dict]
+
     def __init__(self, id=None, formula=None,
                  name=None, compartment=None):
         """
@@ -60,6 +64,7 @@
         state = Object.__getstate__(self)
         state['_reaction'] = set()
         return state
+
     def parse_composition(self):
         """Breaks the chemical formula down by element.
         Useful for making sure Reactions are balanced.'
@@ -80,6 +85,7 @@
         """
         new_metabolite = deepcopy(self)
         return new_metabolite
+
     def guided_copy(self, the_model):
         """Trying to make a faster copy procedure for cases where large
         numbers of metabolites might be copied.  Such as when copying reactions.
@@ -91,15 +97,35 @@
         the_copy._model = the_model
         the_copy._reaction = set()
         return(the_copy)
-    
-    def remove_from_model(self, model=None):
+
+    def get_model(self):
+        """Returns the Model object that contain this Object
+
+        """
+        return self._model
+
+    def get_reaction(self):
+        """Returns a list of Reactions that contain this Object
+
+        """
+        return list(self._reaction)
+
+    def remove_from_model(self, model=None, method='subtractive'):
         """Removes the association
 
-        model: :class:`~cobra.core.Model` object.
+        model: None or :class:`~cobra.core.Model` object.
             Remove the reaction from this model.
+
+        method: 'subtractive' or 'destructive'.  If 'subtractive' then
+        the metabolite is removed from all associated reactions.  If
+        'destructive' then all associated reactions are removed from the Model.
+
+    
         
         """
-        # why is model being taken in as a parameter?
+        # why is model being taken in as a parameter? This plays
+        #back to the question of allowing a Metabolite to be associated
+        #with multiple Models
         if model != self._model and model is not None:
             raise Exception('%s not in %s ergo it cannot be removed. (%s)'%(self,
                                                                   model,
@@ -107,11 +133,16 @@
                                                             
         self._model.metabolites.remove(self)
         self._model = None
-        for the_reaction in self._reaction:
-            the_coefficient = the_reaction._metabolites[self]
-            the_reaction.subtract_metabolites({self: the_coefficient})
+        if method.lower() == 'subtractive':
+            for the_reaction in self._reaction:
+                the_coefficient = the_reaction._metabolites[self]
+                the_reaction.subtract_metabolites({self: the_coefficient})
+        elif method.lower() == 'destructive':
+            [x.remove_from_model() for x in self._reaction()]
+        else:
+            raise Exception("method for remove_from_model must be 'subtractive' " +\
+                            "or 'destructive'.  You entered: '%s'"%method)
 
-
 #
 #END Class Metabolite
 ########################
Index: cobra/core/Object.py
===================================================================
--- cobra/core/Object.py	(revision 330)
+++ cobra/core/Object.py	(working copy)
@@ -14,6 +14,7 @@
         #formatting notes and annotation
         self.notes = {}
         self.annotation = {}
+
     def __getstate__(self):
         """To prevent excessive replication during deepcopy.
         """
@@ -21,6 +22,7 @@
         if '_model' in state:
             state['_model'] = None
         return state
+    
     def guided_copy(self):
         """Trying to make a faster copy procedure for cases where large
         numbers of metabolites might be copied.  Such as when copying reactions.
@@ -32,6 +34,7 @@
         [setattr(the_copy, k, v)
          for k, v in self.__dict__.iteritems()]
         return(the_copy)
+
     ## def __setstate__(self, state):
     ##     self.__dict__.update(state)
     ## def __getstate__(self):
@@ -45,6 +48,7 @@
     #Not the best idea.  This will be removed in the next major
     #release
     #
+
     def __lt__(self, other):
         if hasattr(other, 'id'):
             x = self.id < other.id
Index: cobra/solvers/glpk.py
===================================================================
--- cobra/solvers/glpk.py	(revision 330)
+++ cobra/solvers/glpk.py	(working copy)
@@ -1,84 +0,0 @@
-"""bindings to the glpk solver through pyglpk"""
-# because both this module and the library are named glpk
-from __future__ import absolute_import
-from glpk import LPX
-
-from ..core.Solution import Solution
-
-
-# mappers from cobra representation to glpk
-variable_kind_dict = {
-    'continuous': float,
-    'integer': int}
-# mappers from glpk representations to cobra
-status_dict = {
-    'opt': 'optimal',
-    'nofeas': 'infeasible',
-    'unbnd': 'unbounded'}
-
-
-def create_problem(cobra_model, objective_sense="maximize", lp=None):
-    if lp is None:
-        lp = LPX()  # Create empty problem instance
-        lp.name = cobra_model.id
-        lp.rows.add(len(cobra_model.metabolites))
-        lp.cols.add(len(cobra_model.reactions))
-
-    if objective_sense == 'maximize':
-        lp.obj.maximize = True
-    elif objective_sense == 'minimize':
-        lp.obj.maximize = False
-    else:
-        raise ValueError("objective_sense not 'maximize' or 'minimize'")
-
-    # create metabolites/constraints as rows
-    for i, r in enumerate(lp.rows):
-        metabolite = cobra_model.metabolites[i]
-        r.name = metabolite.id
-        b = float(metabolite._bound)
-        c = metabolite._constraint_sense
-        # constraint sense is set by changing the bounds
-        if c == 'E':
-            r.bounds = (b, b)
-        elif c == 'L':
-            r.bounds = (None, b)
-        elif c == 'G':
-            r.bounds = (b, None)
-        else:
-            raise ValueError("%s is not a valid constraint_sense" % c)
-
-    # create reactions/variables as columns
-    for i, c in enumerate(lp.cols):
-        reaction = cobra_model.reactions[i]
-        c.name = reaction.id
-        c.kind = variable_kind_dict[reaction.variable_kind]
-        c.bounds = (reaction.lower_bound, reaction.upper_bound)
-        lp.obj[i] = float(reaction.objective_coefficient)
-
-    # create S matrix
-    lp.matrix = [(int(i), int(j), c) \
-        for (i, j), c in cobra_model.to_array_based_model().S.todok().iteritems()]
-    return lp
-
-
-def solve_problem(lp):
-    lp.simplex()
-    try:
-        status = status_dict[lp.status]
-    except:
-        status = "unknown error: " + str(lp.status)
-    solution = Solution(status)
-    solution.status = status
-    if status == 'optimal':
-        solution.objective_value = lp.obj.value
-        solution.x_dict = dict((c.name, c.primal) for c in lp.cols)
-        # return the duals as well as the primals for LPs
-        if lp.kind == "float":
-            solution.y_dict = dict((c.name, c.dual) for c in lp.cols)
-        else:
-            solution.y_dict = None
-    return solution
-
-
-def solve(cobra_model, objective_sense="maximize", **kwargs):
-    return solve_problem(create_problem(cobra_model, objective_sense))
Index: cobra/solvers/__init__.py
===================================================================
--- cobra/solvers/__init__.py	(revision 330)
+++ cobra/solvers/__init__.py	(working copy)
@@ -2,104 +2,101 @@
 from os import name as __name
 from sys import modules as __modules
 from warnings import warn
-if __name == 'java':
-    #warn("%s is not yet supported on jython"%__modules[__name__])
-    def optimize():
-        print "No solvers for jython yet"
-else:
-    __legacy_solver = True
-    solver_dict = {}
-    if __legacy_solver:
-        from .legacy import _optimize_glpk, _optimize_gurobi, _optimize_cplex
-        solver_dict = {'glpk': _optimize_glpk,
-                       'gurobi': _optimize_gurobi,
-                       'cplex': _optimize_cplex}
-        for solver_module in ['glpk', 'cplex']:
-            try:
-                exec('from %s import *'%solver_module)
-            except:
-                solver_dict.pop(solver_module)
-        try:
-            from gurobipy import *
-        except:
-            solver_dict.pop('gurobi')
 
+__legacy_solver = False
+solver_dict = {}
+if __legacy_solver:
+    from .legacy import _optimize_glpk, _optimize_gurobi, _optimize_cplex
+    package_dict = {'glpk': 'from glpk import LPX',
+                    'cplex': 'from cplex import Cplex',
+                    'gurobi': 'from gurobipy import Model'}
+    if __name == 'java':
+        from .legacy_jython import _optimize_glpk
+        package_dict['glpk'] = 'from org.gnu.glpk import GLPK'
+        package_dict['gurobi'] = 'from gurobi import GRBModel'
 
-    else:
-        from os import listdir as _listdir
-        from os import path as _path
-        for i in _listdir(_path.split(_path.abspath(__file__))[0]):
-            if i.startswith("_") or i.startswith("."):
-                continue
-            if not i.endswith(".py"):
-                continue
-            try:
-                m = i.strip(".py")
-                exec("from . import %s" % m)
-                solver_dict[m] = eval(m)
-            except Exception, e:
-                pass
-        del _path
-        del _listdir
-        del i
-        m = None
-        del m
 
-    def optimize(cobra_model, solver='glpk', error_reporting=False, **kwargs):
-        """Wrapper to optimization solvers
+    solver_dict = {'glpk': _optimize_glpk,
+                   'gurobi': _optimize_gurobi,
+                   'cplex': _optimize_cplex}
 
+    for solver_name, solver_import in package_dict.iteritems():
+        try:
+            exec(solver_import)
+        except Exception, e:
+            #print e
+            solver_dict.pop(solver_name)
+else:
+    from os import listdir as _listdir
+    from os import path as _path
+    for i in _listdir(_path.split(_path.abspath(__file__))[0]):
+        if i.startswith("_") or i.startswith(".") or i == 'legacy.py':
+            continue
+        if not i.endswith(".py"):
+            continue
+        try:
+            m = i.strip(".py")
+            exec("from . import %s" % m)
+            solver_name = m
+            if solver_name.endswith('_solver'):
+                solver_name = solver_name[:-len('_solver')]
+            solver_dict[solver_name] = eval(m)
+        except Exception, e:
+            pass
+    del _path
+    del _listdir
+    del i
+    m = None
+    del m
 
-        """
-        #If the default solver is not installed then use one of the others
+def optimize(cobra_model, solver='glpk', error_reporting=True, **kwargs):
+    """Wrapper to optimization solvers
+
+
+    """
+    #If the default solver is not installed then use one of the others
+    try:
+        solver_function = solver_dict[solver]
+    except:
         try:
-            solver_function = solver_dict[solver]
+            solver, solver_function = solver_dict.items()[0]
         except:
-            try:
-                solver, solver_function = solver_dict.items()[0]
-            except:
-                raise Exception("It appears that you do not have one of the supported solvers "+\
-                                "(glpk, gurobi, or cplex) installed")
-        the_solution = None
-        if __legacy_solver:
-            def solve_problem(solver_function, kwargs):
-                return solver_function(cobra_model, **kwargs)
-            try:
-                the_solution = solve_problem(solver_function, kwargs)
-            except Exception, e:
-                if error_reporting:
-                    print e
-                    print '%s did not work'%solver
-                solver_keys = solver_dict.keys()
-                solver_keys.remove(solver)
-                for solver in solver_keys:
-                    solver_function = solver_dict[solver]
-                    try:
-                        if error_reporting:
-                            print "now trying %s"%solver
-                        the_solution = solve_problem(solver_function, kwargs)
-                        break
-                    except Exception, e:
-                        if error_reporting:
-                            print e
-                            print '%s did not work'%solver
-                        continue
+            raise Exception("It appears that you do not have one of the supported solvers "+\
+                            "(glpk, gurobi, or cplex) installed")
+    the_solution = None
+    if __legacy_solver:
+        def solve_problem(solver_function, kwargs):
+            return solver_function(cobra_model, **kwargs)
+        try:
+            the_solution = solve_problem(solver_function, kwargs)
+        except Exception, e:
+            if error_reporting:
+                print e
+                print '%s did not work'%solver
+            solver_keys = solver_dict.keys()
+            solver_keys.remove(solver)
+            for solver in solver_keys:
+                solver_function = solver_dict[solver]
+                try:
+                    if error_reporting:
+                        print "now trying %s"%solver
+                    the_solution = solve_problem(solver_function, kwargs)
+                    break
+                except Exception, e:
+                    if error_reporting:
+                        print e
+                        print '%s did not work'%solver
+                    continue
 
-        else:
-            the_solution = solver_function.solve(cobra_model, **kwargs)
-            #raise Exception("New style solvers not yet fully implemented")
+    else:
+        the_solution = solver_function.solve(cobra_model, **kwargs)
+        #raise Exception("New style solvers not yet fully implemented")
 
 
-        #Add the solution to the model.
-        #Please note that it will be faster to dress the reactions and metabolites
-        #with their values within the new style solvers instead of here.
-        if the_solution is None:
-            cobra_model.solution = the_solution
-            return(the_solution)
-        else:
-            if __legacy_solver:
-                cobra_model.solution = the_solution['the_solution']
-                return(the_solution['the_problem'])
-            else:
-                cobra_model.solution = the_solution
+    #Add the solution to the model.
+    #if the_solution is None:
+    #   return(the_solution)
+    #else:
+    return(the_solution['the_problem'])
 
-del __name, __modules
+del __name
Index: cobra/solvers/gurobi_solver.py
===================================================================
--- cobra/solvers/gurobi_solver.py	(revision 0)
+++ cobra/solvers/gurobi_solver.py	(revision 0)
@@ -0,0 +1,331 @@
+##cobra.solvers.gurobi_solver
+#Interface to the gurobi 5.0.1 python and java solvers
+#QPs are not yet supported on java
+from __future__ import absolute_import
+from warnings import warn
+from os import name as __name
+from copy import deepcopy
+###solver specific parameters
+from .parameters import status_dict, variable_kind_dict, \
+     sense_dict, parameter_mappings, parameter_defaults, \
+     objective_senses, default_objective_sense
+
+from ..core.Solution import Solution
+from ..flux_analysis.objective import update_objective
+from time import time
+solver_name = 'gurobi'
+objective_senses = objective_senses[solver_name]
+parameter_mappings = parameter_mappings[solver_name]
+parameter_defaults = parameter_defaults[solver_name]
+#Functions that are different for java implementation of a solver
+if __name == 'java':
+    ## from jarray import array as j_array
+    ## def array(x, variable_type='d'):
+    ##     return j_array(x, variable_type)
+
+    from gurobi import GRB
+    variable_kind_dict = eval(variable_kind_dict[solver_name])
+    status_dict = eval(status_dict[solver_name])
+
+    from gurobi import GRBModel, GRBEnv
+    from gurobi import GRBLinExpr
+    from gurobi import GRBQuadExpr as QuadExpr
+    __solver_class = GRBModel
+    #TODO: Create a pythonesqe class similar to in glpk_solver
+    def Model(name=''):
+        grb_environment = GRBEnv(name)
+        tmp_model = GRBModel(grb_environment)
+        return tmp_model
+    def LinExpr(coefficients, variables):
+        coefficients, variables = map(list, [coefficients, variables])
+        tmp_expression = GRBLinExpr()
+        tmp_expression.addTerms(coefficients, variables)
+        return tmp_expression
+
+    def get_status(lp):
+        status = lp.get(GRB.IntAttr.Status)
+        if status in status_dict:
+            status = status_dict[status]
+        else:
+            status = 'failed'
+        return status
+
+    def set_parameter(lp, parameter_name, parameter_value):
+        """Sets model parameters and attributes.
+        
+        """
+        grb_environment = lp.getEnv()
+        try:
+            if hasattr(GRB.DoubleParam, parameter_name):
+                grb_environment.set(eval('GRB.DoubleParam.%s'%parameter_name),
+                                         parameter_value)
+            elif hasattr(GRB.IntParam, parameter_name):
+                grb_environment.set(eval('GRB.IntParam.%s'%parameter_name),
+                                         parameter_value)
+            elif hasattr(GRB.StringParam, parameter_name):
+                grb_environment.set(eval('GRB.StringParam.%s'%parameter_name),
+                                    parameter_value)
+            elif hasattr(GRB.IntAttr, parameter_name):
+                if parameter_name == 'ModelSense':
+                    parameter_value = objective_senses[parameter_value]
+                lp.set(eval('GRB.IntAttr.%s'%parameter_name),
+                                    parameter_value)
+            else:
+                warn("%s is not a DoubleParam, IntParam, StringParam, IntAttr"%parameter_name)
+                ## raise Exception("%s is not a DoubleParam, IntParam, StringParam, IntAttr"%parameter_name)
+        except Exception, e:
+            warn("%s %s didn't work %s"%(parameter_name, parameter_value, e))
+
+    def format_solution(lp, cobra_model, **kwargs):
+        """
+        """
+        status = get_status(lp)
+        if status != 'optimal':
+            the_solution = Solution(None, status=status)
+        else:
+            x_dict = dict(((v.get(GRB.StringAttr.VarName),
+                            v.get(GRB.DoubleAttr.X))
+                           for v in lp.getVars()))
+            x = [x_dict[v.id] for v in cobra_model.reactions]
+            objective_value = lp.get(GRB.DoubleAttr.ObjVal)
+            if lp.get(GRB.IntAttr.IsMIP) != 0:
+                y = y_dict = None #MIP's don't have duals
+            else:
+                y_dict = dict(((c.get(GRB.StringAttr.ConstrName), c.get(GRB.DoubleAttr.Pi))
+                              for c in lp.getConstrs()))
+                y = list([y_dict[v.id] for v in cobra_model.metabolites])
+            the_solution = Solution(objective_value, x=x, x_dict=x_dict, y=y,
+                                    y_dict=y_dict, status=status)
+        return(the_solution)
+
+    def update_problem(lp, cobra_model, **kwargs):
+        """A performance tunable method for updating a model problem file
+
+        lp: A gurobi problem object
+
+        cobra_model: the cobra.Model corresponding to 'lp'
+
+        """
+        #When reusing the basis only assume that the objective coefficients or bounds can change
+        try:
+            quadratic_component = kwargs['quadratic_component']
+            if quadratic_component is not None:
+                warn("update_problem does not yet take quadratic_component as a parameter")
+        except:
+            quadratic_component = None
+
+        if 'reuse_basis' in kwargs and not kwargs['reuse_basis']:
+            lp.reset()
+        for the_variable, the_reaction in zip(lp.getVars(),
+                                              cobra_model.reactions):
+            the_variable.set(GRB.DoubleAttr.LB, float(the_reaction.lower_bound))
+            the_variable.set(GRB.DoubleAttr.UB, float(the_reaction.upper_bound))
+            the_variable.set(GRB.DoubleAttr.Obj, float(the_reaction.objective_coefficient))
+
+
+else:
+    ## from numpy import array
+    from gurobipy import Model, LinExpr, GRB, QuadExpr
+    variable_kind_dict = eval(variable_kind_dict[solver_name])
+    status_dict = eval(status_dict[solver_name])
+    __solver_class = Model
+    def get_status(lp):
+        status = lp.status
+        if status in status_dict:
+            status = status_dict[status]
+        else:
+            status = 'failed'
+        return status
+
+    def format_solution(lp, cobra_model, **kwargs):
+        status = get_status(lp)
+        if status != 'optimal':
+            the_solution = Solution(None, status=status)
+        else:
+            objective_value = lp.ObjVal            
+            x_dict = dict(((v.VarName, v.X)
+                           for v in lp.getVars()))
+            x = [x_dict[v.id] for v in cobra_model.reactions]
+            if lp.isMIP:
+                y = y_dict = None #MIP's don't have duals
+            else:
+                y_dict = dict(((c.ConstrName, c.Pi)
+                              for c in lp.getConstrs()))
+                y = list([y_dict[v.id] for v in cobra_model.metabolites])
+            the_solution = Solution(objective_value, x=x, x_dict=x_dict, y=y,
+                                    y_dict=y_dict, status=status)
+        return(the_solution)
+
+    def set_parameter(lp, parameter_name, parameter_value):
+        if parameter_name == 'ModelSense':
+            lp.setAttr(parameter_name, objective_senses[parameter_value])
+        else:
+            lp.setParam(parameter_name, parameter_value)
+
+    def update_problem(lp, cobra_model, **kwargs):
+        """A performance tunable method for updating a model problem file
+
+        lp: A gurobi problem object
+
+        cobra_model: the cobra.Model corresponding to 'lp'
+
+        """
+        #When reusing the basis only assume that the objective coefficients or bounds can change
+        try:
+            quadratic_component = kwargs['quadratic_component']
+            if quadratic_component is not None:
+                warn("update_problem does not yet take quadratic_component as a parameter")
+        except:
+            quadratic_component = None
+
+        if 'copy_problem' in kwargs and kwargs['copy_problem']:
+            lp = lp.copy()
+        if 'reuse_basis' in kwargs and not kwargs['reuse_basis']:
+            lp.reset()
+        for the_variable, the_reaction in zip(lp.getVars(),
+                                              cobra_model.reactions):
+            the_variable.lb = float(the_reaction.lower_bound)
+            the_variable.ub = float(the_reaction.upper_bound)
+            the_variable.obj = float(the_reaction.objective_coefficient)
+
+
+
+###
+sense_dict = eval(sense_dict[solver_name])
+def create_problem(cobra_model,  **kwargs):
+    """Solver-specific method for constructing a solver problem from
+    a cobra.Model.  This can be tuned for performance using kwargs
+
+
+    """
+    lp = Model("")
+    #Silence the solver
+    set_parameter(lp, 'OutputFlag', 0)
+
+    the_parameters = parameter_defaults
+    if kwargs:
+        the_parameters = deepcopy(parameter_defaults)
+        the_parameters.update(kwargs)
+
+    [set_parameter(lp, parameter_mappings[k], v)
+         for k, v in the_parameters.iteritems() if k in parameter_mappings]
+    quadratic_component = the_parameters['quadratic_component']
+    objective_sense = objective_senses[the_parameters['objective_sense']]
+
+
+    # Create variables
+    #TODO:  Speed this up
+    variable_list = [lp.addVar(float(x.lower_bound),
+                               float(x.upper_bound),
+                               float(x.objective_coefficient),
+                               variable_kind_dict[x.variable_kind],
+                               x.id)
+                     for x in cobra_model.reactions]
+    reaction_to_variable = dict(zip(cobra_model.reactions,
+                                    variable_list))
+    # Integrate new variables
+    lp.update()
+    #Set objective to quadratic program
+    if quadratic_component is not None:
+        if not hasattr(quadratic_component, 'todok'):
+            raise Exception('quadratic component must have method todok')
+
+        quadratic_objective = QuadExpr()
+        for (index_0, index_1), the_value in quadratic_component.todok().items():
+            quadratic_objective.addTerms(the_value,
+                                   variable_list[index_0],
+                                   variable_list[index_1])
+        #Does this override the linear objective coefficients or integrate with them?
+        lp.setObjective(quadratic_objective, sense=objective_sense)
+    #Constraints are based on mass balance
+    #Construct the lin expression lists and then add
+    #TODO: Speed this up as it takes about .18 seconds
+    #HERE
+    for the_metabolite in cobra_model.metabolites:
+        constraint_coefficients = []
+        constraint_variables = []
+        for the_reaction in the_metabolite._reaction:
+            constraint_coefficients.append(the_reaction._metabolites[the_metabolite])
+            constraint_variables.append(reaction_to_variable[the_reaction])
+        #Add the metabolite to the problem
+        lp.addConstr(LinExpr(constraint_coefficients, constraint_variables),
+                     sense_dict[the_metabolite._constraint_sense.upper()],
+                     the_metabolite._bound,
+                     the_metabolite.id)
+
+
+
+    return(lp)
+###
+
+###
+def solve_problem(lp, **kwargs):
+    """A performance tunable method for updating a model problem file
+
+    """
+    #Update parameter settings if provided
+    if kwargs:
+        [set_parameter(lp, parameter_mappings[k], v)
+         for k, v in kwargs.iteritems() if k in parameter_mappings]
+
+    try:
+        print_solver_time = kwargs['print_solver_time']
+        start_time = time()
+    except:
+        print_solver_time = False
+    lp.update()
+    #Different methods to try if lp_method fails
+    the_methods = [0, 2, 1]
+    lp.optimize()
+    status = get_status(lp)
+    if status != 'optimal':
+        #Try to find a solution using a different method
+        set_parameter(lp, parameter_mappings['tolerance_markowitz'], 1e-2)
+        for the_method in the_methods:
+            set_parameter(lp, parameter_mappings['lp_method'], the_method)
+            lp.optimize()
+            status = get_status(lp)
+            if status == 'optimal':
+                break
+
+    if print_solver_time:
+        print 'optimize time: %f'%(time() - start_time)
+    return status
+
+    
+def solve(cobra_model, **kwargs):
+    """
+
+    """
+        #Update objectives if they are new.
+    if 'new_objective' in kwargs and \
+           kwargs['new_objective'] not in ['update problem', None]:
+       update_objective(cobra_model, kwargs['new_objective'])
+
+    if 'the_problem' in kwargs:
+        the_problem = kwargs['the_problem']
+    else:
+        the_problem = None
+    if 'error_reporting' in kwargs:
+        error_reporting = kwargs['error_reporting']
+    else:
+        error_reporting = False
+
+    if isinstance(the_problem, __solver_class):
+        #Update the problem with the current cobra_model
+        lp = the_problem
+        update_problem(lp, cobra_model, **kwargs)
+    else:
+        #Create a new problem
+        lp = create_problem(cobra_model, **kwargs)
+    #Deprecated way for returning a solver problem created from a cobra_model
+    #without performing optimization
+    if the_problem == 'setup':
+            return lp
+    status = solve_problem(lp, **kwargs)
+    the_solution = format_solution(lp, cobra_model)
+    if status != 'optimal' and error_reporting:
+        print '%s failed: %s'%(solver_name, status)
+    cobra_model.solution = the_solution
+    solution = {'the_problem': lp, 'the_solution': the_solution}
+    return solution
Index: cobra/solvers/parameters.py
===================================================================
--- cobra/solvers/parameters.py	(revision 0)
+++ cobra/solvers/parameters.py	(revision 0)
@@ -0,0 +1,135 @@
+#This centralizes some of the common elements that are differently named across solvers.
+#These are stored as strings here to prevent problems associated with calling
+#solver objects for solver packages that aren't available
+from copy import deepcopy
+__objective_sense_cplex = {'maximize': 'Cplex.objective.sense.maximize',
+                           'minimize': 'Cplex.objective.sense.minimize'}
+__objective_sense_cplex_java = {'maximize': 'IloObjectiveSense.Maximize',
+                                'minimize': 'IloObjectiveSense.Minimize'}
+
+__objective_sense_glpk = {'maximize': True,
+                          'minimize': False}
+__objective_sense_glpk_java = {'maximize': 'GLPKConstants.GLP_MAX',
+                               'minimize': 'GLPKConstants.GLP_MIN'}
+__objective_sense_gurobi = {'maximize': -1,
+                            'minimize': 1}
+objective_senses = {'cplex': __objective_sense_cplex,
+                    'cplex_java': __objective_sense_cplex_java,
+                    'glpk': __objective_sense_glpk,
+                    'glpk_java': __objective_sense_glpk_java,
+                    'gurobi': __objective_sense_gurobi}
+default_objective_sense = 'maximize'
+#Mappings from solver-specific status values to cobra pie status values
+## __status_cplex = "{Cplex.solution.status.MIP_infeasible: 'infeasible', " +\
+##                  "Cplex.solution.status.MIP_optimal: 'optimal', " +\
+##                  "Cplex.solution.status.MIP_optimal_tolerance: 'optimal'," +\
+##                  "Cplex.solution.status.MIP_unbounded:  'unbounded', "+\
+##                  "Cplex.solution.status.infeasible: 'infeasible', " +\
+##                  "Cplex.solution.status.optimal: 'optimal',  " +\
+##                  "Cplex.solution.status.optimal_tolerance: 'optimal', " +\
+##                  "Cplex.solution.status.unbounded: 'unbounded', }"
+__status_cplex = "{'MIP_infeasible': 'infeasible', 'integer optimal solution': 'optimal', " +\
+                  "'MIP_optimal_tolerance': 'optimal',  'MIP_unbounded':  'unbounded', "+\
+                  "'infeasible': 'infeasible', 'optimal': 'optimal',  " +\
+                  "'optimal_tolerance': 'optimal', 'unbounded': 'unbounded' }"
+
+__status_glpk = "{'opt': 'optimal', 'nofeas': 'infeasible', 'unbnd': 'unbounded'}"
+__status_glpk_java = "{GLPKConstants.GLP_OPT: 'optimal', GLPKConstants.GLP_FEAS: 'feasible', GLPKConstants.GLP_INFEAS: 'infeasible', GLPKConstants.GLP_NOFEAS: 'infeasible', GLPKConstants.GLP_UNBND: 'unbounded', GLPKConstants.GLP_UNDEF: 'undefined'}"
+__status_gurobi = "{GRB.OPTIMAL: 'optimal', GRB.INFEASIBLE: 'infeasible', GRB.UNBOUNDED: 'unbounded'}"
+
+status_dict = {'cplex': __status_cplex,
+               'glpk': __status_glpk,
+               'glpk_java': __status_glpk_java,
+               'gurobi': __status_gurobi}
+
+#Mappings from solver-specific variable kinds to cobra pie
+__kind_cplex = "{'continuous': Cplex.variables.type.continuous, 'integer': Cplex.variables.type.integer}"
+__kind_cplex_java = "{'continuous':  IloNumVarType.Float, 'integer': IloNumVarType.Int}"
+__kind_glpk = "{'continuous': float, 'integer': int}"
+__kind_glpk_java = "{'binary': GLPKConstants.GLP_BV, 'continuous': GLPKConstants.GLP_CV, 'integer': GLPKConstants.GLP_IV}"
+__kind_gurobi = "{'continuous': GRB.CONTINUOUS, 'integer': GRB.INTEGER}"
+
+variable_kind_dict = {'cplex': __kind_cplex,
+                      'cplex_java': __kind_cplex_java,
+                      'glpk': __kind_glpk,
+                      'glpk_java': __kind_glpk_java, 
+                      'gurobi': __kind_gurobi}
+
+#Mappings from solver-specific constraint senses to cobra pie
+sense_dict = {'cplex': "{'E': 'E', 'L': 'L', 'G': 'G'}",
+              'glpk': "{'E': 'E', 'L': 'L', 'G': 'G'}",
+              'gurobi': "{'E': GRB.EQUAL, 'L': GRB.LESS_EQUAL, 'G': GRB.GREATER_EQUAL}"}
+
+
+#Mappings from cobra pie parameters names to solver specific parameter names
+__mappings_cplex = {'lp_method': 'parameters.lpmethod.set',
+                    'lp_parallel': 'parameters.threads.set',
+                    'objective_sense': 'objective.set_sense',
+                    'time_limit': 'parameters.timelimit.set',
+                    'tolerance_barrier': 'parameters.barrier.convergetol.set',
+                    'tolerance_feasibility': 'parameters.simplex.tolerances.feasibility.set',
+                    'tolerance_markowitz': 'parameters.simplex.tolerances.markowitz.set',
+                    'tolerance_optimality': 'parameters.simplex.tolerances.optimality.set'}
+__mappings_cplex_java = {'lp_method': 'RootAlg',
+                         'lp_parallel': 'ParallelMode',
+                         'objective_sense': 'objective_sense',
+                         'time_limit': 'TiLim',
+                         'tolerance_barrier': 'BarEpComp',
+                         'tolerance_feasibility': 'EpRHS',
+                         'tolerance_markowitz': 'EpMrk',
+                         'tolerance_optimality': 'EpOpt'}
+__mappings_glpk = {}
+__mappings_glpk_java = {'objective_sense': 'objective_sense',
+                        'lp_method': 'meth',
+                        'output_verbosity': 'msg_lev',
+                        'tolerance_dual': 'tol_dj',
+                        'tolerance_integer': 'tol_int',
+                        'tolerance_optimality': 'tol_bnd'
+                        }
+__mappings_gurobi = {'log_file': 'LogFile',
+                     'lp_method': 'Method',
+                     'objective_sense': 'ModelSense',
+                     'output_verbosity': 'OutputFlag',
+                     'quadratic_precision': 'Quad',
+                     'time_limit': 'TimeLimit',
+                     'tolerance_feasibility': 'FeasibilityTol',
+                     'tolerance_markowitz': 'MarkowitzTol',
+                     'tolerance_optimality': 'OptimalityTol' }
+parameter_mappings = {'cplex': __mappings_cplex,
+                      'cplex_java': __mappings_cplex_java,
+                      'glpk': __mappings_glpk,
+                      'glpk_java': __mappings_glpk_java,
+                      'gurobi': __mappings_gurobi}
+
+
+#Default solver parameters
+__common_defaults = {'new_objective': None, 'objective_sense': 'maximize',
+                      'min_norm': 0, 'the_problem': None, 
+                      'tolerance_optimality': 1e-6, 'tolerance_feasibility': 1e-6,
+                      'tolerance_integer': 1e-9, 
+                      'error_reporting': None, 'print_solver_time': False,
+                      'quadratic_component': None}
+                      
+
+
+__parameters_cplex = deepcopy(__common_defaults)
+__parameters_cplex.update({'lp_method': 1,
+                           'lp_parallel': 0,
+                           'tolerance_barrier': 1e-8})
+__parameters_glpk = deepcopy(__common_defaults)
+__parameters_glpk.update({'lp_method': 1})
+__parameters_glpk_java = deepcopy(__common_defaults)
+__parameters_glpk_java.update({'lp_method': 1,
+                               'output_verbosity': 0,
+                               'tolerance_dual': 1e-8})
+__parameters_gurobi = deepcopy(__common_defaults)
+__parameters_gurobi.update({'output_verbosity': 0,
+                          'lp_method': 0,
+                          'log_file': '',
+                          'tolerance_barrier': 1e-8})
+
+
+parameter_defaults = {'cplex': __parameters_cplex,
+                      'glpk': __parameters_glpk,
+                      'glpk_java': __parameters_glpk_java,
+                      'gurobi': __parameters_gurobi}
Index: cobra/solvers/legacy.py
===================================================================
--- cobra/solvers/legacy.py	(revision 330)
+++ cobra/solvers/legacy.py	(working copy)
@@ -309,8 +309,6 @@
 
     if print_solver_time:
         print 'cplex time: %f'%(time() - start_time)
-    x = []
-    x_dict = {}
     #TODO: It might be able to speed this up a little.
     if status == 'optimal':
         objective_value = lp.solution.get_objective_value()
@@ -334,7 +332,7 @@
         if error_reporting:
             print 'cplex failed: %s'%lp.status
 
-    the_solution = Solution(objective_value, x=x, x_dict=x_dict,
+    cobra_model.solution = the_solution = Solution(objective_value, x=x, x_dict=x_dict,
                             status=status, y=y, y_dict=y_dict)
     solution = {'the_problem': lp, 'the_solution': the_solution}
     return solution    
@@ -565,7 +563,7 @@
         objective_value = None
         if error_reporting:
             print 'gurobi failed: %s'%lp.status  
-    the_solution = Solution(objective_value, x=x, x_dict=x_dict,
+    cobra_model.solution = the_solution = Solution(objective_value, x=x, x_dict=x_dict,
                             y=y, y_dict=y_dict,
                             status=status)
     solution = {'the_problem': lp, 'the_solution': the_solution}
@@ -810,7 +808,7 @@
         x = y = x_dict = y_dict = objective_value = None
         if error_reporting:
             print 'glpk failed: %s'%lp.status
-    the_solution = Solution(objective_value, x=x, x_dict=x_dict,
+    cobra_model.solution = the_solution = Solution(objective_value, x=x, x_dict=x_dict,
                             y=y, y_dict=y_dict,
                             status=status)
     solution = {'the_problem': lp, 'the_solution': the_solution}
Index: cobra/solvers/cplex_solver.py
===================================================================
--- cobra/solvers/cplex_solver.py	(revision 0)
+++ cobra/solvers/cplex_solver.py	(revision 0)
@@ -0,0 +1,530 @@
+#cobra.solvers.cplex_solver
+#Interface to ilog/cplex 12.4 python / jython interfaces
+#QPs are not yet supported under jython
+from __future__ import absolute_import
+from pdb import set_trace
+from os import name as __name
+from copy import deepcopy
+from warnings import warn
+###solver specific parameters
+from cobra.solvers.parameters import status_dict, variable_kind_dict, \
+     sense_dict, parameter_mappings, parameter_defaults, \
+     objective_senses, default_objective_sense
+
+from cobra.core.Solution import Solution
+from cobra.flux_analysis.objective import update_objective
+from time import time
+solver_name = 'cplex'
+parameter_defaults = parameter_defaults[solver_name]
+sense_dict = eval(sense_dict[solver_name])
+
+#Functions that are different for java implementation of a solver
+if __name == 'java':
+    from ilog.cplex import IloCplex
+    from ilog.cplex.IloCplex import DoubleParam, IntParam, StringParam
+    from ilog.concert import IloNumVarType, IloObjectiveSense 
+    #__solver_class = IloCplex
+    status_dict = eval(status_dict[solver_name])
+    class Problem(IloCplex):
+        def __init__(self):
+            IloCplex.__init__(self)
+            self._lp_matrix = self.addLPMatrix()
+            self.objective_value = None
+            self._objective_sense = 'maximize'
+        def add_linear_expression(self, linear_expression, metabolite):
+            b = metabolite._bound
+            c = metabolite._constraint_sense
+            the_id = metabolite.id
+            if c == 'E':
+                p = self.addEq(linear_expression, b, the_id)
+            elif c == 'L':
+                p = self.addLe(linear_expression, b, the_id)
+            elif c == 'G':
+                p = self.addGe(linear_expression, b, the_id)
+            else:
+                raise Exception("Constraint sense '%s' for metabolite %s is not valid"%(c,
+                                                                                        the_id))
+            return(p)
+
+    __solver_class = Problem
+    parameter_mappings = parameter_mappings['%s_%s'%(solver_name,
+                                                     __name)]
+    variable_kind_dict = eval(variable_kind_dict['%s_%s'%(solver_name,
+                                                          __name)])
+    objective_senses = objective_senses['%s_%s'%(solver_name,
+                                                 __name)]
+    ## from jarray import array as j_array
+    ## def array(x, variable_type='d'):
+    ##     return j_array(x, variable_type)
+
+
+    def get_status(lp):
+        status = repr(lp.status).lower()
+        if status in status_dict:
+            status = status_dict[status]
+        else:
+            status = 'failed'
+        return status
+
+    def set_parameter(lp, parameter_name, parameter_value):
+        if parameter_name == 'objective_sense':
+            objective = lp.getObjective()
+            if objective is not None:
+                objective.setSense(eval(objective_senses[parameter_value]))
+
+        else:
+            if hasattr(DoubleParam, parameter_name):
+                parameter_type = 'DoubleParam'
+            elif hasattr(IntParam, parameter_name):
+                parameter_type = 'IntParam'
+            elif hasattr(StringParam, parameter_name):
+                parameter_type = 'StringParam'
+            else:
+                raise Exception("%s is not a DoubleParam, IntParam, or StringParam"%parameter_name)
+            lp.setParam(eval('%s.%s'%(parameter_type, parameter_name)),
+                        parameter_value)
+
+    def format_solution(lp, cobra_model, **kwargs):
+        """
+        TODO
+        """
+        status = get_status(lp)
+        try:
+            x = lp.getValues(lp.variables)
+            x_dict = dict(zip(cobra_model.reactions, x))
+            objective_value = lp.getObjValue()
+        except:
+            x = x_dict = objective_value = None
+            #print status
+
+        try:
+            y = lp.getDuals(lp.variables)
+            y_dict = dict(zip(cobra_model.metabolites, y))
+        except:
+            y = y_dict = None
+        return(Solution(objective_value, x=x, x_dict=x_dict, y=y,
+                        y_dict=y_dict, status=status))
+
+    def create_problem(cobra_model,  **kwargs):
+        """Solver-specific method for constructing a solver problem from
+        a cobra.Model.  This can be tuned for performance using kwargs
+
+        TODO: This will need to be specific for python / jython
+        """
+        the_parameters = parameter_defaults
+        if kwargs:
+            the_parameters = deepcopy(parameter_defaults)
+            the_parameters.update(kwargs)
+
+        lp = Problem()
+
+        if 'log_file' not in the_parameters:
+            lp.setWarning(None)
+            lp.setOut(None)
+        [set_parameter(lp, parameter_mappings[k], v)
+         for k, v in the_parameters.iteritems() if k in parameter_mappings]
+        quadratic_component = the_parameters['quadratic_component']
+        new_objective = the_parameters['new_objective']
+        error_reporting = the_parameters['error_reporting']
+        lp._objective_sense  = the_parameters['objective_sense']
+        if 'relax_b' in the_parameters:
+            warn('need to reimplement relax_b')
+            relax_b = False
+        else:
+            relax_b = False
+
+        #Using the new objects
+        #NOTE: This might be slow
+        objective_coefficients = []
+        lower_bounds = []
+        upper_bounds = []
+        variable_names = []
+        variable_kinds = []
+        [(objective_coefficients.append(x.objective_coefficient),
+          lower_bounds.append(x.lower_bound),
+          upper_bounds.append(x.upper_bound),
+          variable_names.append(x.id),
+          variable_kinds.append(variable_kind_dict[x.variable_kind]))
+         for x in cobra_model.reactions]
+
+        #Only add the variable types if one or more variables is an integer, just
+        #in case the java interface has the same bug as the python interface where
+        #the problem type switches to integer if variable types are supplied even
+        #if all are continuous
+        if variable_kind_dict['integer'] in variable_kinds:
+            lp.variables = lp.numVarArray(len(cobra_model.reactions), lower_bounds,
+                                          upper_bounds, variable_kinds, variable_names)
+        else:
+            lp.variables = lp.numVarArray(len(cobra_model.reactions), lower_bounds, upper_bounds,
+                                          variable_names)
+        
+        lp.variable_dict = dict(zip(cobra_model.reactions, lp.variables))
+        if lp._objective_sense == 'maximize':
+            __lp_add_objective = lp.addMaximize
+        else:
+            __lp_add_objective = lp.addMinimize
+
+        __lp_add_objective(lp.scalProd(lp.variables, objective_coefficients))
+        
+
+        
+        lp.constraints = []
+        lp.constraint_dict = {}
+        for the_metabolite in cobra_model.metabolites:
+            linear_expression = lp.sum([lp.prod(k._metabolites[the_metabolite],
+                                                lp.variable_dict[k])
+                                        for k in the_metabolite._reaction])
+            expression_pointer = lp.add_linear_expression(linear_expression, the_metabolite)
+            lp.constraints.append(expression_pointer)
+            lp.constraint_dict[the_metabolite] = expression_pointer
+        
+        if quadratic_component is not None:
+            raise Exception("cplex through java isn't configured for QPs yet")
+            if not hasattr(quadratic_component, 'todok'):
+                raise Exception('quadratic component must have method todok')
+            quadratic_component_scaled = quadratic_component.todok()
+
+            lp.parameters.emphasis.numerical.set(1)
+            for k, v in quadratic_component_scaled.items():
+                lp.objective.set_quadratic_coefficients(int(k[0]), int(k[1]), v)
+
+        if error_reporting == 'time':
+            print 'setup new problem: ' + repr(time()-start_time)
+            start_time = time()
+
+        ## #Set the problem type as cplex doesn't appear to do this correctly
+        ## problem_type = Cplex.problem_type.LP
+        ## if Cplex.variables.type.integer in variable_kinds:
+        ##     if quadratic_component is not None:
+        ##         problem_type = Cplex.problem_type.MIQP
+        ##     else:
+        ##         problem_type = Cplex.problem_type.MILP
+        ## elif quadratic_component is not None:
+        ##     problem_type = Cplex.problem_type.QP
+        ## lp.set_problem_type(problem_type)
+        return(lp)
+
+
+    def update_problem(lp, cobra_model, **kwargs):
+        """A performance tunable method for updating a model problem file
+
+        lp: A gurobi problem object
+
+        cobra_model: the cobra.Model corresponding to 'lp'
+
+        """
+        #When reusing the basis only assume that the objective coefficients or bounds can change
+        #BUG with changing / unchanging the basis
+        try:
+            new_objective = kwargs['new_objective']
+        except:
+            new_objective = None
+        try:
+            update_problem_reaction_bounds = kwargs['update_problem_reaction_bounds']
+        except:
+            update_problem_reaction_bounds = True
+        try:
+            quadratic_component = kwargs['quadratic_component']
+            if quadratic_component is not None:
+                warn("update_problem does not yet take quadratic_component as a parameter")
+        except:
+            quadratic_component = None
+
+        the_objective = lp.getObjective()
+        for the_variable, the_reaction in zip(lp.variables, cobra_model.reactions):
+            the_variable.setUB(float(the_reaction.upper_bound))
+            the_variable.setLB(float(the_reaction.lower_bound))
+            the_objective.setLinearCoef(the_variable, the_reaction.objective_coefficient)
+            
+
+else:
+    ###Python functions
+    parameter_mappings = parameter_mappings[solver_name]
+    objective_senses = objective_senses[solver_name]
+    from cplex import Cplex, SparsePair
+    class Problem(Cplex):
+        def __init__(self):
+            Cplex.__init__(self)
+    __solver_class = Problem
+    variable_kind_dict = eval(variable_kind_dict[solver_name])
+    status_dict = eval(status_dict[solver_name])
+    def get_status(lp):
+        status = lp.solution.get_status_string().lower()
+        if status in status_dict:
+            status = status_dict[status]
+        else:
+            status = 'failed'
+        return status
+
+    def format_solution(lp, cobra_model, **kwargs):
+        status = get_status(lp)
+        #TODO: It might be able to speed this up a little.
+        if status == 'optimal':
+            objective_value = lp.solution.get_objective_value()
+            #This can be sped up a little
+            x_dict = dict(zip(lp.variables.get_names(),
+                         lp.solution.get_values()))
+            x = lp.solution.get_values()
+            #MIP's don't have duals
+            if lp.get_problem_type() in (Cplex.problem_type.MIQP,
+                                         Cplex.problem_type.MILP):
+
+                y = y_dict = None
+            else:
+                y_dict = dict(zip(lp.linear_constraints.get_names(),
+                                  lp.solution.get_dual_values()))
+                y = lp.solution.get_dual_values()
+        else:
+            x = y = x_dict = y_dict = objective_value = None
+
+        the_solution = Solution(objective_value, x=x, x_dict=x_dict,
+                                status=status, y=y, y_dict=y_dict)
+        return the_solution    
+   
+    def set_parameter(lp, parameter_name, parameter_value):
+        """
+        
+        """
+        if parameter_name == 'objective.set_sense':
+            if parameter_value in objective_senses:
+                parameter_value = eval(objective_senses[parameter_value])
+        try:
+            eval('lp.%s(%s)'%(parameter_name, repr(parameter_value)))
+        except Exception, e:
+            print "Couldn't set parameter %s: %s"%(parameter_name, repr(e))
+
+
+
+    def create_problem(cobra_model,  **kwargs):
+        """Solver-specific method for constructing a solver problem from
+        a cobra.Model.  This can be tuned for performance using kwargs
+
+
+        """
+        the_parameters = parameter_defaults
+        if kwargs:
+            the_parameters = deepcopy(parameter_defaults)
+            the_parameters.update(kwargs)
+
+        lp = __solver_class()
+        if 'log_file' not in the_parameters:
+            lp.set_results_stream(None)
+            lp.set_warning_stream(None)
+        [set_parameter(lp, parameter_mappings[k], v)
+         for k, v in the_parameters.iteritems() if k in parameter_mappings]
+        quadratic_component = the_parameters['quadratic_component']
+        new_objective = the_parameters['new_objective']
+        error_reporting = the_parameters['error_reporting']
+        if 'relax_b' in the_parameters:
+            warn('need to reimplement relax_b')
+            relax_b = False
+        else:
+            relax_b = False
+
+        #Using the new objects
+        #NOTE: This might be slow
+        objective_coefficients = []
+        lower_bounds = []
+        upper_bounds = []
+        variable_names = []
+        variable_kinds = []
+        [(objective_coefficients.append(x.objective_coefficient),
+          lower_bounds.append(x.lower_bound),
+          upper_bounds.append(x.upper_bound),
+          variable_names.append(x.id),
+          variable_kinds.append(variable_kind_dict[x.variable_kind]))
+         for x in cobra_model.reactions]
+        #Cplex decides that the problem is a MIP if variable_kinds are supplied
+        #even if there aren't any integers.
+        if variable_kind_dict['integer'] in variable_kinds:
+            lp.variables.add(obj=objective_coefficients,
+                             lb=lower_bounds,
+                             ub=upper_bounds,
+                             names=variable_names,
+                             types=variable_kinds)
+        else:
+            lp.variables.add(obj=objective_coefficients,
+                             lb=lower_bounds,
+                             ub=upper_bounds,
+                             names=variable_names)
+
+       ## if relax_b:
+            ## range_values = zeros(len(cobra_model.metabolites))
+            ## b_values = array([x._bound for x in cobra_model.metabolties])
+            ## for the_nonzero in list(b_values.nonzero()[0]):
+            ##     range_values[the_nonzero] = -relax_b
+
+        constraint_sense = []
+        constraint_names = []
+        constraint_limits = []
+        [(constraint_sense.append(x._constraint_sense),
+          constraint_names.append(x.id),
+          constraint_limits.append(x._bound))
+         for x in cobra_model.metabolites]
+
+        the_linear_expressions = []
+        #NOTE: This won't work with metabolites that aren't in any reaction
+        for the_metabolite in cobra_model.metabolites:
+            variable_list = []
+            coefficient_list = []
+            for the_reaction in the_metabolite._reaction:
+                variable_list.append(the_reaction.id)
+                coefficient_list.append(the_reaction._metabolites[the_metabolite])
+            the_linear_expressions.append(SparsePair(ind=variable_list,
+                                                     val=coefficient_list))
+        if quadratic_component is not None:
+            if not hasattr(quadratic_component, 'todok'):
+                raise Exception('quadratic component must have method todok')
+            quadratic_component_scaled = quadratic_component.todok()
+
+            lp.parameters.emphasis.numerical.set(1)
+            for k, v in quadratic_component_scaled.items():
+                lp.objective.set_quadratic_coefficients(int(k[0]), int(k[1]), v)
+
+
+        if relax_b:
+            lp.linear_constraints.add(lin_expr=the_linear_expressions,
+                                      rhs=constraint_limits,
+                                      range_values=list(range_values),
+                                      senses=constraint_sense,
+                                      names=constraint_names)
+
+        else:
+            lp.linear_constraints.add(lin_expr=the_linear_expressions,
+                                      rhs=constraint_limits,
+                                      senses=constraint_sense,
+                                      names=constraint_names)
+
+        if error_reporting == 'time':
+            print 'setup new problem: ' + repr(time()-start_time)
+            start_time = time()
+
+        #Set the problem type as cplex doesn't appear to do this correctly
+        problem_type = Cplex.problem_type.LP
+        if Cplex.variables.type.integer in variable_kinds:
+            if quadratic_component is not None:
+                problem_type = Cplex.problem_type.MIQP
+            else:
+                problem_type = Cplex.problem_type.MILP
+        elif quadratic_component is not None:
+            problem_type = Cplex.problem_type.QP
+        lp.set_problem_type(problem_type)
+        return(lp)
+
+###
+
+    def update_problem(lp, cobra_model, **kwargs):
+        """A performance tunable method for updating a model problem file
+
+        lp: A gurobi problem object
+
+        cobra_model: the cobra.Model corresponding to 'lp'
+
+        """
+        #When reusing the basis only assume that the objective coefficients or bounds can change
+        #BUG with changing / unchanging the basis
+        try:
+            new_objective = kwargs['new_objective']
+        except:
+            new_objective = None
+        try:
+            update_problem_reaction_bounds = kwargs['update_problem_reaction_bounds']
+        except:
+            update_problem_reaction_bounds = True
+        try:
+            quadratic_component = kwargs['quadratic_component']
+            if quadratic_component is not None:
+                warn("update_problem does not yet take quadratic_component as a parameter")
+        except:
+            quadratic_component = None
+
+        if new_objective is not None:
+            lp.objective.set_linear([(x.id, float(x.objective_coefficient))
+                                     for x in cobra_model.reactions])
+        if update_problem_reaction_bounds:
+            lp.variables.set_upper_bounds([(x.id, float(x.upper_bound))
+                                            for x in cobra_model.reactions])
+            lp.variables.set_lower_bounds([(x.id, float(x.lower_bound))
+                                            for x in cobra_model.reactions])
+
+
+
+###
+def solve_problem(lp, **kwargs):
+    """A performance tunable method for updating a model problem file
+
+    """
+    #Update parameter settings if provided
+    if kwargs:
+        [set_parameter(lp, parameter_mappings[k], v)
+         for k, v in kwargs.iteritems() if k in parameter_mappings]
+    try:
+        print_solver_time = kwargs['print_solver_time']
+        start_time = time()
+    except:
+        print_solver_time = False
+
+    try:
+        the_problem = kwargs['the_problem']
+    except:
+        the_problem = False
+    if isinstance(the_problem, __solver_class):
+        try:
+            the_basis = the_problem.solution.basis.get_basis()
+            lp.start.set_basis(the_basis[0],the_basis[1])
+            lp.parameters.preprocessing.presolve.set(0)
+        except:
+            warn("cplex_java isn't yet configured to reuse the basis")
+    
+    lp.solve()
+    #If the solver takes more than 0.1 s with a hot start it is likely stuck
+    status = get_status(lp)
+    if status != 'optimal':
+        #Cycle through the different solver options, if a solution is not found
+        for lp_method in (1, 2, 3, 4, 5, 6):
+            set_parameter(lp, parameter_mappings['lp_method'], lp_method)
+            lp.solve()
+            status = get_status(lp)
+            if status == 'optimal':
+                break
+
+    if print_solver_time:
+        print 'optimize time: %f'%(time() - start_time)
+    return status
+
+    
+def solve(cobra_model, **kwargs):
+    """
+
+    """
+        #Update objectives if they are new.
+    if 'new_objective' in kwargs and \
+           kwargs['new_objective'] not in ['update problem', None]:
+       update_objective(cobra_model, kwargs['new_objective'])
+
+    if 'the_problem' in kwargs:
+        the_problem = kwargs['the_problem']
+    else:
+        the_problem = None
+    if 'error_reporting' in kwargs:
+        error_reporting = kwargs['error_reporting']
+    else:
+        error_reporting = False
+    if isinstance(the_problem, __solver_class):
+        #Update the problem with the current cobra_model
+        lp = the_problem
+        update_problem(lp, cobra_model, **kwargs)
+    else:
+        #Create a new problem
+        lp = create_problem(cobra_model, **kwargs)
+    #Deprecated way for returning a solver problem created from a cobra_model
+    #without performing optimization
+    if the_problem == 'setup':
+        return lp
+    status = solve_problem(lp, **kwargs)
+    the_solution = format_solution(lp, cobra_model)
+    if status != 'optimal' and error_reporting:
+        print '%s failed: %s'%(solver_name, status)
+    cobra_model.solution = the_solution
+    solution = {'the_problem': lp, 'the_solution': the_solution}
+    return solution
Index: cobra/solvers/gurobi.py
===================================================================
--- cobra/solvers/gurobi.py	(revision 330)
+++ cobra/solvers/gurobi.py	(working copy)
@@ -1,88 +0,0 @@
-from gurobipy import GRB, Model, LinExpr, GRB, QuadExpr, Column
-from numpy import array
-
-from ..core.Solution import Solution
-
-
-# mappers from cobra representation to gurobi
-sense_dict = {
-    'E': GRB.EQUAL,
-    'L': GRB.LESS_EQUAL,
-    'G': GRB.GREATER_EQUAL}
-variable_kind_dict = {
-    'continuous': GRB.CONTINUOUS,
-    'integer': GRB.INTEGER}
-parameter_dict = {  # TODO USE
-    "tolerance_feasibility": "FeasibilityTol",
-    "tolerance_optimality": "OptimalityTol"}
-default_parameters = {
-}
-
-# mappers from gurobi representations to cobra
-status_dict = {
-    GRB.OPTIMAL: 'optimal',
-    GRB.INFEASIBLE: 'infeasible',
-    GRB.UNBOUNDED: 'unbounded'}
-
-
-def create_problem(cobra_model, objective_sense="maximize"):
-    lp = Model("cobra")
-    lp.Params.OutputFlag = 0
-
-    if objective_sense == 'maximize':
-        objective_sign = -1.0
-    elif objective_sense == 'minimize':
-        objective_sign = 1.0
-    else:
-        raise ValueError("objective_sense must be 'maximize' or 'minimize'")
-
-    # create metabolites/constraints
-    metabolite_constraints = {}
-    for metabolite in cobra_model.metabolites:
-        metabolite_constraints[metabolite] = \
-            lp.addConstr(0.0, sense_dict[metabolite._constraint_sense],
-            metabolite._bound, metabolite.id)
-    lp.update()
-
-    # create reactions/variables along with S matrix
-    for j, reaction in enumerate(cobra_model.reactions):
-        constraints = [metabolite_constraints[i] \
-            for i in reaction._metabolites]
-        stoichiometry = reaction._metabolites.values()
-        lp.addVar(
-            lb=float(reaction.lower_bound),
-            ub=float(reaction.upper_bound),
-            obj=objective_sign * reaction.objective_coefficient,
-            name=reaction.id,
-            vtype=variable_kind_dict[reaction.variable_kind],
-            column=Column(stoichiometry, constraints))
-    lp.update()
-    return lp
-
-
-def update_problem(cobra_model, lp, objective_sense="maximize"):
-    pass
-    # TODO implement
-
-
-def solve_problem(lp):
-    lp.optimize()
-    try:
-        status = status_dict[lp.status]
-    except KeyError:
-        status = "unkown error: " + lp.status
-    solution = Solution(status)
-    solution.status = status
-    if status == "optimal":
-        solution.objective_value = lp.ObjVal * -1  # TODO fix sign
-        solution.x_dict = dict((v.VarName, v.X) for v in lp.getVars())
-        if lp.isMIP:
-            solution.y_dict = None  # MIP's don't have duals
-        else:
-            solution.y_dict = \
-                dict((c.ConstrName, c.Pi) for c in lp.getConstrs())
-    return solution
-
-
-def solve(cobra_model, objective_sense="maximize", **kwargs):
-    return solve_problem(create_problem(cobra_model, objective_sense))
Index: cobra/solvers/glpk_solver.py
===================================================================
--- cobra/solvers/glpk_solver.py	(revision 0)
+++ cobra/solvers/glpk_solver.py	(revision 0)
@@ -0,0 +1,555 @@
+##cobra.solvers.glpk_solver
+#This script provides wrappers for libglpk-java 1.0.22 and pyglpk 0.3
+from __future__ import absolute_import
+from warnings import warn
+from os import name as __name
+from copy import deepcopy
+###solver specific parameters
+from .parameters import status_dict, variable_kind_dict, \
+     sense_dict, parameter_mappings, parameter_defaults, \
+     objective_senses, default_objective_sense
+
+from ..core.Solution import Solution
+from ..flux_analysis.objective import update_objective
+from time import time
+solver_name = 'glpk'
+sense_dict = eval(sense_dict[solver_name])
+#Functions that are different for java implementation of a solver
+if __name == 'java':
+    warn("cobra.solvers.glpk_solver isn't mature.  consider using gurobi or cplex")
+    from org.gnu.glpk import GLPK, GLPKConstants, glp_smcp, glp_iocp
+    variable_kind_dict = eval(variable_kind_dict['%s_%s'%(solver_name,
+                                                __name)])
+    status_dict = eval(status_dict['%s_%s'%(solver_name,
+                                                __name)])
+    objective_senses = objective_senses['%s_%s'%(solver_name,
+                                                __name)]
+    parameter_mappings = parameter_mappings['%s_%s'%(solver_name,
+                                                     __name)]
+    parameter_defaults = parameter_defaults['%s_%s'%(solver_name,
+                                                     __name)]
+
+    class Problem():
+        """Create a more pythonesqe class to wrap the key
+        features of the libglpk-java functions.
+        
+        """
+        def __init__(self):
+            """the attributes g, lp, mip should be made private
+            """
+            self._g = GLPK
+            self._lp= GLPK.glp_create_prob()
+            self._simplex_parameters = glp_smcp()
+            self._mip_parameters = None
+            self._g.glp_init_smcp(self._simplex_parameters)
+            self.status = self.objective_value = None
+            self._mip = False
+        def set_name(self, name=''):
+            self._g.glp_set_prob_name(self._lp, name)
+
+        def solve(self):
+            try:
+                self._g.glp_simplex(self._lp,
+                                   self._simplex_parameters)
+                if self._mip:
+                    #perform the MIP
+                    setattr(self._mip_parameters, 'msg_lev',
+                             self._simplex_parameters.msg_lev)
+                    self._g.glp_intopt(self._lp, self._mip_parameters)
+                self.status = self.get_status()
+                self.objective_value = self.get_objective_value()
+            except:
+                self.status = 'failed'
+            return self.status
+
+        def get_status(self):
+            if self._mip:
+                status = self._g.glp_mip_status(self._lp)
+            else:
+                status = self._g.glp_get_status(self._lp)
+            return status_dict[status]
+        
+        def set_objective_sense(self, parameter_value='maximize'):
+            self._g.glp_set_obj_dir(self._lp,
+                                   eval(objective_senses[parameter_value]))
+
+        def set_parameter(self, parameter_name, parameter_value, warning=False):
+            if parameter_name == 'objective_sense':
+                self.set_objective_sense(parameter_value)
+            else:
+                if parameter_name == 'meth' and parameter_value not in [1,2,3]:
+                    parameter_value = 1
+                try:
+                    setattr(self._simplex_parameters, parameter_name,
+                            parameter_value)
+                except Exception, e1:
+                    try:
+                        setattr(self._mip_parameters, parameter_name,
+                                parameter_value)
+                    except Exception, e2:
+                        if warning:
+                            print "Could not set simplex parameter " +\
+                                  "%s: %s"%(parameter_name, repr(e1))
+                            
+                            if self._mip_parameters is not None:
+                                print "Could not set mip parameter " +\
+                                      "%s: %s"%(parameter_name, repr(e2))
+        def get_objective_value(self):
+            if self._mip:
+                tmp_value = self._g.glp_mip_obj_val(self._lp)
+            else:
+                tmp_value = self._g.glp_get_obj_val(self._lp)
+            return tmp_value
+
+        def create_problem(self, cobra_model):
+            g = self._g
+            lp = self._lp
+            number_of_reactions = len(cobra_model.reactions)
+            number_of_metabolites = len(cobra_model.metabolites)
+            g.glp_add_cols(lp, number_of_reactions)
+            reaction_to_index = {}
+            objective_dict = {}
+            #Add in the variables
+            tmp_kinds = []
+            for i, the_reaction in enumerate(cobra_model.reactions):
+                i_offset = i + 1
+                reaction_to_index[the_reaction] = i_offset
+                if the_reaction.objective_coefficient != 0:
+                    objective_dict[i_offset] = the_reaction.objective_coefficient
+                g.glp_set_col_name(lp, i_offset, the_reaction.id)
+                tmp_kinds.append(the_reaction.variable_kind)
+                the_kind = variable_kind_dict[the_reaction.variable_kind]
+                lower_bound = the_reaction.lower_bound
+                upper_bound = the_reaction.upper_bound
+                #Note. It is possible to have unbounded or one-bound variables
+                if lower_bound == upper_bound:
+                    bound_kind = GLPKConstants.GLP_FX
+                else:
+                    bound_kind = GLPKConstants.GLP_DB
+                g.glp_set_col_kind(lp, i_offset, the_kind)
+                g.glp_set_col_bnds(lp, i_offset,
+                                   bound_kind, the_reaction.lower_bound,
+                                   the_reaction.upper_bound)
+            tmp_kinds = set(tmp_kinds)
+            if 'integer' in tmp_kinds or 'binary' in tmp_kinds:
+                self._mip = True
+                self._mip_parameters = glp_iocp()
+                g.glp_init_iocp(self._mip_parameters)
+            #create constraints
+            g.glp_add_rows(lp, number_of_metabolites)
+            row_indices = []
+            column_indices = []
+            constraint_values = []
+            for i, the_metabolite in enumerate(cobra_model.metabolites):
+                i_offset = i + 1
+                g.glp_set_row_name(lp, i_offset, the_metabolite.id)
+
+                lower_bound = upper_bound = the_metabolite._bound
+                constraint_sense = sense_dict[the_metabolite._constraint_sense]
+                if constraint_sense == 'E':
+                    bound_type = GLPKConstants.GLP_FX
+                elif constraint_sense == 'L':
+                    bound_type = GLPKConstants.GLP_UP
+                elif constraint_sense == 'G':
+                    bound_type = GLPKConstants.GLP_LO
+                elif constraint_sense == 'U':
+                    bound_type = GLPKConstants.GLP_FR
+                elif hasattr(lower_bound, '__iter__'):
+                    lower_bound, upper_bound = lower_bound[:2]
+                    bound_type = GLPKConstants.GLP_DB
+                    
+
+                g.glp_set_row_bnds(lp, i_offset, bound_type,
+                                   lower_bound, upper_bound)
+
+                [(row_indices.append(i_offset),
+                  column_indices.append(reaction_to_index[k]),
+                  constraint_values.append(k._metabolites[the_metabolite]))
+                 for k in the_metabolite._reaction]
+
+            #Load the constraints into the lp.  Need to use
+            #typed arrays.
+            number_of_constraints = len(row_indices)
+            i_array = g.new_intArray(number_of_constraints)
+            j_array = g.new_intArray(number_of_constraints)
+            v_array = g.new_doubleArray(number_of_constraints)
+            for a, (i, j, v) in enumerate(zip(row_indices,
+                                              column_indices,
+                                              constraint_values)):
+                g.intArray_setitem(i_array, a+1, i)
+                g.intArray_setitem(j_array, a+1, j)
+                g.doubleArray_setitem(v_array, a+1, v)
+            g.glp_load_matrix(lp, number_of_constraints, i_array,
+                              j_array, v_array)
+            g.delete_intArray(i_array)
+            g.delete_intArray(j_array)
+            g.delete_doubleArray(v_array)
+            
+    
+            g.glp_set_obj_name(lp, "z")
+            [g.glp_set_obj_coef(lp, k, v)
+              for k, v in objective_dict.iteritems()]
+
+            
+
+
+
+
+    __solver_class = Problem
+
+    def set_parameter(lp, parameter_name, parameter_value):
+        lp.set_parameter(parameter_name, parameter_value)
+
+
+    def get_status(lp):
+        return lp.get_status()
+
+    def format_solution(lp, cobra_model, **kwargs):
+        """
+
+        """
+        status = get_status(lp)
+        if not lp._mip:
+            try:
+                x = [lp._g.glp_get_col_prim(lp._lp, i + 1)
+                     for i in range(len(cobra_model.reactions))]
+                x_dict = dict(zip(cobra_model.reactions, x))
+
+                y = [lp._g.glp_get_row_dual(lp._lp, i + 1)
+                     for i in range(len(cobra_model.metabolites))]
+                y_dict = dict(zip(cobra_model.metabolites, y))
+            
+                objective_value = lp.objective_value
+            except Exception, e:
+                print repr(e)
+                y = y_dict = x = x_dict = objective_value = None
+                #print status
+        else:
+            try:
+                x = [lp._g.glp_mip_col_val(lp._lp, i + 1)
+                     for i in range(len(cobra_model.reactions))]
+                x_dict = dict(zip(cobra_model.reactions, x))
+                y = y_dict = None
+                objective_value = lp.objective_value
+            except:
+                y = y_dict = x = x_dict = objective_value = None
+
+        return(Solution(objective_value, x=x, x_dict=x_dict, y=y,
+                        y_dict=y_dict, status=status))
+    def create_problem(cobra_model,  **kwargs):
+        """Solver-specific method for constructing a solver problem from
+        a cobra.Model.  This can be tuned for performance using kwargs
+
+
+        """
+        the_parameters = parameter_defaults
+        if kwargs:
+            the_parameters = deepcopy(parameter_defaults)
+            the_parameters.update(kwargs)
+        quadratic_component = the_parameters['quadratic_component']
+        new_objective = the_parameters['new_objective']
+        if quadratic_component is not None:
+            raise Exception('%s cannot solve QPs, try a different solver'%solver_name)
+        lp = Problem()        # Create empty problem instance
+        lp.create_problem(cobra_model)
+        [set_parameter(lp, parameter_mappings[k], v)
+         for k, v in the_parameters.iteritems() if k in parameter_mappings]
+        return(lp)
+    
+    def update_problem(lp, cobra_model, **kwargs):
+        """
+        Assumes that neither Metabolites nor Reaction have been
+        added or removed.
+
+        Currently only deals with reaction bounds and objective
+        coefficients.
+
+        """
+        g = lp._g
+        l = lp._lp
+        for i, the_reaction in enumerate(cobra_model.reactions):
+            lower_bound = float(the_reaction.lower_bound)
+            upper_bound = float(the_reaction.upper_bound)
+            objective_coefficient = float(the_reaction.objective_coefficient)
+            if lower_bound == upper_bound:
+                bound_type = GLPKConstants.GLP_FX
+            else:
+                bound_type = GLPKConstants.GLP_DB
+            g.glp_set_col_bnds(l, i + 1, bound_type, lower_bound, upper_bound)
+            g.glp_set_obj_coef(l, i + 1, objective_coefficient)
+
+        
+    def solve_problem(lp, **kwargs):
+        """A performance tunable method for updating a model problem file
+
+        """
+        #Update parameter settings if provided
+        if kwargs:
+            [set_parameter(lp, parameter_mappings[k], v)
+             for k, v in kwargs.iteritems() if k in parameter_mappings]
+        try:
+            print_solver_time = kwargs['print_solver_time']
+            start_time = time()
+        except:
+            print_solver_time = False
+        lp_method = lp._simplex_parameters.meth
+        the_methods = [1, 2, 3]
+        if lp_method in the_methods:
+            the_methods.remove(lp_method)
+        else:
+            lp_method = 1
+        lp.solve()
+        status = get_status(lp)
+        if status != 'optimal':
+            for lp_method in the_methods:
+                set_parameter(lp, parameter_mappings['lp_method'], lp_method)
+                lp.solve()
+                status = get_status(lp)
+                break
+        if print_solver_time:
+            print 'optimize time: %f'%(time() - start_time)
+        return status
+else:
+    ##Interface to pyGLPK 0.3 
+    from glpk import LPX as GLPK
+    __solver_class = GLPK
+    objective_senses = objective_senses[solver_name]
+    variable_kind_dict = eval(variable_kind_dict[solver_name])
+    status_dict = eval(status_dict[solver_name])
+    parameter_mappings = parameter_mappings[solver_name]
+    parameter_defaults = parameter_defaults[solver_name]
+
+    def get_status(lp):
+        status = lp.status
+        if status in status_dict:
+            status = status_dict[status]
+        else:
+            status = 'failed'
+        return status
+
+    def format_solution(lp, cobra_model, **kwargs):
+        try:
+            objective_sign = objective_senses[kwargs['objective_sense']]
+        except:
+            objective_sign = objective_senses[default_objective_sense]
+            
+        status = get_status(lp)
+        if status == 'optimal':
+            objective_value = lp.obj.value
+            x = []
+            x_dict = {}
+            [(x.append(float(c.primal)),
+              x_dict.update({c.name:c.primal}))
+              for c in lp.cols]
+
+            if lp.kind == float:
+                y = []
+                y_dict = {}
+                #return the duals as well as the primals for LPs
+                [(y.append(float(c.dual)),
+                  y_dict.update({c.name:c.dual}))
+                 for c in lp.rows]
+            else:
+                #MIPs don't have duals
+                y = y_dict = None
+            the_solution = Solution(objective_value, x=x, x_dict=x_dict, y=y,
+                                    y_dict=y_dict, status=status)
+        else:
+            the_solution = Solution(None, status=status)
+        return(the_solution)
+
+    def set_parameter(lp, parameter_name, parameter_value):
+        """with pyglpk the parameters are set during the solve phase
+        """
+        warn("py glpk solver parameters are set during solve_problem")
+        pass
+
+    def create_problem(cobra_model,  **kwargs):
+        """Solver-specific method for constructing a solver problem from
+        a cobra.Model.  This can be tuned for performance using kwargs
+
+
+        """
+        the_parameters = parameter_defaults
+        if kwargs:
+            the_parameters = deepcopy(parameter_defaults)
+            the_parameters.update(kwargs)
+        quadratic_component = the_parameters['quadratic_component']
+        new_objective = the_parameters['new_objective']
+        if quadratic_component is not None:
+            raise Exception('%s cannot solve QPs, try a different solver'%solver_name)
+        #Faster to use these dicts than index lists
+        index_to_metabolite = dict(zip(range(len(cobra_model.metabolites)),
+                                       cobra_model.metabolites))
+        index_to_reaction = dict(zip(range(len(cobra_model.reactions)),
+                                     cobra_model.reactions))
+        reaction_to_index = dict(zip(index_to_reaction.values(),
+                                     index_to_reaction.keys()))
+
+
+        lp = __solver_class()        # Create empty problem instance
+        lp.name = 'cobra'     # Assign symbolic name to problem
+        lp.rows.add(len(cobra_model.metabolites))
+        lp.cols.add(len(cobra_model.reactions))
+        linear_constraints = []
+        for r in lp.rows:
+            the_metabolite = index_to_metabolite[r.index]
+            r.name = the_metabolite.id
+            b = float(the_metabolite._bound)
+            c = sense_dict[the_metabolite._constraint_sense]
+            if c == 'E':
+                r.bounds = b, b     # Set metabolite to steady state levels
+            elif c == 'L':
+                r.bounds = None, b
+            elif c == 'G':
+                r.bounds = b, None
+            #Add in the linear constraints
+
+            for the_reaction in the_metabolite._reaction:
+                reaction_index = reaction_to_index[the_reaction]
+                the_coefficient = the_reaction._metabolites[the_metabolite]
+                linear_constraints.append((r.index, reaction_index,
+                                           the_coefficient))
+        #Need to assign lp.matrix after constructing the whole list
+        lp.matrix = linear_constraints
+        objective_coefficients = []
+
+        for c in lp.cols:
+            the_reaction = index_to_reaction[c.index]
+            c.name = the_reaction.id           
+            the_reaction = index_to_reaction[c.index]
+            c.kind = variable_kind_dict[the_reaction.variable_kind]
+            c.bounds = the_reaction.lower_bound, the_reaction.upper_bound
+            objective_coefficients.append(float(the_reaction.objective_coefficient))
+        #Add the new objective coefficients to the problem
+        lp.obj[:] = objective_coefficients
+
+        return(lp)
+
+
+    def update_problem(lp, cobra_model, **kwargs):
+        """A performance tunable method for updating a model problem file
+
+        lp: A gurobi problem object
+
+        cobra_model: the cobra.Model corresponding to 'lp'
+
+        """
+        #When reusing the basis only assume that the objective coefficients or bounds can change
+        #BUG with changing / unchanging the basis
+        index_to_metabolite = dict(zip(range(len(cobra_model.metabolites)),
+                                       cobra_model.metabolites))
+        index_to_reaction = dict(zip(range(len(cobra_model.reactions)),
+                                     cobra_model.reactions))
+        reaction_to_index = dict(zip(index_to_reaction.values(),
+                                     index_to_reaction.keys()))
+
+        try:
+            new_objective = kwargs['new_objective']
+        except:
+            new_objective = None
+        if new_objective is not None:
+            objective_coefficients = []
+            for c in lp.cols:      # Iterate over all rows
+                the_reaction = index_to_reaction[c.index]
+                c.name = the_reaction.id
+                c.bounds = the_reaction.lower_bound, the_reaction.upper_bound
+                objective_coefficients.append(float(the_reaction.objective_coefficient))
+                c.kind = variable_kind_dict[the_reaction.variable_kind]
+            #Add the new objective coefficients to the problem
+            lp.obj[:] = objective_coefficients
+        else:
+            for c in lp.cols:      # Iterate over all rows
+                the_reaction = index_to_reaction[c.index]
+                c.name = the_reaction.id
+                c.bounds = the_reaction.lower_bound, the_reaction.upper_bound
+                c.kind = variable_kind_dict[the_reaction.variable_kind]
+
+
+    ###
+    def solve_problem(lp, **kwargs):
+        """A performance tunable method for updating a model problem file
+
+        """
+        #Update parameter settings if provided
+        the_parameters = parameter_defaults
+
+        if kwargs:
+            the_parameters = deepcopy(parameter_defaults)
+            the_parameters.update(kwargs)
+        try:
+            print_solver_time = kwargs['print_solver_time']
+            start_time = time()
+        except:
+            print_solver_time = False
+        tolerance_optimality = the_parameters['tolerance_optimality']
+        tolerance_integer = the_parameters['tolerance_integer']
+        lp_method = the_parameters['lp_method']
+        #[set_parameter(lp, parameter_mappings[k], v)
+        # for k, v in kwargs.iteritems() if k in parameter_mappings]
+
+        lp.obj.maximize = objective_senses[the_parameters['objective_sense']] 
+        the_methods = [1, 2, 3]
+        if lp_method in the_methods:
+            the_methods.remove(lp_method)
+        else:
+            lp_method = 1
+
+        if lp.kind == int:
+            #For MILPs, it is faster to solve LP then move to MILP
+            lp.simplex(tol_bnd=tolerance_optimality,
+                       tol_dj=tolerance_optimality, meth=lp_method)  
+            lp.integer(tol_int=tolerance_integer)
+        else:
+            lp.simplex(tol_bnd=tolerance_optimality, tol_dj=tolerance_optimality,
+                       meth=lp_method)
+        status = get_status(lp)
+        if status != 'optimal':
+            for lp_method in the_methods:
+                lp.simplex(tol_bnd=tolerance_optimality,
+                           tol_dj=tolerance_optimality, meth=lp_method)
+                status = get_status(lp)
+                if status == 'optimal':
+                    if lp.kind == int:
+                        lp.integer(tol_int=tolerance_integer)
+                    break
+        if print_solver_time:
+            print 'optimize time: %f'%(time() - start_time)
+        return status
+
+    
+def solve(cobra_model, **kwargs):
+    """
+
+    """
+    #Update objectives if they are new.
+    if 'new_objective' in kwargs and \
+           kwargs['new_objective'] not in ['update problem', None]:
+       update_objective(cobra_model, kwargs['new_objective'])
+
+    if 'the_problem' in kwargs:
+        the_problem = kwargs['the_problem']
+    else:
+        the_problem = None
+    if 'error_reporting' in kwargs:
+        error_reporting = kwargs['error_reporting']
+    else:
+        error_reporting = False
+    if isinstance(the_problem, __solver_class):
+        #Update the problem with the current cobra_model
+        lp = the_problem
+        update_problem(lp, cobra_model, **kwargs)
+    else:
+        #Create a new problem
+        lp = create_problem(cobra_model, **kwargs)
+    #Deprecated way for returning a solver problem created from a cobra_model
+    #without performing optimization
+    if the_problem == 'setup':
+        return lp
+    status = solve_problem(lp, **kwargs)
+    the_solution = format_solution(lp, cobra_model)
+    if status != 'optimal' and error_reporting:
+        print '%s failed: %s'%(solver_name, status)
+    cobra_model.solution = the_solution
+    solution = {'the_problem': lp, 'the_solution': the_solution}
+    return solution
Index: cobra/oven/patches/patch_explanations.txt
===================================================================
--- cobra/oven/patches/patch_explanations.txt	(revision 330)
+++ cobra/oven/patches/patch_explanations.txt	(working copy)
@@ -1,3 +1,11 @@
+cobra_pie_0.2.alpha01.patch:
+  Adds support for gurobi, cplex, and libglpk-java solvers through jython and moves towards the new style solvers.  
+  Adds sbml support for jython via jsbml.
+  Adds get_model to Reaction and Metabolite/Gene which returns the Model object that contains the calling Object.
+  Adds get_reaction to Metabolite/Gene which returns a list of Reaction Objects that contain the calling Object.
+  Started to remove numpy/scipy dependencies from core objects / functions as they aren't really essential.
+
+
 DictList_tab_complete  
 Allows tab completion on a DictList, such as model.reactions.PG<TAB> will
 autocomplete to model.reactions.PGI
Index: cobra/oven/patches/cobra_pie_0.2.alpha01.patch
===================================================================
--- cobra/oven/patches/cobra_pie_0.2.alpha01.patch	(revision 0)
+++ cobra/oven/patches/cobra_pie_0.2.alpha01.patch	(revision 0)
@@ -0,0 +1,5633 @@
+Index: cobra/test/solvers.py
+===================================================================
+--- cobra/test/solvers.py	(revision 330)
++++ cobra/test/solvers.py	(working copy)
+@@ -1,5 +1,6 @@
+ from unittest import TestCase, TestLoader, TextTestRunner
+ import sys
++from pdb import set_trace
+ # deal with absolute imports by adding the appropriate directory to the path
+ sys.path.insert(0, "../..")
+ from cobra.manipulation import initialize_growth_medium
+@@ -14,7 +15,7 @@
+         self.model = create_test_model()
+         initialize_growth_medium(self.model, 'MgM')
+         self.old_solution = 0.320064
+-        self.infeasible_problem = Model()
++        self.infeasible_model = Model()
+         metabolite_1 = Metabolite("met1")
+         metabolite_2 = Metabolite("met2")
+         reaction_1 = Reaction("rxn1")
+@@ -23,8 +24,8 @@
+         reaction_2.add_metabolites({metabolite_2: 1})
+         reaction_1.lower_bound = 1
+         reaction_2.upper_bound = 2
+-        self.infeasible_problem.add_reactions([reaction_1, reaction_2])
+-        #self.infeasible_problem.update()
++        self.infeasible_model.add_reactions([reaction_1, reaction_2])
++        #self.infeasible_model.update()
+ 
+ 
+ def add_new_test(TestCobraSolver, solver_name, solver):
+@@ -39,22 +40,28 @@
+     def test_setup(self):
+         solver.create_problem(self.model)
+     def test_solve_feasible(self):
+-        solution = solver.solve(self.model)
++        solver.solve(self.model)
++        solution = self.model.solution        
+         self.assertEqual(solution.status, "optimal")
+         self.assertAlmostEqual(self.old_solution, \
+-            solution.objective_value, places=4)
++            solution.f, places=4)
+     def test_solve_infeasible(self):
+-        solution = solver.solve(self.infeasible_problem)
++        solver.solve(self.infeasible_model)
++        solution = self.infeasible_model.solution
+         self.assertEqual(solution.status, "infeasible")
++
+     def test_independent_creation(self):
+         feasible_lp = solver.create_problem(self.model)
+-        infeasible_lp = solver.create_problem(self.infeasible_problem)
+-        feasible_solution = solve_problem(lp)
+-        infeasible_solution = solve_problem(lp)
++        infeasible_lp = solver.create_problem(self.infeasible_model)
++        solver.solve_problem(feasible_lp)
++        solver.solve_problem(infeasible_lp)
++        feasible_solution = solver.format_solution(feasible_lp, self.model)
++        infeasible_solution = solver.format_solution(infeasible_lp, self.infeasible_model)
+         self.assertEqual(feasible_solution.status, "optimal")
+         self.assertAlmostEqual(self.old_solution, \
+-            feasible_solution.objective_value, places=4)
++            feasible_solution.f, places=4)
+         self.assertEqual(infeasible_solution.status, "infeasible")
++
+     setattr(TestCobraSolver, "test_%s_create" % solver_name, \
+         test_setup)
+     setattr(TestCobraSolver, "test_%s_attributes" % solver_name, \
+@@ -64,7 +71,7 @@
+     setattr(TestCobraSolver, "test_%s_infeasible_solve" % solver_name, \
+         test_solve_infeasible)
+     setattr(TestCobraSolver, "test_%s_independent_creation" % solver_name, \
+-        test_solve_infeasible)
++        test_independent_creation)
+ 
+ def add_legacy_test(TestCobraSolver, solver_name, solver_function):
+     """Creates a test set for each of the installed solvers using the
+Index: cobra/test/__init__.py
+===================================================================
+--- cobra/test/__init__.py	(revision 330)
++++ cobra/test/__init__.py	(working copy)
+@@ -1,10 +1,14 @@
++from __future__ import with_statement, absolute_import
+ from os import name as __name
+-from sys import modules as __modules
+ from warnings import warn
+-if __name == 'java':
+-    raise Exception("%s is not yet supported on jython"%__modules[__name__])
++test_import_string = 'from cobra.test.%s import test_all'
++available_tests = ['unit_tests', 'solvers']
++#if not using jython then add the tests that don't run through jython
++if __name != 'java':
++    available_tests += ['flux_analysis']
++    
+ 
+-del __name, __modules
++del __name
+ 
+ from os.path import abspath as __abspath
+ from os.path import join as __join
+@@ -24,12 +28,22 @@
+ 
+ def create_test_model(test_pickle=salmonella_pickle):
+     """returns the salmonella model for testing"""
++    from os import name as __name
+     try:
+         from cPickle import load
+     except:
+         from pickle import load
+-    with open(test_pickle, "rb") as infile:
+-        model = load(infile)
++
++    try: 
++        with open(test_pickle, "rb") as infile:
++            model = load(infile)
++    except:
++        #if the pickle can't be loaded then load the sbml xml
++        import sys
++        sys.path.insert(0, "../..")
++        from cobra.io import read_sbml_model
++        model = read_sbml_model(salmonella_sbml)
++        sys.path.pop(0)
+     return model
+ 
+ 
+@@ -38,15 +52,10 @@
+     import sys
+     sys.path.insert(0, "../..")
+     import unittest
+-    from cobra.test.unit_tests import test_all
+-    print '###running general unit tests###'
+-    test_all()
+-    from cobra.test.flux_analysis import test_all
+-    print '\n###running flux_analysis unit tests###'
+-    test_all()
+-    print '\n###running solver unit tests###'
+-    from cobra.test.solvers import test_all
+-    test_all()
++    for the_test in available_tests:
++        exec(test_import_string%the_test)
++        print '###running %s tests###'%the_test
++        test_all()
+     sys.path.pop(0)
+ 
+ del __abspath, __join, __split, __sep
+Index: cobra/test/flux_analysis.py
+===================================================================
+--- cobra/test/flux_analysis.py	(revision 330)
++++ cobra/test/flux_analysis.py	(working copy)
+@@ -90,7 +90,9 @@
+                                             the_reactions=cobra_model.reactions[100:140])
+         fva_out = dict([(k.id, v) for k, v in fva_out.items()])
+         for the_reaction, the_range in fva_out.iteritems():
++            #print the_reaction
+             for k, v in the_range.iteritems():
++                #print " %s: %s vs %s"%(k, repr(fva_results[the_reaction][k]), repr(v))
+                 self.assertAlmostEqual(fva_results[the_reaction][k], v, places=3)
+         ## blocked_reactions = find_blocked_reactions(cobra_model)
+         ## open_ex_blocked = find_blocked_reactions(cobra_model,
+@@ -99,15 +101,16 @@
+     def test_assess_medium_component_essentiality(self):
+         """
+ 
+-        TODO: Add in a numerical value test
++
+         """
+-        essentiality_results = {'EX_ser__L_e': 0.28511251509333996, 'EX_cobalt2_e': 0.0, 'EX_glu__L_e': 0.18551423955187463, 'EX_glyc_e': 0.02162967396132975, 'EX_h_e': 0.18551423955211313, 'EX_mobd_e': 0.0, 'EX_val__L_e': 0.18004717981556367, 'EX_so4_e': 0.1800471798156284, 'EX_co2_e': 0.18004717981574314, 'EX_k_e': 5.048709793414476e-29, 'EX_fe3_e': -3.4331226595218434e-27, 'EX_na1_e': 0.18004717981556367, 'EX_cl_e': 1.7495455763604752e-28, 'EX_leu__L_e': 0.1762785172191746, 'EX_arg__L_e': 0.13025755872698241, 'EX_nh4_e': 0.09432269135782297, 'EX_lys__L_e': 0.43718843672718055, 'EX_ala__L_e': 0.4371884367334397, 'EX_thr__L_e': 0.43718843673877533, 'EX_pi_e': 4.1028325973665373e-13, 'EX_mn2_e': 0.0, 'EX_phe__L_e': 0.380007972274807, 'EX_h2o_e': 0.38000797227380473, 'EX_mg2_e': 0.0, 'EX_his__L_e': 0.38000797227522415, 'EX_o2_e': 0.3428169207281707, 'EX_pro__L_e': 0.271070547843646, 'EX_asp__L_e': 0.38000797227507915, 'EX_gly_e': 0.3800079722747013, 'EX_cys__L_e': 0.3800079722760569, 'EX_cu2_e': 9.244463733058732e-31, 'EX_ca2_e': 0.0, 'EX_tyr__L_e': 0.38000797227331706, 'EX_zn2_e': 0.0, 'EX_met__L_e': 0.38000797227265026, 'EX_ile__L_e': 0.3800079722724871}
++        essentiality_results = {'EX_ser__L_e': 0.28511251509333996, 'EX_cobalt2_e': 0.0,  'EX_glu__L_e': 0.18551423955187463, 'EX_glyc_e': 0.02162967396132975, 'EX_h_e': 0.18551423955211313, 'EX_mobd_e': 0.0, 'EX_val__L_e': 0.18004717981556367, 'EX_so4_e': 0.1800471798156284, 'EX_co2_e': 0.18004717981574314, 'EX_k_e': 5.048709793414476e-29, 'EX_fe3_e': -3.4331226595218434e-27, 'EX_na1_e': 0.18004717981556367, 'EX_cl_e': 1.7495455763604752e-28, 'EX_leu__L_e': 0.1762785172191746, 'EX_arg__L_e': 0.13025755872698241, 'EX_nh4_e': 0.09432269135782297, 'EX_lys__L_e': 0.43718843672718055, 'EX_ala__L_e': 0.4371884367334397, 'EX_thr__L_e': 0.43718843673877533, 'EX_pi_e': 4.1028325973665373e-13, 'EX_mn2_e': 0.0, 'EX_phe__L_e': 0.380007972274807, 'EX_h2o_e': 0.38000797227380473, 'EX_mg2_e': 0.0, 'EX_his__L_e': 0.38000797227522415, 'EX_o2_e': 0.3428169207281707, 'EX_pro__L_e': 0.271070547843646, 'EX_asp__L_e': 0.38000797227507915, 'EX_gly_e': 0.3800079722747013, 'EX_cys__L_e': 0.3800079722760569, 'EX_cu2_e': 9.244463733058732e-31, 'EX_ca2_e': 0.0, 'EX_tyr__L_e': 0.38000797227331706, 'EX_zn2_e': 0.0, 'EX_met__L_e': 0.38000797227265026, 'EX_ile__L_e': 0.3800079722724871}
+         cobra_model = self.model
+-        the_problem='return'
++        
+         from cobra.flux_analysis import assess_medium_component_essentiality
+         essentiality_dict = assess_medium_component_essentiality(cobra_model, None, 'MgM')
+-        for k, v in essentiality_dict.iteritems():
+-            self.assertAlmostEqual(essentiality_results[k], v, places=3)
++        for k, v in essentiality_results.iteritems():
++            #print "%s expected: %s / simulated: %s"%(k, repr(v), repr(essentiality_dict[k]))
++            self.assertAlmostEqual(essentiality_dict[k], v, places=3)
+ 
+ 
+ 
+Index: cobra/test/unit_tests.py
+===================================================================
+--- cobra/test/unit_tests.py	(revision 330)
++++ cobra/test/unit_tests.py	(working copy)
+@@ -1,13 +1,15 @@
++from __future__ import with_statement
+ from unittest import TestCase, TestLoader, TextTestRunner
+-#skipIf is not in python 2.6
++#skipIf is not in python 2.6 / 2.5
+ try:
+     from unittest import skipIf
++    from warnings import catch_warnings
+ except:
+     try:
+         from unittest2 import skipIf
+     except:
+         skipIf = None
+-from warnings import catch_warnings
++
+ import sys
+ from os import unlink
+ sys.path.insert(0, "../..")
+@@ -60,6 +62,10 @@
+         self.assertEqual(len(self.list), 9)
+ 
+     def testAdd(self):
++        from os import name as __name
++        if __name == 'java':
++            print 'cobra.test.unit_tests.testAdd does not yet work with %s'%__name
++            return
+         obj_list = [Object("test%d" % (i)) for i in range(2, 10)]
+         sum = self.list + obj_list
+         self.assertEqual(self.list[0].id, "test1")
+@@ -127,18 +133,19 @@
+             io.write_sbml_model(self.model, test_output_filename)
+             #cleanup the test file
+             unlink(test_output_filename)
+-    
+-    def test_mat_read_write(self):
+-        test_output_filename = "test_mat_write.mat"
+-        io.save_matlab_model(self.model, test_output_filename)
+-        reread = io.load_matlab_model(test_output_filename)
+-        self.assertEqual(len(self.model.reactions), len(reread.reactions))
+-        self.assertEqual(len(self.model.metabolites), len(reread.metabolites))
+-        for i in range(len(self.model.reactions)):
+-            self.assertEqual(len(self.model.reactions[i]._metabolites), \
+-                len(reread.reactions[i]._metabolites))
+-            self.assertEqual(self.model.reactions[i].id, reread.reactions[i].id)
+-        unlink(test_output_filename)
++    from os import name as __name
++    if __name != 'java':
++        def test_mat_read_write(self):
++            test_output_filename = "test_mat_write.mat"
++            io.save_matlab_model(self.model, test_output_filename)
++            reread = io.load_matlab_model(test_output_filename)
++            self.assertEqual(len(self.model.reactions), len(reread.reactions))
++            self.assertEqual(len(self.model.metabolites), len(reread.metabolites))
++            for i in range(len(self.model.reactions)):
++                self.assertEqual(len(self.model.reactions[i]._metabolites), \
++                    len(reread.reactions[i]._metabolites))
++                self.assertEqual(self.model.reactions[i].id, reread.reactions[i].id)
++            unlink(test_output_filename)
+ 
+ # make a test suite to run all of the tests
+ loader = TestLoader()
+Index: cobra/flux_analysis/moma.py
+===================================================================
+--- cobra/flux_analysis/moma.py	(revision 330)
++++ cobra/flux_analysis/moma.py	(working copy)
+@@ -1,9 +1,15 @@
++from __future__ import with_statement
+ #cobra.flux_analysis.moma.py: Runs the minimization of metabolic
+ #adjustment method described in Segre et al 2002 PNAS 99(23): 15112-7
++from os import name as __name
++from sys import modules as __modules
++from warnings import warn
++if __name == 'java':
++    raise Exception("%s is not yet supported on jython"%__modules[__name__])
+ from copy import deepcopy
+ from time import time
+ from math import ceil, floor
+-from numpy import array, zeros, ones, hstack, vstack, matrix, sum
++from numpy import array, hstack, vstack, matrix, sum
+ from scipy.sparse import eye, lil_matrix, dok_matrix
+ from scipy.sparse import hstack as s_hstack
+ from scipy.sparse import vstack as s_vstack
+Index: cobra/flux_analysis/objective.py
+===================================================================
+--- cobra/flux_analysis/objective.py	(revision 330)
++++ cobra/flux_analysis/objective.py	(working copy)
+@@ -3,8 +3,11 @@
+ from ..core.Reaction import Reaction
+ from ..manipulation import initialize_growth_medium
+ import sys
+-if sys.maxsize > 2**32:
+-    from numpy import int64, int32
++if hasattr(sys, 'maxsize') and sys.maxsize > 2**32:
++    try:
++        from numpy import int64, int32
++    except:
++        int32 = int64 = int
+ else:
+     int32 = int
+     int64 = int
+Index: cobra/flux_analysis/double_deletion.py
+===================================================================
+--- cobra/flux_analysis/double_deletion.py	(revision 330)
++++ cobra/flux_analysis/double_deletion.py	(working copy)
+@@ -1,13 +1,27 @@
++from __future__ import with_statement
+ #cobra.flux_analysis.double_deletion.py
+ #runs flux variablity analysis on a Model object.
+ from math import floor,ceil
+-from numpy import vstack,zeros, nan
++from numpy import vstack,zeros
+ from scipy import sparse
+ from copy import deepcopy
+-from .moma import moma
+ from warnings import warn
+-from cPickle import dump
++from os import name as __name
++nan = float('nan')
++from sys import modules as __modules
++from warnings import warn
++if __name == 'java':
++    raise Exception("%s is not yet supported on jython"%__modules[__name__])
++    warn("moma is not supported on %s"%__name)
++    def moma(**kwargs):
++        warn("moma is not supported on %s"%__name)
++else:
++    from .moma import moma    
+ try:
++    from cPickle import dump
++except:
++    from pickle import dump
++try:
+     from cobra.external.ppmap import ppmap
+     __parallel_mode_available = True
+ except:
+@@ -154,7 +168,8 @@
+     """
+     #BUG: Since this might be called from ppmap, the modules need to
+     #be imported.  Modify ppmap to take depfuncs
+-    from numpy import zeros, nan
++    from numpy import zeros
++    nan = float('nan')
+     from cobra.flux_analysis.single_deletion import single_deletion
+     from cobra.manipulation import initialize_growth_medium
+     from cobra.manipulation import delete_model_genes, undelete_model_genes
+Index: cobra/flux_analysis/essentiality.py
+===================================================================
+--- cobra/flux_analysis/essentiality.py	(revision 330)
++++ cobra/flux_analysis/essentiality.py	(working copy)
+@@ -1,28 +1,41 @@
++from __future__ import with_statement
+ #cobra.flux_analysis.essentiality.py
+ #runs flux variablity analysis on a Model object.
++from os import name as __name
+ from warnings import warn
+ from math import floor,ceil
+-from numpy import vstack,zeros
+-from scipy import sparse
+ from copy import deepcopy
+-from cPickle import dump
+ from os import path, mkdir
+ try:
+-    #Allow for parallel simulations if ppmap is available
+-    from cobra.external import ppmap
+-    from double_deletion import double_deletion_parallel
+-    __parallel_mode_available = True
++    from cPickle import dump
+ except:
++    from pickle import dump
++if __name == 'java':
+     __parallel_mode_available = False
+-    from double_deletion import double_deletion
+-from cobra.flux_analysis.moma import moma
++    warn("moma is not supported on %s"%__name)
++    warn("flux_analysis.double_deletion is not supported on %s"%__name)
++    def moma(a, **kwargs):
++        raise Exception("moma is not supported on %s"%__name)
++
++    def double_deletion(a, **kwargs):
++        raise Exception("flux_analysis.double_deletion is not supported on %s"%__name)
++else:
++    try:
++        #Allow for parallel simulations if ppmap is available
++        from cobra.external import ppmap
++        from double_deletion import double_deletion_parallel
++        __parallel_mode_available = True
++    except:
++        __parallel_mode_available = False
++        from double_deletion import double_deletion
++    from cobra.flux_analysis.moma import moma
+ from cobra.flux_analysis.single_deletion import single_deletion
+ from cobra.manipulation import initialize_growth_medium
+ def assess_medium_component_essentiality(cobra_model, the_components=None,
+                                          the_medium=None, solver='glpk',
+                                          the_problem='return',
+                                          the_condition=None, method='fba'):
+-    """Deterimes which components in an in silico medium are essential for growth in the
++    """Determines which components in an in silico medium are essential for growth in the
+     context of the remaining components.
+ 
+     cobra_model: A Model object.
+@@ -53,15 +66,17 @@
+     """
+     warn("assess_medium_component_essentiality needs to be updated to " +\
+          "deal with new style reactions")
+-    from cobra.core.ArrayBasedModel import ArrayBasedModel
++    #from cobra.core.ArrayBasedModel import ArrayBasedModel
+     if method.lower() == 'moma':
+-        wt_model = ArrayBasedModel(cobra_model.copy())
++        wt_model = cobra_model.copy()
++        #wt_model = ArrayBasedModel(cobra_model.copy())
+     if isinstance(cobra_model, tuple):
+         if len(cobra_model) == 3:
+             the_condition = cobra_model[2]
+         the_components = cobra_model[1]
+         cobra_model = cobra_model[0]
+-    cobra_model = ArrayBasedModel(cobra_model.copy())
++    #cobra_model = ArrayBasedModel(cobra_model.copy())
++    cobra_model = cobra_model.copy()
+     if not the_components:
+         if the_medium:
+             if hasattr(the_medium, 'keys') or \
+@@ -76,15 +91,15 @@
+     essentiality_dict = {}
+     for the_component in the_components:
+         component_index = cobra_model.reactions.index(the_component)
+-        tmp_lb = float(cobra_model.lower_bounds[component_index])
+-        cobra_model.reactions[component_index].lower_bound = cobra_model.lower_bounds[component_index] = 0
++        tmp_lb = float(cobra_model.reactions[component_index].lower_bound)
++        cobra_model.reactions[component_index].lower_bound = 0
+         if method.lower() == 'fba':
+             cobra_model.optimize(solver=solver, the_problem=the_problem)
+             objective_value = cobra_model.solution.f
+         elif method.lower() == 'moma':
+            objective_value = moma(wt_model, cobra_model, solver=solver)['objective_value'] 
+         essentiality_dict[the_component] = objective_value
+-        cobra_model.reactions[component_index].lower_bound = cobra_model.lower_bounds[component_index] = tmp_lb
++        cobra_model.reactions[component_index].lower_bound = tmp_lb
+     if the_condition:
+         essentiality_dict['the_condition'] = the_condition
+     return(essentiality_dict)
+Index: cobra/flux_analysis/__init__.py
+===================================================================
+--- cobra/flux_analysis/__init__.py	(revision 330)
++++ cobra/flux_analysis/__init__.py	(working copy)
+@@ -1,19 +1,27 @@
++try:
++    from essentiality import *
++    from variability import *
++    from single_deletion import single_deletion
++except Exception, e:
++    from warnings import warn
++    warn("essentiality is not accessible: %s"%e)
++
+ from os import name as __name
+-from sys import modules as __modules
+ from warnings import warn
+ if __name == 'java':
+-    warn("%s is not yet supported on jython"%__modules[__name__])
+-
++    warn('double_deletion functions and moma are not yet supported on %s'%__name)
+ else:
+-    from ..solvers import *
+-    from essentiality import *
+-    from variability import *
+-    from single_deletion import single_deletion
+-    from double_deletion import double_deletion, double_deletion_parallel
+-del __name, __modules
++    try:
++        from double_deletion import double_deletion, double_deletion_parallel
++    except Exception, e:
++        from warnings import warn
++        warn("double_deletion is not accessible: %s"%e)
+ 
++    
+ 
+ 
+ 
+ 
+ 
++
++
+Index: cobra/flux_analysis/variability.py
+===================================================================
+--- cobra/flux_analysis/variability.py	(revision 330)
++++ cobra/flux_analysis/variability.py	(working copy)
+@@ -1,8 +1,7 @@
++from __future__ import with_statement
+ #cobra.flux_analysis.variablity.py
+ #runs flux variablity analysis on a Model object.
+ from math import floor,ceil
+-from numpy import hstack,zeros
+-from scipy import sparse
+ from copy import deepcopy
+ from ..core.Metabolite import Metabolite
+ try:
+@@ -15,7 +14,10 @@
+     """Provides an interface to call flux_variability_analysis from ppmap
+     
+     """
+-    from cPickle import dump
++    try:
++        from cPickle import dump
++    except:
++        from pickle import dump
+     from .variability import flux_variability_analysis
+     results_dict = {}
+     new_objective = keywords.pop('new_objective')
+@@ -226,7 +228,10 @@
+     
+     """
+     from test import salmonella_pickle
+-    from cPickle import load
++    try:
++        from cPickle import load
++    except:
++        from pickle import load
+     with open(salmonella_pickle) as in_file:
+         cobra_model = load(in_file)
+     fva_out =  flux_variability_analysis(cobra_model,
+Index: cobra/flux_analysis/single_deletion.py
+===================================================================
+--- cobra/flux_analysis/single_deletion.py	(revision 330)
++++ cobra/flux_analysis/single_deletion.py	(working copy)
+@@ -1,11 +1,19 @@
++from __future__ import with_statement
+ #cobra.flux_analysis.single_deletion.py
+ #run single gene or reaction deletions on the model
+-from numpy import nan
++nan = float('nan')
+ from time import time
++from warnings import warn
+ from copy import deepcopy
+ from ..manipulation import initialize_growth_medium
+ from ..manipulation import delete_model_genes, undelete_model_genes
+-from .moma import moma
++from os import name as __name
++if __name == 'java':
++    warn("moma is not supported on %s"%__name)
++    def moma(**kwargs):
++        warn("moma is not supported on %s"%__name)
++else:
++    from .moma import moma    
+ def single_deletion(cobra_model, element_list=None,
+                     method='fba', the_problem='return',
+                     element_type='gene', solver='glpk',
+Index: cobra/__init__.py
+===================================================================
+--- cobra/__init__.py	(revision 330)
++++ cobra/__init__.py	(working copy)
+@@ -6,9 +6,10 @@
+     #"not yet ready for prime time.")
+     import oven.danielhyduke.jython.numpy as numpy
+     import oven.danielhyduke.jython.scipy as scipy
+-    from core import Object, Formula, Metabolite, Gene, Reaction, Model
++    from core import Object, Formula, Metabolite, Gene, Reaction, Model, DictList
+ else:
+-    from core import *
++    #from core import *
++    from core import Object, Formula, Metabolite, Gene, Reaction, Model, DictList
+ del __name
+ __doc__ = """
+ """
+Index: cobra/core/ArrayBasedModel.py
+===================================================================
+--- cobra/core/ArrayBasedModel.py	(revision 330)
++++ cobra/core/ArrayBasedModel.py	(working copy)
+@@ -114,6 +114,7 @@
+ 
+         """
+         Model.add_metabolites(metabolite_list)
++        self.constraint_sense = [x._constraint_sense for x in self.metabolites]
+         if self.S is not None and expand_stoichiometric_matrix:
+             s_expansion = len(self.metabolites) - self.S.shape[0]
+             if s_expansion > 0:
+@@ -210,6 +211,7 @@
+         self.lower_bounds = array(lower_bounds)
+         self.upper_bounds = array(upper_bounds)
+         self.objective_coefficients = array(objective_coefficients)
++
+     def _update_metabolite_vectors(self):
+         """regenerates _b and _constraint_sense
+ 
+@@ -223,10 +225,9 @@
+         [(_b.append(x._bound),
+           _constraint_sense.append(x._constraint_sense))
+          for x in self.metabolites]
+-        self._b = array(_b)
+-        self._constraint_sense = _constraint_sense
++        self.b = array(_b)
++        self.constraint_sense = _constraint_sense
+          
+-
+     def _update_matrices(self, reaction_list=None):
+         """
+         reaction_list: None or a list of cobra.Reaction objects that are in
+Index: cobra/core/__init__.py
+===================================================================
+--- cobra/core/__init__.py	(revision 330)
++++ cobra/core/__init__.py	(working copy)
+@@ -8,6 +8,9 @@
+ from .Model import Model 
+ from os import name as __name
+ if __name != 'java':
+-    from .ArrayBasedModel import ArrayBasedModel 
++    try:
++        from .ArrayBasedModel import ArrayBasedModel 
++    except Exception, e:
++        from warnings import warn
++        warn("ArrayBasedModel is not accessible: %s"%e)
+ 
+-
+Index: cobra/core/Model.py
+===================================================================
+--- cobra/core/Model.py	(revision 330)
++++ cobra/core/Model.py	(working copy)
+@@ -180,8 +180,10 @@
+             self.reactions[reaction_index] = the_reaction
+ 
+     def update(self):
++        """Non functional.  Model.update is moved to ArrayBasedModel.  Please use
++        the to_array_based_model property to create an ArrayBasedModel.
++        
+         """
+-        """
+         raise Exception("Model.update is moved to ArrayBasedModel.  Please use \n"
+                         "the to_array_based_model property to create an ArrayBasedModel.")
+                      
+Index: cobra/core/Reaction.py
+===================================================================
+--- cobra/core/Reaction.py	(revision 330)
++++ cobra/core/Reaction.py	(working copy)
+@@ -2,6 +2,9 @@
+ #######################
+ #BEGIN Class Reaction
+ #
++#Is it better to restrict a Reaction to a single model or
++#should we allow a Reaction to be associated with multiple models?
++#
+ from collections import defaultdict
+ import re
+ from copy import deepcopy
+@@ -62,13 +65,22 @@
+         [x._reaction.add(self) for x in self._metabolites]
+         [x._reaction.add(self) for x in self._genes]
+ 
++    def get_model(self):
++        """Returns the Model object that this Reaction is associated with.
++
++        """
++        return self._model
++        
++
+     def remove_from_model(self, model=None):
+         """Removes the association
+ 
+         model: cobra.Model object.  remove the reaction from this model.
+         
+         """
+-        # why is model being taken in as a parameter?
++        # why is model being taken in as a parameter? This plays
++        #back to the question of allowing a Metabolite to be associated
++        #with multiple Models
+         if model != self._model and model is not None:
+             raise Exception('%s not in %s ergo it cannot be removed. (%s)'%(self,
+                                                                   model,
+@@ -133,6 +145,7 @@
+         new_reaction = deepcopy(self)
+         ## self._model = the_model
+         return new_reaction
++
+     def guided_copy(self, the_model, metabolite_dict, gene_dict=None):
+         """Trying to make a faster copy procedure for cases where large
+         numbers of metabolites might be copied.  Such as when copying reactions.
+@@ -259,7 +272,13 @@
+         return [k for k, v in self._metabolites.items()
+                 if v > 0]
+ 
++    def get_gene(self):
++        """Return a list of reactants for the reaction.
+ 
++        """
++        return self._genes.keys()
++
++
+     def get_coefficient(self, the_metabolite):
+         """Return the stoichiometric coefficient for a metabolite in
+         the reaction.
+Index: cobra/core/Metabolite.py
+===================================================================
+--- cobra/core/Metabolite.py	(revision 330)
++++ cobra/core/Metabolite.py	(working copy)
+@@ -2,6 +2,9 @@
+ #######################
+ #BEGIN Class Metabolite
+ #
++#Is it better to restrict a Metabolite to a single model or
++#should we allow a Metabolite to be associated with multiple models?
++#
+ from copy import deepcopy
+ import re
+ from .Formula import Formula
+@@ -10,7 +13,7 @@
+     """Metabolite is a class for holding information regarding
+     a metabolite in a cobra.Reaction object.
+ 
+-    TODO: Clean up.  Allow for creation of empty metabolite
++        
+     """
+     ## __slots__ = ['id', 'formula', 'name', 'compartment',
+     ##              'charge']
+@@ -18,6 +21,7 @@
+     ##    from cobra.core.Metabolite import Metabolite
+     ##    Object.__setstate__(self, the_dict)
+     ##    [self.__setattr__(k, v) for k, v in the_dict]
++
+     def __init__(self, id=None, formula=None,
+                  name=None, compartment=None):
+         """
+@@ -60,6 +64,7 @@
+         state = Object.__getstate__(self)
+         state['_reaction'] = set()
+         return state
++
+     def parse_composition(self):
+         """Breaks the chemical formula down by element.
+         Useful for making sure Reactions are balanced.'
+@@ -80,6 +85,7 @@
+         """
+         new_metabolite = deepcopy(self)
+         return new_metabolite
++
+     def guided_copy(self, the_model):
+         """Trying to make a faster copy procedure for cases where large
+         numbers of metabolites might be copied.  Such as when copying reactions.
+@@ -91,15 +97,35 @@
+         the_copy._model = the_model
+         the_copy._reaction = set()
+         return(the_copy)
+-    
+-    def remove_from_model(self, model=None):
++
++    def get_model(self):
++        """Returns the Model object that contain this Object
++
++        """
++        return self._model
++
++    def get_reaction(self):
++        """Returns a list of Reactions that contain this Object
++
++        """
++        return list(self._reaction)
++
++    def remove_from_model(self, model=None, method='subtractive'):
+         """Removes the association
+ 
+-        model: :class:`~cobra.core.Model` object.
++        model: None or :class:`~cobra.core.Model` object.
+             Remove the reaction from this model.
++
++        method: 'subtractive' or 'destructive'.  If 'subtractive' then
++        the metabolite is removed from all associated reactions.  If
++        'destructive' then all associated reactions are removed from the Model.
++
++    
+         
+         """
+-        # why is model being taken in as a parameter?
++        # why is model being taken in as a parameter? This plays
++        #back to the question of allowing a Metabolite to be associated
++        #with multiple Models
+         if model != self._model and model is not None:
+             raise Exception('%s not in %s ergo it cannot be removed. (%s)'%(self,
+                                                                   model,
+@@ -107,11 +133,16 @@
+                                                             
+         self._model.metabolites.remove(self)
+         self._model = None
+-        for the_reaction in self._reaction:
+-            the_coefficient = the_reaction._metabolites[self]
+-            the_reaction.subtract_metabolites({self: the_coefficient})
++        if method.lower() == 'subtractive':
++            for the_reaction in self._reaction:
++                the_coefficient = the_reaction._metabolites[self]
++                the_reaction.subtract_metabolites({self: the_coefficient})
++        elif method.lower() == 'destructive':
++            [x.remove_from_model() for x in self._reaction()]
++        else:
++            raise Exception("method for remove_from_model must be 'subtractive' " +\
++                            "or 'destructive'.  You entered: '%s'"%method)
+ 
+-
+ #
+ #END Class Metabolite
+ ########################
+Index: cobra/core/Object.py
+===================================================================
+--- cobra/core/Object.py	(revision 330)
++++ cobra/core/Object.py	(working copy)
+@@ -14,6 +14,7 @@
+         #formatting notes and annotation
+         self.notes = {}
+         self.annotation = {}
++
+     def __getstate__(self):
+         """To prevent excessive replication during deepcopy.
+         """
+@@ -21,6 +22,7 @@
+         if '_model' in state:
+             state['_model'] = None
+         return state
++    
+     def guided_copy(self):
+         """Trying to make a faster copy procedure for cases where large
+         numbers of metabolites might be copied.  Such as when copying reactions.
+@@ -32,6 +34,7 @@
+         [setattr(the_copy, k, v)
+          for k, v in self.__dict__.iteritems()]
+         return(the_copy)
++
+     ## def __setstate__(self, state):
+     ##     self.__dict__.update(state)
+     ## def __getstate__(self):
+@@ -45,6 +48,7 @@
+     #Not the best idea.  This will be removed in the next major
+     #release
+     #
++
+     def __lt__(self, other):
+         if hasattr(other, 'id'):
+             x = self.id < other.id
+Index: cobra/solvers/glpk.py
+===================================================================
+--- cobra/solvers/glpk.py	(revision 330)
++++ cobra/solvers/glpk.py	(working copy)
+@@ -1,84 +0,0 @@
+-"""bindings to the glpk solver through pyglpk"""
+-# because both this module and the library are named glpk
+-from __future__ import absolute_import
+-from glpk import LPX
+-
+-from ..core.Solution import Solution
+-
+-
+-# mappers from cobra representation to glpk
+-variable_kind_dict = {
+-    'continuous': float,
+-    'integer': int}
+-# mappers from glpk representations to cobra
+-status_dict = {
+-    'opt': 'optimal',
+-    'nofeas': 'infeasible',
+-    'unbnd': 'unbounded'}
+-
+-
+-def create_problem(cobra_model, objective_sense="maximize", lp=None):
+-    if lp is None:
+-        lp = LPX()  # Create empty problem instance
+-        lp.name = cobra_model.id
+-        lp.rows.add(len(cobra_model.metabolites))
+-        lp.cols.add(len(cobra_model.reactions))
+-
+-    if objective_sense == 'maximize':
+-        lp.obj.maximize = True
+-    elif objective_sense == 'minimize':
+-        lp.obj.maximize = False
+-    else:
+-        raise ValueError("objective_sense not 'maximize' or 'minimize'")
+-
+-    # create metabolites/constraints as rows
+-    for i, r in enumerate(lp.rows):
+-        metabolite = cobra_model.metabolites[i]
+-        r.name = metabolite.id
+-        b = float(metabolite._bound)
+-        c = metabolite._constraint_sense
+-        # constraint sense is set by changing the bounds
+-        if c == 'E':
+-            r.bounds = (b, b)
+-        elif c == 'L':
+-            r.bounds = (None, b)
+-        elif c == 'G':
+-            r.bounds = (b, None)
+-        else:
+-            raise ValueError("%s is not a valid constraint_sense" % c)
+-
+-    # create reactions/variables as columns
+-    for i, c in enumerate(lp.cols):
+-        reaction = cobra_model.reactions[i]
+-        c.name = reaction.id
+-        c.kind = variable_kind_dict[reaction.variable_kind]
+-        c.bounds = (reaction.lower_bound, reaction.upper_bound)
+-        lp.obj[i] = float(reaction.objective_coefficient)
+-
+-    # create S matrix
+-    lp.matrix = [(int(i), int(j), c) \
+-        for (i, j), c in cobra_model.to_array_based_model().S.todok().iteritems()]
+-    return lp
+-
+-
+-def solve_problem(lp):
+-    lp.simplex()
+-    try:
+-        status = status_dict[lp.status]
+-    except:
+-        status = "unknown error: " + str(lp.status)
+-    solution = Solution(status)
+-    solution.status = status
+-    if status == 'optimal':
+-        solution.objective_value = lp.obj.value
+-        solution.x_dict = dict((c.name, c.primal) for c in lp.cols)
+-        # return the duals as well as the primals for LPs
+-        if lp.kind == "float":
+-            solution.y_dict = dict((c.name, c.dual) for c in lp.cols)
+-        else:
+-            solution.y_dict = None
+-    return solution
+-
+-
+-def solve(cobra_model, objective_sense="maximize", **kwargs):
+-    return solve_problem(create_problem(cobra_model, objective_sense))
+Index: cobra/solvers/__init__.py
+===================================================================
+--- cobra/solvers/__init__.py	(revision 330)
++++ cobra/solvers/__init__.py	(working copy)
+@@ -2,104 +2,101 @@
+ from os import name as __name
+ from sys import modules as __modules
+ from warnings import warn
+-if __name == 'java':
+-    #warn("%s is not yet supported on jython"%__modules[__name__])
+-    def optimize():
+-        print "No solvers for jython yet"
+-else:
+-    __legacy_solver = True
+-    solver_dict = {}
+-    if __legacy_solver:
+-        from .legacy import _optimize_glpk, _optimize_gurobi, _optimize_cplex
+-        solver_dict = {'glpk': _optimize_glpk,
+-                       'gurobi': _optimize_gurobi,
+-                       'cplex': _optimize_cplex}
+-        for solver_module in ['glpk', 'cplex']:
+-            try:
+-                exec('from %s import *'%solver_module)
+-            except:
+-                solver_dict.pop(solver_module)
+-        try:
+-            from gurobipy import *
+-        except:
+-            solver_dict.pop('gurobi')
+ 
++__legacy_solver = False
++solver_dict = {}
++if __legacy_solver:
++    from .legacy import _optimize_glpk, _optimize_gurobi, _optimize_cplex
++    package_dict = {'glpk': 'from glpk import LPX',
++                    'cplex': 'from cplex import Cplex',
++                    'gurobi': 'from gurobipy import Model'}
++    if __name == 'java':
++        from .legacy_jython import _optimize_glpk
++        package_dict['glpk'] = 'from org.gnu.glpk import GLPK'
++        package_dict['gurobi'] = 'from gurobi import GRBModel'
+ 
+-    else:
+-        from os import listdir as _listdir
+-        from os import path as _path
+-        for i in _listdir(_path.split(_path.abspath(__file__))[0]):
+-            if i.startswith("_") or i.startswith("."):
+-                continue
+-            if not i.endswith(".py"):
+-                continue
+-            try:
+-                m = i.strip(".py")
+-                exec("from . import %s" % m)
+-                solver_dict[m] = eval(m)
+-            except Exception, e:
+-                pass
+-        del _path
+-        del _listdir
+-        del i
+-        m = None
+-        del m
+ 
+-    def optimize(cobra_model, solver='glpk', error_reporting=False, **kwargs):
+-        """Wrapper to optimization solvers
++    solver_dict = {'glpk': _optimize_glpk,
++                   'gurobi': _optimize_gurobi,
++                   'cplex': _optimize_cplex}
+ 
++    for solver_name, solver_import in package_dict.iteritems():
++        try:
++            exec(solver_import)
++        except Exception, e:
++            #print e
++            solver_dict.pop(solver_name)
++else:
++    from os import listdir as _listdir
++    from os import path as _path
++    for i in _listdir(_path.split(_path.abspath(__file__))[0]):
++        if i.startswith("_") or i.startswith(".") or i == 'legacy.py':
++            continue
++        if not i.endswith(".py"):
++            continue
++        try:
++            m = i.strip(".py")
++            exec("from . import %s" % m)
++            solver_name = m
++            if solver_name.endswith('_solver'):
++                solver_name = solver_name[:-len('_solver')]
++            solver_dict[solver_name] = eval(m)
++        except Exception, e:
++            pass
++    del _path
++    del _listdir
++    del i
++    m = None
++    del m
+ 
+-        """
+-        #If the default solver is not installed then use one of the others
++def optimize(cobra_model, solver='glpk', error_reporting=True, **kwargs):
++    """Wrapper to optimization solvers
++
++
++    """
++    #If the default solver is not installed then use one of the others
++    try:
++        solver_function = solver_dict[solver]
++    except:
+         try:
+-            solver_function = solver_dict[solver]
++            solver, solver_function = solver_dict.items()[0]
+         except:
+-            try:
+-                solver, solver_function = solver_dict.items()[0]
+-            except:
+-                raise Exception("It appears that you do not have one of the supported solvers "+\
+-                                "(glpk, gurobi, or cplex) installed")
+-        the_solution = None
+-        if __legacy_solver:
+-            def solve_problem(solver_function, kwargs):
+-                return solver_function(cobra_model, **kwargs)
+-            try:
+-                the_solution = solve_problem(solver_function, kwargs)
+-            except Exception, e:
+-                if error_reporting:
+-                    print e
+-                    print '%s did not work'%solver
+-                solver_keys = solver_dict.keys()
+-                solver_keys.remove(solver)
+-                for solver in solver_keys:
+-                    solver_function = solver_dict[solver]
+-                    try:
+-                        if error_reporting:
+-                            print "now trying %s"%solver
+-                        the_solution = solve_problem(solver_function, kwargs)
+-                        break
+-                    except Exception, e:
+-                        if error_reporting:
+-                            print e
+-                            print '%s did not work'%solver
+-                        continue
++            raise Exception("It appears that you do not have one of the supported solvers "+\
++                            "(glpk, gurobi, or cplex) installed")
++    the_solution = None
++    if __legacy_solver:
++        def solve_problem(solver_function, kwargs):
++            return solver_function(cobra_model, **kwargs)
++        try:
++            the_solution = solve_problem(solver_function, kwargs)
++        except Exception, e:
++            if error_reporting:
++                print e
++                print '%s did not work'%solver
++            solver_keys = solver_dict.keys()
++            solver_keys.remove(solver)
++            for solver in solver_keys:
++                solver_function = solver_dict[solver]
++                try:
++                    if error_reporting:
++                        print "now trying %s"%solver
++                    the_solution = solve_problem(solver_function, kwargs)
++                    break
++                except Exception, e:
++                    if error_reporting:
++                        print e
++                        print '%s did not work'%solver
++                    continue
+ 
+-        else:
+-            the_solution = solver_function.solve(cobra_model, **kwargs)
+-            #raise Exception("New style solvers not yet fully implemented")
++    else:
++        the_solution = solver_function.solve(cobra_model, **kwargs)
++        #raise Exception("New style solvers not yet fully implemented")
+ 
+ 
+-        #Add the solution to the model.
+-        #Please note that it will be faster to dress the reactions and metabolites
+-        #with their values within the new style solvers instead of here.
+-        if the_solution is None:
+-            cobra_model.solution = the_solution
+-            return(the_solution)
+-        else:
+-            if __legacy_solver:
+-                cobra_model.solution = the_solution['the_solution']
+-                return(the_solution['the_problem'])
+-            else:
+-                cobra_model.solution = the_solution
++    #Add the solution to the model.
++    #if the_solution is None:
++    #   return(the_solution)
++    #else:
++    return(the_solution['the_problem'])
+ 
+-del __name, __modules
++del __name
+Index: cobra/solvers/gurobi_solver.py
+===================================================================
+--- cobra/solvers/gurobi_solver.py	(revision 0)
++++ cobra/solvers/gurobi_solver.py	(revision 0)
+@@ -0,0 +1,306 @@
++##cobra.solvers.gurobi_solver
++#Interface to the gurobi 5.0.1 python and java solvers
++#QPs are not yet supported on java
++from __future__ import absolute_import
++from warnings import warn
++from os import name as __name
++from copy import deepcopy
++###solver specific parameters
++from .parameters import status_dict, variable_kind_dict, \
++     sense_dict, parameter_mappings, parameter_defaults, \
++     objective_senses, default_objective_sense
++
++from ..core.Solution import Solution
++from ..flux_analysis.objective import update_objective
++from time import time
++solver_name = 'gurobi'
++objective_senses = objective_senses[solver_name]
++parameter_mappings = parameter_mappings[solver_name]
++parameter_defaults = parameter_defaults[solver_name]
++#Functions that are different for java implementation of a solver
++if __name == 'java':
++    ## from jarray import array as j_array
++    ## def array(x, variable_type='d'):
++    ##     return j_array(x, variable_type)
++
++    from gurobi import GRB
++    variable_kind_dict = eval(variable_kind_dict[solver_name])
++    status_dict = eval(status_dict[solver_name])
++
++    from gurobi import GRBModel, GRBEnv
++    from gurobi import GRBLinExpr
++    from gurobi import GRBQuadExpr as QuadExpr
++    __solver_class = GRBModel
++    #TODO: Create a pythonesqe class similar to in glpk_solver
++    def Model(name=''):
++        grb_environment = GRBEnv(name)
++        tmp_model = GRBModel(grb_environment)
++        return tmp_model
++    def LinExpr(coefficients, variables):
++        coefficients, variables = map(list, [coefficients, variables])
++        tmp_expression = GRBLinExpr()
++        tmp_expression.addTerms(coefficients, variables)
++        return tmp_expression
++
++    def get_status(lp):
++        status = lp.get(GRB.IntAttr.Status)
++        if status in status_dict:
++            status = status_dict[status]
++        else:
++            status = 'failed'
++        return status
++
++    def set_parameter(lp, parameter_name, parameter_value):
++        """Sets model parameters and attributes.
++        
++        """
++        grb_environment = lp.getEnv()
++        try:
++            if hasattr(GRB.DoubleParam, parameter_name):
++                grb_environment.set(eval('GRB.DoubleParam.%s'%parameter_name),
++                                         parameter_value)
++            elif hasattr(GRB.IntParam, parameter_name):
++                grb_environment.set(eval('GRB.IntParam.%s'%parameter_name),
++                                         parameter_value)
++            elif hasattr(GRB.StringParam, parameter_name):
++                grb_environment.set(eval('GRB.StringParam.%s'%parameter_name),
++                                    parameter_value)
++            elif hasattr(GRB.IntAttr, parameter_name):
++                if parameter_name == 'ModelSense':
++                    parameter_value = objective_senses[parameter_value]
++                lp.set(eval('GRB.IntAttr.%s'%parameter_name),
++                                    parameter_value)
++            else:
++                warn("%s is not a DoubleParam, IntParam, StringParam, IntAttr"%parameter_name)
++                ## raise Exception("%s is not a DoubleParam, IntParam, StringParam, IntAttr"%parameter_name)
++        except Exception, e:
++            warn("%s %s didn't work %s"%(parameter_name, parameter_value, e))
++
++    def format_solution(lp, cobra_model, **kwargs):
++        """
++        """
++        status = get_status(lp)
++        if status != 'optimal':
++            the_solution = Solution(None, status=status)
++        else:
++            x_dict = dict(((v.get(GRB.StringAttr.VarName),
++                            v.get(GRB.DoubleAttr.X))
++                           for v in lp.getVars()))
++            x = [x_dict[v.id] for v in cobra_model.reactions]
++            objective_value = lp.get(GRB.DoubleAttr.ObjVal)
++            if lp.get(GRB.IntAttr.IsMIP) != 0:
++                y = y_dict = None #MIP's don't have duals
++            else:
++                y_dict = dict(((c.get(GRB.StringAttr.ConstrName), c.get(GRB.DoubleAttr.Pi))
++                              for c in lp.getConstrs()))
++                y = list([y_dict[v.id] for v in cobra_model.metabolites])
++            the_solution = Solution(objective_value, x=x, x_dict=x_dict, y=y,
++                                    y_dict=y_dict, status=status)
++        return(the_solution)
++
++else:
++    ## from numpy import array
++    from gurobipy import Model, LinExpr, GRB, QuadExpr
++    variable_kind_dict = eval(variable_kind_dict[solver_name])
++    status_dict = eval(status_dict[solver_name])
++    __solver_class = Model
++    def get_status(lp):
++        status = lp.status
++        if status in status_dict:
++            status = status_dict[status]
++        else:
++            status = 'failed'
++        return status
++
++    def format_solution(lp, cobra_model, **kwargs):
++        status = get_status(lp)
++        if status != 'optimal':
++            the_solution = Solution(None, status=status)
++        else:
++            objective_value = lp.ObjVal            
++            x_dict = dict(((v.VarName, v.X)
++                           for v in lp.getVars()))
++            x = [x_dict[v.id] for v in cobra_model.reactions]
++            if lp.isMIP:
++                y = y_dict = None #MIP's don't have duals
++            else:
++                y_dict = dict(((c.ConstrName, c.Pi)
++                              for c in lp.getConstrs()))
++                y = list([y_dict[v.id] for v in cobra_model.metabolites])
++            the_solution = Solution(objective_value, x=x, x_dict=x_dict, y=y,
++                                    y_dict=y_dict, status=status)
++        return(the_solution)
++
++    def set_parameter(lp, parameter_name, parameter_value):
++        if parameter_name == 'ModelSense':
++            lp.setAttr(parameter_name, objective_senses[parameter_value])
++        else:
++            lp.setParam(parameter_name, parameter_value)
++
++
++
++
++###
++sense_dict = eval(sense_dict[solver_name])
++def create_problem(cobra_model,  **kwargs):
++    """Solver-specific method for constructing a solver problem from
++    a cobra.Model.  This can be tuned for performance using kwargs
++
++
++    """
++    lp = Model("")
++    #Silence the solver
++    set_parameter(lp, 'OutputFlag', 0)
++
++    the_parameters = parameter_defaults
++    if kwargs:
++        the_parameters = deepcopy(parameter_defaults)
++        the_parameters.update(kwargs)
++
++    [set_parameter(lp, parameter_mappings[k], v)
++         for k, v in the_parameters.iteritems() if k in parameter_mappings]
++    quadratic_component = the_parameters['quadratic_component']
++    objective_sense = objective_senses[the_parameters['objective_sense']]
++
++
++    # Create variables
++    #TODO:  Speed this up
++    variable_list = [lp.addVar(float(x.lower_bound),
++                               float(x.upper_bound),
++                               float(x.objective_coefficient),
++                               variable_kind_dict[x.variable_kind],
++                               x.id)
++                     for x in cobra_model.reactions]
++    reaction_to_variable = dict(zip(cobra_model.reactions,
++                                    variable_list))
++    # Integrate new variables
++    lp.update()
++    #Set objective to quadratic program
++    if quadratic_component is not None:
++        if not hasattr(quadratic_component, 'todok'):
++            raise Exception('quadratic component must have method todok')
++
++        quadratic_objective = QuadExpr()
++        for (index_0, index_1), the_value in quadratic_component.todok().items():
++            quadratic_objective.addTerms(the_value,
++                                   variable_list[index_0],
++                                   variable_list[index_1])
++        #Does this override the linear objective coefficients or integrate with them?
++        lp.setObjective(quadratic_objective, sense=objective_sense)
++    #Constraints are based on mass balance
++    #Construct the lin expression lists and then add
++    #TODO: Speed this up as it takes about .18 seconds
++    #HERE
++    for the_metabolite in cobra_model.metabolites:
++        constraint_coefficients = []
++        constraint_variables = []
++        for the_reaction in the_metabolite._reaction:
++            constraint_coefficients.append(the_reaction._metabolites[the_metabolite])
++            constraint_variables.append(reaction_to_variable[the_reaction])
++        #Add the metabolite to the problem
++        lp.addConstr(LinExpr(constraint_coefficients, constraint_variables),
++                     sense_dict[the_metabolite._constraint_sense.upper()],
++                     the_metabolite._bound,
++                     the_metabolite.id)
++
++
++
++    return(lp)
++###
++def update_problem(lp, cobra_model, **kwargs):
++    """A performance tunable method for updating a model problem file
++
++    lp: A gurobi problem object
++
++    cobra_model: the cobra.Model corresponding to 'lp'
++
++    """
++    #When reusing the basis only assume that the objective coefficients or bounds can change
++    try:
++        quadratic_component = kwargs['quadratic_component']
++        if quadratic_component is not None:
++            warn("update_problem does not yet take quadratic_component as a parameter")
++    except:
++        quadratic_component = None
++ 
++    if 'copy_problem' in kwargs and kwargs['copy_problem']:
++        lp = lp.copy()
++    if 'reuse_basis' in kwargs and not kwargs['reuse_basis']:
++        lp.reset()
++    for the_variable, the_reaction in zip(lp.getVars(),
++                                          cobra_model.reactions):
++        the_variable.lb = float(the_reaction.lower_bound)
++        the_variable.ub = float(the_reaction.upper_bound)
++        the_variable.obj = float(the_reaction.objective_coefficient)
++
++###
++def solve_problem(lp, **kwargs):
++    """A performance tunable method for updating a model problem file
++
++    """
++    #Update parameter settings if provided
++    if kwargs:
++        [set_parameter(lp, parameter_mappings[k], v)
++         for k, v in kwargs.iteritems() if k in parameter_mappings]
++
++    try:
++        print_solver_time = kwargs['print_solver_time']
++        start_time = time()
++    except:
++        print_solver_time = False
++    lp.update()
++    #Different methods to try if lp_method fails
++    the_methods = [0, 2, 1]
++    lp.optimize()
++    status = get_status(lp)
++    if status != 'optimal':
++        #Try to find a solution using a different method
++        set_parameter(lp, parameter_mappings['tolerance_markowitz'], 1e-2)
++        for the_method in the_methods:
++            set_parameter(lp, parameter_mappings['lp_method'], the_method)
++            lp.optimize()
++            status = get_status(lp)
++            if status == 'optimal':
++                break
++
++    if print_solver_time:
++        print 'optimize time: %f'%(time() - start_time)
++    return status
++
++    
++def solve(cobra_model, **kwargs):
++    """
++
++    """
++        #Update objectives if they are new.
++    if 'new_objective' in kwargs and \
++           kwargs['new_objective'] not in ['update problem', None]:
++       update_objective(cobra_model, kwargs['new_objective'])
++
++    if 'the_problem' in kwargs:
++        the_problem = kwargs['the_problem']
++    else:
++        the_problem = None
++    if 'error_reporting' in kwargs:
++        error_reporting = kwargs['error_reporting']
++    else:
++        error_reporting = False
++
++    if isinstance(the_problem, __solver_class):
++        #Update the problem with the current cobra_model
++        lp = the_problem
++        update_problem(lp, cobra_model, **kwargs)
++    else:
++        #Create a new problem
++        lp = create_problem(cobra_model, **kwargs)
++    #Deprecated way for returning a solver problem created from a cobra_model
++    #without performing optimization
++    if the_problem == 'setup':
++            return lp
++    status = solve_problem(lp)
++    the_solution = format_solution(lp, cobra_model)
++    if status != 'optimal' and error_reporting:
++        print '%s failed: %s'%(solver_name, status)
++    cobra_model.solution = the_solution
++    solution = {'the_problem': lp, 'the_solution': the_solution}
++    return solution
+Index: cobra/solvers/parameters.py
+===================================================================
+--- cobra/solvers/parameters.py	(revision 0)
++++ cobra/solvers/parameters.py	(revision 0)
+@@ -0,0 +1,125 @@
++#This centralizes some of the common elements that are differently named across solvers.
++#These are stored as strings here to prevent problems associated with calling
++#solver objects for solver packages that aren't available
++from copy import deepcopy
++__objective_sense_cplex = {'maximize': 'Cplex.objective.sense.maximize',
++                           'minimize': 'Cplex.objective.sense.maximize'}
++__objective_sense_glpk = {'maximize': True,
++                          'minimize': False}
++__objective_sense_glpk_java = {'maximize': 'GLPKConstants.GLP_MAX',
++                               'minimize': 'GLPKConstants.GLP_MIN'}
++__objective_sense_gurobi = {'maximize': -1,
++                            'minimize': 1}
++objective_senses = {'cplex': __objective_sense_cplex,
++                    'glpk': __objective_sense_glpk,
++                    'glpk_java': __objective_sense_glpk_java,
++                    'gurobi': __objective_sense_gurobi}
++default_objective_sense = 'maximize'
++#Mappings from solver-specific status values to cobra pie status values
++## __status_cplex = "{Cplex.solution.status.MIP_infeasible: 'infeasible', " +\
++##                  "Cplex.solution.status.MIP_optimal: 'optimal', " +\
++##                  "Cplex.solution.status.MIP_optimal_tolerance: 'optimal'," +\
++##                  "Cplex.solution.status.MIP_unbounded:  'unbounded', "+\
++##                  "Cplex.solution.status.infeasible: 'infeasible', " +\
++##                  "Cplex.solution.status.optimal: 'optimal',  " +\
++##                  "Cplex.solution.status.optimal_tolerance: 'optimal', " +\
++##                  "Cplex.solution.status.unbounded: 'unbounded', }"
++__status_cplex = "{'MIP_infeasible': 'infeasible', 'integer optimal solution': 'optimal', " +\
++                  "'MIP_optimal_tolerance': 'optimal',  'MIP_unbounded':  'unbounded', "+\
++                  "'infeasible': 'infeasible', 'optimal': 'optimal',  " +\
++                  "'optimal_tolerance': 'optimal', 'unbounded': 'unbounded' }"
++
++__status_glpk = "{'opt': 'optimal', 'nofeas': 'infeasible', 'unbnd': 'unbounded'}"
++__status_glpk_java = "{GLPKConstants.GLP_OPT: 'optimal', GLPKConstants.GLP_FEAS: 'feasible', GLPKConstants.GLP_INFEAS: 'infeasible', GLPKConstants.GLP_NOFEAS: 'infeasible', GLPKConstants.GLP_UNBND: 'unbounded', GLPKConstants.GLP_UNDEF: 'undefined'}"
++__status_gurobi = "{GRB.OPTIMAL: 'optimal', GRB.INFEASIBLE: 'infeasible', GRB.UNBOUNDED: 'unbounded'}"
++
++status_dict = {'cplex': __status_cplex,
++               'glpk': __status_glpk,
++               'glpk_java': __status_glpk_java,
++               'gurobi': __status_gurobi}
++
++#Mappings from solver-specific variable kinds to cobra pie
++__kind_cplex = "{'continuous': Cplex.variables.type.continuous, 'integer': Cplex.variables.type.integer}"
++__kind_cplex_java = "{'continuous':  IloNumVarType.Float, 'integer': IloNumVarType.Int}"
++__kind_glpk = "{'continuous': float, 'integer': int}"
++__kind_glpk_java = "{'binary': GLPKConstants.GLP_BV, 'continuous': GLPKConstants.GLP_CV, 'integer': GLPKConstants.GLP_IV}"
++__kind_gurobi = "{'continuous': GRB.CONTINUOUS, 'integer': GRB.INTEGER}"
++
++variable_kind_dict = {'cplex': __kind_cplex,
++                      'cplex_java': __kind_cplex_java,
++                      'glpk': __kind_glpk,
++                      'glpk_java': __kind_glpk_java, 
++                      'gurobi': __kind_gurobi}
++
++#Mappings from solver-specific constraint senses to cobra pie
++sense_dict = {'cplex': "{'E': 'E', 'L': 'L', 'G': 'G'}",
++              'glpk': "{'E': 'E', 'L': 'L', 'G': 'G'}",
++              'gurobi': "{'E': GRB.EQUAL, 'L': GRB.LESS_EQUAL, 'G': GRB.GREATER_EQUAL}"}
++
++
++#Mappings from cobra pie parameters names to solver specific parameter names
++__mappings_cplex = {'lp_method': 'parameters.lpmethod.set',
++                    'lp_parallel': 'parameters.threads.set',
++                    'objective_sense': 'objective.set_sense',
++                    'time_limit': 'parameters.timelimit.set',
++                    'tolerance_barrier': 'parameters.barrier.convergetol.set',
++                    'tolerance_feasibility': 'parameters.simplex.tolerances.feasibility.set',
++                    'tolerance_markowitz': 'parameters.simplex.tolerances.markowitz.set',
++                    'tolerance_optimality': 'parameters.simplex.tolerances.optimality.set'}
++__mappings_cplex_java = {'lp_method': 'RootAlg'}
++__mappings_glpk = {}
++__mappings_glpk_java = {'objective_sense': 'objective_sense',
++                        'lp_method': 'meth',
++                        'output_verbosity': 'msg_lev',
++                        'tolerance_dual': 'tol_dj',
++                        'tolerance_integer': 'tol_int',
++                        'tolerance_optimality': 'tol_bnd'
++                        }
++__mappings_gurobi = {'log_file': 'LogFile',
++                     'lp_method': 'Method',
++                     'objective_sense': 'ModelSense',
++                     'output_verbosity': 'OutputFlag',
++                     'quadratic_precision': 'Quad',
++                     'time_limit': 'TimeLimit',
++                     'tolerance_feasibility': 'FeasibilityTol',
++                     'tolerance_markowitz': 'MarkowitzTol',
++                     'tolerance_optimality': 'OptimalityTol' }
++parameter_mappings = {'cplex': __mappings_cplex,
++                      'cplex_java': __mappings_cplex_java,
++                      'glpk': __mappings_glpk,
++                      'glpk_java': __mappings_glpk_java,
++                      'gurobi': __mappings_gurobi}
++
++
++#Default solver parameters
++__common_defaults = {'new_objective': None, 'objective_sense': 'maximize',
++                      'min_norm': 0, 'the_problem': None, 
++                      'tolerance_optimality': 1e-6, 'tolerance_feasibility': 1e-6,
++                      'tolerance_integer': 1e-9, 
++                      'error_reporting': None, 'print_solver_time': False,
++                      'quadratic_component': None}
++                      
++
++
++__parameters_cplex = deepcopy(__common_defaults)
++__parameters_cplex.update({'lp_method': 1,
++                           'lp_parallel': 0,
++                           'tolerance_barrier': 1e-8,
++                           'update_problem_reaction_bounds': True})
++__parameters_glpk = deepcopy(__common_defaults)
++__parameters_glpk.update({'lp_method': 1})
++__parameters_glpk_java = deepcopy(__common_defaults)
++__parameters_glpk_java.update({'lp_method': 1,
++                               'output_verbosity': 0,
++                               'tolerance_dual': 1e-8})
++__parameters_gurobi = deepcopy(__common_defaults)
++__parameters_gurobi.update({'output_verbosity': 0,
++                          'lp_method': 0,
++                          'log_file': '',
++                          'tolerance_barrier': 1e-8})
++
++
++parameter_defaults = {'cplex': __parameters_cplex,
++                      'glpk': __parameters_glpk,
++                      'glpk_java': __parameters_glpk_java,
++                      'gurobi': __parameters_gurobi}
+Index: cobra/solvers/legacy.py
+===================================================================
+--- cobra/solvers/legacy.py	(revision 330)
++++ cobra/solvers/legacy.py	(working copy)
+@@ -309,8 +309,6 @@
+ 
+     if print_solver_time:
+         print 'cplex time: %f'%(time() - start_time)
+-    x = []
+-    x_dict = {}
+     #TODO: It might be able to speed this up a little.
+     if status == 'optimal':
+         objective_value = lp.solution.get_objective_value()
+@@ -334,7 +332,7 @@
+         if error_reporting:
+             print 'cplex failed: %s'%lp.status
+ 
+-    the_solution = Solution(objective_value, x=x, x_dict=x_dict,
++    cobra_model.solution = the_solution = Solution(objective_value, x=x, x_dict=x_dict,
+                             status=status, y=y, y_dict=y_dict)
+     solution = {'the_problem': lp, 'the_solution': the_solution}
+     return solution    
+@@ -565,7 +563,7 @@
+         objective_value = None
+         if error_reporting:
+             print 'gurobi failed: %s'%lp.status  
+-    the_solution = Solution(objective_value, x=x, x_dict=x_dict,
++    cobra_model.solution = the_solution = Solution(objective_value, x=x, x_dict=x_dict,
+                             y=y, y_dict=y_dict,
+                             status=status)
+     solution = {'the_problem': lp, 'the_solution': the_solution}
+@@ -810,7 +808,7 @@
+         x = y = x_dict = y_dict = objective_value = None
+         if error_reporting:
+             print 'glpk failed: %s'%lp.status
+-    the_solution = Solution(objective_value, x=x, x_dict=x_dict,
++    cobra_model.solution = the_solution = Solution(objective_value, x=x, x_dict=x_dict,
+                             y=y, y_dict=y_dict,
+                             status=status)
+     solution = {'the_problem': lp, 'the_solution': the_solution}
+Index: cobra/solvers/cplex_solver.py
+===================================================================
+--- cobra/solvers/cplex_solver.py	(revision 0)
++++ cobra/solvers/cplex_solver.py	(revision 0)
+@@ -0,0 +1,491 @@
++#cobra.solvers.cplex_solver
++#Interface to ilog/cplex 12.4 python / jython interfaces
++#QPs are not yet supported under jython
++from __future__ import absolute_import
++from pdb import set_trace
++from os import name as __name
++from copy import deepcopy
++from warnings import warn
++###solver specific parameters
++from cobra.solvers.parameters import status_dict, variable_kind_dict, \
++     sense_dict, parameter_mappings, parameter_defaults, \
++     objective_senses, default_objective_sense
++
++from cobra.core.Solution import Solution
++from cobra.flux_analysis.objective import update_objective
++from time import time
++solver_name = 'cplex'
++parameter_defaults = parameter_defaults[solver_name]
++sense_dict = eval(sense_dict[solver_name])
++
++#Functions that are different for java implementation of a solver
++if __name == 'java':
++    from ilog.cplex import IloCplex
++    from ilog.cplex.IloCplex import DoubleParam, IntParam, StringParam
++    from ilog.concert import IloNumVarType 
++    #__solver_class = IloCplex
++    status_dict = eval(status_dict[solver_name])
++    class Problem(IloCplex):
++        def __init__(self):
++            IloCplex.__init__(self)
++            self._lp_matrix = self.addLPMatrix()
++            self.objective_value = None
++        def add_linear_expression(self, linear_expression, metabolite):
++            b = metabolite._bound
++            c = metabolite._constraint_sense
++            the_id = metabolite.id
++            if c == 'E':
++                p = self.addEq(linear_expression, b, the_id)
++            elif c == 'L':
++                p = self.addLe(linear_expression, b, the_id)
++            elif c == 'G':
++                p = self.addGe(linear_expression, b, the_id)
++            else:
++                raise Exception("Constraint sense '%s' for metabolite %s is not valid"%(c,
++                                                                                        the_id))
++            return(p)
++
++    __solver_class = Problem
++    parameter_mappings = parameter_mappings['%s_%s'%(solver_name,
++                                                     __name)]
++    variable_kind_dict = eval(variable_kind_dict['%s_%s'%(solver_name,
++                                                          __name)])
++    objective_senses = objective_senses[solver_name]
++    ## from jarray import array as j_array
++    ## def array(x, variable_type='d'):
++    ##     return j_array(x, variable_type)
++
++
++    def get_status(lp):
++        status = repr(lp.status).lower()
++        if status in status_dict:
++            status = status_dict[status]
++        else:
++            status = 'failed'
++        return status
++
++    def set_parameter(lp, parameter_name, parameter_value):
++        if hasattr(DoubleParam, parameter_name):
++            parameter_type = 'DoubleParam'
++        elif hasattr(IntParam, parameter_name):
++            parameter_type = 'IntParam'
++        elif hasattr(StringParam, parameter_name):
++            parameter_type = 'StringParam'
++        else:
++            raise Exception("%s is not a DoubleParam, IntParam, or StringParam"%parameter_name)
++        lp.setParam(eval('%s.%s'%(parameter_type, parameter_name)),
++                    parameter_value)
++
++    def format_solution(lp, cobra_model, **kwargs):
++        """
++        TODO
++        """
++        status = get_status(lp)
++        try:
++            x = lp.getValues(lp.variables)
++            x_dict = dict(zip(cobra_model.reactions, x))
++            objective_value = lp.getObjValue()
++        except:
++            x = x_dict = objective_value = None
++            #print status
++
++        try:
++            y = lp.getDuals(lp.variables)
++            y_dict = dict(zip(cobra_model.metabolites, y))
++        except:
++            y = y_dict = None
++        return(Solution(objective_value, x=x, x_dict=x_dict, y=y,
++                        y_dict=y_dict, status=status))
++
++    def create_problem(cobra_model,  **kwargs):
++        """Solver-specific method for constructing a solver problem from
++        a cobra.Model.  This can be tuned for performance using kwargs
++
++        TODO: This will need to be specific for python / jython
++        """
++        the_parameters = parameter_defaults
++        if kwargs:
++            the_parameters = deepcopy(parameter_defaults)
++            the_parameters.update(kwargs)
++
++        lp = Problem()
++
++        if 'log_file' not in the_parameters:
++            lp.setWarning(None)
++            lp.setOut(None)
++        [set_parameter(lp, parameter_mappings[k], v)
++         for k, v in the_parameters.iteritems() if k in parameter_mappings]
++        quadratic_component = the_parameters['quadratic_component']
++        new_objective = the_parameters['new_objective']
++        error_reporting = the_parameters['error_reporting']
++        objective_sense = the_parameters['objective_sense']
++        if 'relax_b' in the_parameters:
++            warn('need to reimplement relax_b')
++            relax_b = False
++        else:
++            relax_b = False
++
++        #Using the new objects
++        #NOTE: This might be slow
++        objective_coefficients = []
++        lower_bounds = []
++        upper_bounds = []
++        variable_names = []
++        variable_kinds = []
++        [(objective_coefficients.append(x.objective_coefficient),
++          lower_bounds.append(x.lower_bound),
++          upper_bounds.append(x.upper_bound),
++          variable_names.append(x.id),
++          variable_kinds.append(variable_kind_dict[x.variable_kind]))
++         for x in cobra_model.reactions]
++
++        #Only add the variable types if one or more variables is an integer, just
++        #in case the java interface has the same bug as the python interface where
++        #the problem type switches to integer if variable types are supplied even
++        #if all are continuous
++        if variable_kind_dict['integer'] in variable_kinds:
++            lp.variables = lp.numVarArray(len(cobra_model.reactions), lower_bounds,
++                                          upper_bounds, variable_kinds, variable_names)
++        else:
++            lp.variables = lp.numVarArray(len(cobra_model.reactions), lower_bounds, upper_bounds,
++                                          variable_names)
++        
++        lp.variable_dict = dict(zip(cobra_model.reactions, lp.variables))
++        if objective_sense == 'maximize':
++            __lp_add_objective = lp.addMaximize
++        else:
++            __lp_add_objective = lp.addMinimize
++
++        __lp_add_objective(lp.scalProd(lp.variables, objective_coefficients))
++        
++
++        
++        lp.constraints = []
++        lp.constraint_dict = {}
++        for the_metabolite in cobra_model.metabolites:
++            linear_expression = lp.sum([lp.prod(k._metabolites[the_metabolite],
++                                                lp.variable_dict[k])
++                                        for k in the_metabolite._reaction])
++            expression_pointer = lp.add_linear_expression(linear_expression, the_metabolite)
++            lp.constraints.append(expression_pointer)
++            lp.constraint_dict[the_metabolite] = expression_pointer
++        
++        if quadratic_component is not None:
++            raise Exception("cplex through java isn't configured for QPs yet")
++            if not hasattr(quadratic_component, 'todok'):
++                raise Exception('quadratic component must have method todok')
++            quadratic_component_scaled = quadratic_component.todok()
++
++            lp.parameters.emphasis.numerical.set(1)
++            for k, v in quadratic_component_scaled.items():
++                lp.objective.set_quadratic_coefficients(int(k[0]), int(k[1]), v)
++
++        if error_reporting == 'time':
++            print 'setup new problem: ' + repr(time()-start_time)
++            start_time = time()
++
++        ## #Set the problem type as cplex doesn't appear to do this correctly
++        ## problem_type = Cplex.problem_type.LP
++        ## if Cplex.variables.type.integer in variable_kinds:
++        ##     if quadratic_component is not None:
++        ##         problem_type = Cplex.problem_type.MIQP
++        ##     else:
++        ##         problem_type = Cplex.problem_type.MILP
++        ## elif quadratic_component is not None:
++        ##     problem_type = Cplex.problem_type.QP
++        ## lp.set_problem_type(problem_type)
++        return(lp)
++
++else:
++    ###Python functions
++    parameter_mappings = parameter_mappings[solver_name]
++    objective_senses = objective_senses[solver_name]
++    from cplex import Cplex, SparsePair
++    class Problem(Cplex):
++        def __init__(self):
++            Cplex.__init__(self)
++    __solver_class = Problem
++    variable_kind_dict = eval(variable_kind_dict[solver_name])
++
++    def get_status(lp):
++        status = lp.solution.get_status_string().lower()
++        if status in status_dict:
++            status = status_dict[status]
++        else:
++            status = 'failed'
++        return status
++
++    def format_solution(lp, cobra_model, **kwargs):
++        status = get_status(lp)
++        #TODO: It might be able to speed this up a little.
++        if status == 'optimal':
++            objective_value = lp.solution.get_objective_value()
++            #This can be sped up a little
++            x_dict = dict(zip(lp.variables.get_names(),
++                         lp.solution.get_values()))
++            x = lp.solution.get_values()
++            #MIP's don't have duals
++            if lp.get_problem_type() in (Cplex.problem_type.MIQP,
++                                         Cplex.problem_type.MILP):
++
++                y = y_dict = None
++            else:
++                y_dict = dict(zip(lp.linear_constraints.get_names(),
++                                  lp.solution.get_dual_values()))
++                y = lp.solution.get_dual_values()
++        else:
++            x = y = x_dict = y_dict = objective_value = None
++
++        the_solution = Solution(objective_value, x=x, x_dict=x_dict,
++                                status=status, y=y, y_dict=y_dict)
++        return the_solution    
++   
++    def set_parameter(lp, parameter_name, parameter_value):
++        """with pyglpk the parameters are set during the solve phase
++        """
++        if parameter_name == 'objective.set_sense':
++            if parameter_value in objective_senses:
++                parameter_value = eval(objective_senses[parameter_value])
++        try:
++            eval('lp.%s(%s)'%(parameter_name, repr(parameter_value)))
++        except Exception, e:
++            print "Couldn't set parameter %s: %s"%(parameter_name, repr(e))
++
++
++
++    def create_problem(cobra_model,  **kwargs):
++        """Solver-specific method for constructing a solver problem from
++        a cobra.Model.  This can be tuned for performance using kwargs
++
++
++        """
++        the_parameters = parameter_defaults
++        if kwargs:
++            the_parameters = deepcopy(parameter_defaults)
++            the_parameters.update(kwargs)
++
++        lp = __solver_class()
++        if 'log_file' not in the_parameters:
++            lp.set_results_stream(None)
++            lp.set_warning_stream(None)
++        [set_parameter(lp, parameter_mappings[k], v)
++         for k, v in the_parameters.iteritems() if k in parameter_mappings]
++        quadratic_component = the_parameters['quadratic_component']
++        new_objective = the_parameters['new_objective']
++        error_reporting = the_parameters['error_reporting']
++        if 'relax_b' in the_parameters:
++            warn('need to reimplement relax_b')
++            relax_b = False
++        else:
++            relax_b = False
++
++        #Using the new objects
++        #NOTE: This might be slow
++        objective_coefficients = []
++        lower_bounds = []
++        upper_bounds = []
++        variable_names = []
++        variable_kinds = []
++        [(objective_coefficients.append(x.objective_coefficient),
++          lower_bounds.append(x.lower_bound),
++          upper_bounds.append(x.upper_bound),
++          variable_names.append(x.id),
++          variable_kinds.append(variable_kind_dict[x.variable_kind]))
++         for x in cobra_model.reactions]
++        #Cplex decides that the problem is a MIP if variable_kinds are supplied
++        #even if there aren't any integers.
++        if variable_kind_dict['integer'] in variable_kinds:
++            lp.variables.add(obj=objective_coefficients,
++                             lb=lower_bounds,
++                             ub=upper_bounds,
++                             names=variable_names,
++                             types=variable_kinds)
++        else:
++            lp.variables.add(obj=objective_coefficients,
++                             lb=lower_bounds,
++                             ub=upper_bounds,
++                             names=variable_names)
++
++       ## if relax_b:
++            ## range_values = zeros(len(cobra_model.metabolites))
++            ## b_values = array([x._bound for x in cobra_model.metabolties])
++            ## for the_nonzero in list(b_values.nonzero()[0]):
++            ##     range_values[the_nonzero] = -relax_b
++
++        constraint_sense = []
++        constraint_names = []
++        constraint_limits = []
++        [(constraint_sense.append(x._constraint_sense),
++          constraint_names.append(x.id),
++          constraint_limits.append(x._bound))
++         for x in cobra_model.metabolites]
++
++        the_linear_expressions = []
++        #NOTE: This won't work with metabolites that aren't in any reaction
++        for the_metabolite in cobra_model.metabolites:
++            variable_list = []
++            coefficient_list = []
++            for the_reaction in the_metabolite._reaction:
++                variable_list.append(the_reaction.id)
++                coefficient_list.append(the_reaction._metabolites[the_metabolite])
++            the_linear_expressions.append(SparsePair(ind=variable_list,
++                                                     val=coefficient_list))
++        if quadratic_component is not None:
++            if not hasattr(quadratic_component, 'todok'):
++                raise Exception('quadratic component must have method todok')
++            quadratic_component_scaled = quadratic_component.todok()
++
++            lp.parameters.emphasis.numerical.set(1)
++            for k, v in quadratic_component_scaled.items():
++                lp.objective.set_quadratic_coefficients(int(k[0]), int(k[1]), v)
++
++
++        if relax_b:
++            lp.linear_constraints.add(lin_expr=the_linear_expressions,
++                                      rhs=constraint_limits,
++                                      range_values=list(range_values),
++                                      senses=constraint_sense,
++                                      names=constraint_names)
++
++        else:
++            lp.linear_constraints.add(lin_expr=the_linear_expressions,
++                                      rhs=constraint_limits,
++                                      senses=constraint_sense,
++                                      names=constraint_names)
++
++        if error_reporting == 'time':
++            print 'setup new problem: ' + repr(time()-start_time)
++            start_time = time()
++
++        #Set the problem type as cplex doesn't appear to do this correctly
++        problem_type = Cplex.problem_type.LP
++        if Cplex.variables.type.integer in variable_kinds:
++            if quadratic_component is not None:
++                problem_type = Cplex.problem_type.MIQP
++            else:
++                problem_type = Cplex.problem_type.MILP
++        elif quadratic_component is not None:
++            problem_type = Cplex.problem_type.QP
++        lp.set_problem_type(problem_type)
++        return(lp)
++
++###
++
++def update_problem(lp, cobra_model, **kwargs):
++    """A performance tunable method for updating a model problem file
++
++    lp: A gurobi problem object
++
++    cobra_model: the cobra.Model corresponding to 'lp'
++
++    """
++    #When reusing the basis only assume that the objective coefficients or bounds can change
++    #BUG with changing / unchanging the basis
++    try:
++        new_objective = kwargs['new_objective']
++    except:
++        new_objective = None
++    try:
++        update_problem_reaction_bounds = kwargs['update_problem_reaction_bounds']
++    except:
++        update_problem_reaction_bounds = True
++    try:
++        quadratic_component = kwargs['quadratic_component']
++        if quadratic_component is not None:
++            warn("update_problem does not yet take quadratic_component as a parameter")
++    except:
++        quadratic_component = None
++    
++    if 'copy_problem' in kwargs and kwargs['copy_problem']:
++        lp = Cplex(lp)
++
++    if new_objective is not None:
++        lp.objective.set_linear([(x.id, float(x.objective_coefficient))
++                                 for x in cobra_model.reactions])
++    if update_problem_reaction_bounds:
++        lp.variables.set_upper_bounds([(x.id, float(x.upper_bound))
++                                        for x in cobra_model.reactions])
++        lp.variables.set_lower_bounds([(x.id, float(x.lower_bound))
++                                        for x in cobra_model.reactions])
++
++
++
++###
++def solve_problem(lp, **kwargs):
++    """A performance tunable method for updating a model problem file
++
++    """
++    #Update parameter settings if provided
++    if kwargs:
++        [set_parameter(lp, parameter_mappings[k], v)
++         for k, v in kwargs.iteritems() if k in parameter_mappings]
++    try:
++        print_solver_time = kwargs['print_solver_time']
++        start_time = time()
++    except:
++        print_solver_time = False
++
++    try:
++        the_problem = kwargs['the_problem']
++    except:
++        the_problem = False
++    if isinstance(the_problem, __solver_class):
++        try:
++            the_basis = the_problem.solution.basis.get_basis()
++            lp.start.set_basis(the_basis[0],the_basis[1])
++            lp.parameters.preprocessing.presolve.set(0)
++        except:
++            print 'no basis in the_problem'
++    
++    lp.solve()
++    #If the solver takes more than 0.1 s with a hot start it is likely stuck
++    status = get_status(lp)
++    if status != 'optimal':
++        #Cycle through the different solver options, if a solution is not found
++        for lp_method in (1, 2, 3, 4, 5, 6):
++            set_parameter(lp, parameter_mappings['lp_method'], lp_method)
++            lp.solve()
++            status = get_status(lp)
++            if status == 'optimal':
++                break
++
++    if print_solver_time:
++        print 'optimize time: %f'%(time() - start_time)
++    return status
++
++    
++def solve(cobra_model, **kwargs):
++    """
++
++    """
++        #Update objectives if they are new.
++    if 'new_objective' in kwargs and \
++           kwargs['new_objective'] not in ['update problem', None]:
++       update_objective(cobra_model, kwargs['new_objective'])
++
++    if 'the_problem' in kwargs:
++        the_problem = kwargs['the_problem']
++    else:
++        the_problem = None
++    if 'error_reporting' in kwargs:
++        error_reporting = kwargs['error_reporting']
++    else:
++        error_reporting = False
++    if isinstance(the_problem, __solver_class):
++        #Update the problem with the current cobra_model
++        lp = the_problem
++        update_problem(lp, cobra_model, **kwargs)
++    else:
++        #Create a new problem
++        lp = create_problem(cobra_model, **kwargs)
++    #Deprecated way for returning a solver problem created from a cobra_model
++    #without performing optimization
++    if the_problem == 'setup':
++        return lp
++    status = solve_problem(lp)
++    the_solution = format_solution(lp, cobra_model)
++    if status != 'optimal' and error_reporting:
++        print '%s failed: %s'%(solver_name, status)
++    cobra_model.solution = the_solution
++    solution = {'the_problem': lp, 'the_solution': the_solution}
++    return solution
+Index: cobra/solvers/gurobi.py
+===================================================================
+--- cobra/solvers/gurobi.py	(revision 330)
++++ cobra/solvers/gurobi.py	(working copy)
+@@ -1,88 +0,0 @@
+-from gurobipy import GRB, Model, LinExpr, GRB, QuadExpr, Column
+-from numpy import array
+-
+-from ..core.Solution import Solution
+-
+-
+-# mappers from cobra representation to gurobi
+-sense_dict = {
+-    'E': GRB.EQUAL,
+-    'L': GRB.LESS_EQUAL,
+-    'G': GRB.GREATER_EQUAL}
+-variable_kind_dict = {
+-    'continuous': GRB.CONTINUOUS,
+-    'integer': GRB.INTEGER}
+-parameter_dict = {  # TODO USE
+-    "tolerance_feasibility": "FeasibilityTol",
+-    "tolerance_optimality": "OptimalityTol"}
+-default_parameters = {
+-}
+-
+-# mappers from gurobi representations to cobra
+-status_dict = {
+-    GRB.OPTIMAL: 'optimal',
+-    GRB.INFEASIBLE: 'infeasible',
+-    GRB.UNBOUNDED: 'unbounded'}
+-
+-
+-def create_problem(cobra_model, objective_sense="maximize"):
+-    lp = Model("cobra")
+-    lp.Params.OutputFlag = 0
+-
+-    if objective_sense == 'maximize':
+-        objective_sign = -1.0
+-    elif objective_sense == 'minimize':
+-        objective_sign = 1.0
+-    else:
+-        raise ValueError("objective_sense must be 'maximize' or 'minimize'")
+-
+-    # create metabolites/constraints
+-    metabolite_constraints = {}
+-    for metabolite in cobra_model.metabolites:
+-        metabolite_constraints[metabolite] = \
+-            lp.addConstr(0.0, sense_dict[metabolite._constraint_sense],
+-            metabolite._bound, metabolite.id)
+-    lp.update()
+-
+-    # create reactions/variables along with S matrix
+-    for j, reaction in enumerate(cobra_model.reactions):
+-        constraints = [metabolite_constraints[i] \
+-            for i in reaction._metabolites]
+-        stoichiometry = reaction._metabolites.values()
+-        lp.addVar(
+-            lb=float(reaction.lower_bound),
+-            ub=float(reaction.upper_bound),
+-            obj=objective_sign * reaction.objective_coefficient,
+-            name=reaction.id,
+-            vtype=variable_kind_dict[reaction.variable_kind],
+-            column=Column(stoichiometry, constraints))
+-    lp.update()
+-    return lp
+-
+-
+-def update_problem(cobra_model, lp, objective_sense="maximize"):
+-    pass
+-    # TODO implement
+-
+-
+-def solve_problem(lp):
+-    lp.optimize()
+-    try:
+-        status = status_dict[lp.status]
+-    except KeyError:
+-        status = "unkown error: " + lp.status
+-    solution = Solution(status)
+-    solution.status = status
+-    if status == "optimal":
+-        solution.objective_value = lp.ObjVal * -1  # TODO fix sign
+-        solution.x_dict = dict((v.VarName, v.X) for v in lp.getVars())
+-        if lp.isMIP:
+-            solution.y_dict = None  # MIP's don't have duals
+-        else:
+-            solution.y_dict = \
+-                dict((c.ConstrName, c.Pi) for c in lp.getConstrs())
+-    return solution
+-
+-
+-def solve(cobra_model, objective_sense="maximize", **kwargs):
+-    return solve_problem(create_problem(cobra_model, objective_sense))
+Index: cobra/solvers/glpk_solver.py
+===================================================================
+--- cobra/solvers/glpk_solver.py	(revision 0)
++++ cobra/solvers/glpk_solver.py	(revision 0)
+@@ -0,0 +1,556 @@
++##cobra.solvers.glpk_solver
++#This script provides wrappers for libglpk-java 1.0.22 and pyglpk 0.3
++from __future__ import absolute_import
++from warnings import warn
++from os import name as __name
++from copy import deepcopy
++###solver specific parameters
++from .parameters import status_dict, variable_kind_dict, \
++     sense_dict, parameter_mappings, parameter_defaults, \
++     objective_senses, default_objective_sense
++
++from ..core.Solution import Solution
++from ..flux_analysis.objective import update_objective
++from time import time
++solver_name = 'glpk'
++sense_dict = eval(sense_dict[solver_name])
++#Functions that are different for java implementation of a solver
++if __name == 'java':
++    ## from jarray import array as j_array
++    ## def array(x, variable_type='d'):
++    ##     return j_array(x, variable_type)
++
++    from org.gnu.glpk import GLPK, GLPKConstants, glp_smcp, glp_iocp
++    variable_kind_dict = eval(variable_kind_dict['%s_%s'%(solver_name,
++                                                __name)])
++    status_dict = eval(status_dict['%s_%s'%(solver_name,
++                                                __name)])
++    objective_senses = objective_senses['%s_%s'%(solver_name,
++                                                __name)]
++    parameter_mappings = parameter_mappings['%s_%s'%(solver_name,
++                                                     __name)]
++    parameter_defaults = parameter_defaults['%s_%s'%(solver_name,
++                                                     __name)]
++
++    class Problem():
++        """Create a more pythonesqe class to wrap the key
++        features of the libglpk-java functions.
++        
++        """
++        def __init__(self):
++            """the attributes g, lp, mip should be made private
++            """
++            self._g = GLPK
++            self._lp= GLPK.glp_create_prob()
++            self._simplex_parameters = glp_smcp()
++            self._mip_parameters = None
++            self._g.glp_init_smcp(self._simplex_parameters)
++            self.status = self.objective_value = None
++            self._mip = False
++        def set_name(self, name=''):
++            self._g.glp_set_prob_name(self._lp, name)
++
++        def solve(self):
++            try:
++                self._g.glp_simplex(self._lp,
++                                   self._simplex_parameters)
++                if self._mip:
++                    #perform the MIP
++                    setattr(self._mip_parameters, 'msg_lev',
++                             self._simplex_parameters.msg_lev)
++                    self._g.glp_intopt(self._lp, self._mip_parameters)
++                self.status = self.get_status()
++                self.objective_value = self.get_objective_value()
++            except:
++                self.status = 'failed'
++            return self.status
++
++        def get_status(self):
++            if self._mip:
++                status = self._g.glp_mip_status(self._lp)
++            else:
++                status = self._g.glp_get_status(self._lp)
++            return status_dict[status]
++        
++        def set_objective_sense(self, parameter_value='maximize'):
++            self._g.glp_set_obj_dir(self._lp,
++                                   eval(objective_senses[parameter_value]))
++
++        def set_parameter(self, parameter_name, parameter_value, warning=False):
++            if parameter_name == 'objective_sense':
++                self.set_objective_sense()
++            else:
++                if parameter_name == 'meth' and parameter_value not in [1,2,3]:
++                    parameter_value = 1
++                try:
++                    setattr(self._simplex_parameters, parameter_name,
++                            parameter_value)
++                except Exception, e1:
++                    try:
++                        setattr(self._mip_parameters, parameter_name,
++                                parameter_value)
++                    except Exception, e2:
++                        if warning:
++                            print "Could not set simplex parameter " +\
++                                  "%s: %s"%(parameter_name, repr(e1))
++                            
++                            if self._mip_parameters is not None:
++                                print "Could not set mip parameter " +\
++                                      "%s: %s"%(parameter_name, repr(e2))
++        def get_objective_value(self):
++            if self._mip:
++                tmp_value = self._g.glp_mip_obj_val(self._lp)
++            else:
++                tmp_value = self._g.glp_get_obj_val(self._lp)
++            return tmp_value
++
++        def create_problem(self, cobra_model):
++            g = self._g
++            lp = self._lp
++            number_of_reactions = len(cobra_model.reactions)
++            number_of_metabolites = len(cobra_model.metabolites)
++            g.glp_add_cols(lp, number_of_reactions)
++            reaction_to_index = {}
++            objective_dict = {}
++            #Add in the variables
++            tmp_kinds = []
++            for i, the_reaction in enumerate(cobra_model.reactions):
++                i_offset = i + 1
++                reaction_to_index[the_reaction] = i_offset
++                if the_reaction.objective_coefficient != 0:
++                    objective_dict[i_offset] = the_reaction.objective_coefficient
++                g.glp_set_col_name(lp, i_offset, the_reaction.id)
++                tmp_kinds.append(the_reaction.variable_kind)
++                the_kind = variable_kind_dict[the_reaction.variable_kind]
++                lower_bound = the_reaction.lower_bound
++                upper_bound = the_reaction.upper_bound
++                #Note. It is possible to have unbounded or one-bound variables
++                if lower_bound == upper_bound:
++                    bound_kind = GLPKConstants.GLP_FX
++                else:
++                    bound_kind = GLPKConstants.GLP_DB
++                g.glp_set_col_kind(lp, i_offset, the_kind)
++                g.glp_set_col_bnds(lp, i_offset,
++                                   bound_kind, the_reaction.lower_bound,
++                                   the_reaction.upper_bound)
++            tmp_kinds = set(tmp_kinds)
++            if 'integer' in tmp_kinds or 'binary' in tmp_kinds:
++                self._mip = True
++                self._mip_parameters = glp_iocp()
++                _g.glp_init_iocp(self._mip_parameters)
++            #create constraints
++            g.glp_add_rows(lp, number_of_metabolites)
++            row_indices = []
++            column_indices = []
++            constraint_values = []
++            for i, the_metabolite in enumerate(cobra_model.metabolites):
++                i_offset = i + 1
++                g.glp_set_row_name(lp, i_offset, the_metabolite.id)
++                bound_type = GLPKConstants.GLP_FX
++                lower_bound = upper_bound = the_metabolite._bound
++                constraint_sense = sense_dict[the_metabolite._constraint_sense]
++                if constraint_sense == 'L':
++                    bound_type = GLPKConstants.GLP_LO
++                elif constraint_sense == 'G':
++                    bound_type = GLPKConstants.GLP_UP
++                elif constraint_sense == 'U':
++                    bound_type = GLPKConstants.GLP_FR
++                elif hasattr(lower_bound, '__iter__'):
++                    lower_bound, upper_bound = lower_bound[:2]
++                    bound_type = GLPKConstants.GLP_DB
++                    
++
++                g.glp_set_row_bnds(lp, i_offset, bound_type,
++                                   lower_bound, upper_bound)
++
++                [(row_indices.append(i_offset),
++                  column_indices.append(reaction_to_index[k]),
++                  constraint_values.append(k._metabolites[the_metabolite]))
++                 for k in the_metabolite._reaction]
++
++            #Load the constraints into the lp.  Need to use
++            #typed arrays.
++            number_of_constraints = len(row_indices)
++            i_array = g.new_intArray(number_of_constraints)
++            j_array = g.new_intArray(number_of_constraints)
++            v_array = g.new_doubleArray(number_of_constraints)
++            for a, (i, j, v) in enumerate(zip(row_indices,
++                                              column_indices,
++                                              constraint_values)):
++                g.intArray_setitem(i_array, a+1, i)
++                g.intArray_setitem(j_array, a+1, j)
++                g.doubleArray_setitem(v_array, a+1, v)
++            g.glp_load_matrix(lp, number_of_constraints, i_array,
++                              j_array, v_array)
++            g.delete_intArray(i_array)
++            g.delete_intArray(j_array)
++            g.delete_doubleArray(v_array)
++            
++    
++            g.glp_set_obj_name(lp, "z")
++            self.set_objective_sense()
++            [g.glp_set_obj_coef(lp, k, v)
++              for k, v in objective_dict.iteritems()]
++
++            
++
++
++
++
++    __solver_class = Problem
++
++    def set_parameter(lp, parameter_name, parameter_value):
++        lp.set_parameter(parameter_name, parameter_value)
++
++
++    def get_status(lp):
++        return lp.get_status()
++
++    def format_solution(lp, cobra_model, **kwargs):
++        """
++
++        """
++        status = get_status(lp)
++        if not lp._mip:
++            try:
++                x = [lp._g.glp_get_col_prim(lp._lp, i + 1)
++                     for i in range(len(cobra_model.reactions))]
++                x_dict = dict(zip(cobra_model.reactions, x))
++
++                y = [lp._g.glp_get_row_dual(lp._lp, i + 1)
++                     for i in range(len(cobra_model.metabolites))]
++                y_dict = dict(zip(cobra_model.metabolites, y))
++            
++                objective_value = lp.objective_value
++            except Exception, e:
++                print repr(e)
++                y = y_dict = x = x_dict = objective_value = None
++                #print status
++        else:
++            try:
++                x = [lp._g.glp_mip_col_val(lp._lp, i + 1)
++                     for i in range(cobra_model.reactions)]
++                x_dict = dict(zip(cobra_model.reactions, x))
++                y = y_dict = None
++                objective_value = lp.objective_value
++            except:
++                y = y_dict = x = x_dict = objective_value = None
++
++        return(Solution(objective_value, x=x, x_dict=x_dict, y=y,
++                        y_dict=y_dict, status=status))
++    def create_problem(cobra_model,  **kwargs):
++        """Solver-specific method for constructing a solver problem from
++        a cobra.Model.  This can be tuned for performance using kwargs
++
++
++        """
++        the_parameters = parameter_defaults
++        if kwargs:
++            the_parameters = deepcopy(parameter_defaults)
++            the_parameters.update(kwargs)
++        quadratic_component = the_parameters['quadratic_component']
++        new_objective = the_parameters['new_objective']
++        if quadratic_component is not None:
++            raise Exception('%s cannot solve QPs, try a different solver'%solver_name)
++        lp = Problem()        # Create empty problem instance
++        lp.create_problem(cobra_model)
++        [set_parameter(lp, parameter_mappings[k], v)
++         for k, v in the_parameters.iteritems() if k in parameter_mappings]
++        return(lp)
++    
++    def update_problem(lp, cobra_model, **kwargs):
++        """
++        Assumes that neither Metabolites nor Reaction have been
++        added or removed.
++
++        Currently only deals with reaction bounds and objective
++        coefficients.
++
++        """
++        g = lp._g
++        l = lp._lp
++        for i, the_reaction in enumerate(cobra_model.reactions):
++            lower_bound = float(the_reaction.lower_bound)
++            upper_bound = float(the_reaction.upper_bound)
++            objective_coefficient = float(the_reaction.objective_coefficients)
++            if lower_bound == upper_bound:
++                bound_type = GLPKConstants.GLP_FX
++            else:
++                bound_type = GLPKConstants.GLP_DB
++            g.glp_set_col_bnds(l, i + 1, bound_type, lower_bound, upper_bound)
++            g.glp_set_obj_coef(l, i + 1, objective_coefficient)
++
++        
++    def solve_problem(lp, **kwargs):
++        """A performance tunable method for updating a model problem file
++
++        """
++        #Update parameter settings if provided
++        if kwargs:
++            [set_parameter(lp, parameter_mappings[k], v)
++             for k, v in kwargs.iteritems() if k in parameter_mappings]
++        try:
++            print_solver_time = kwargs['print_solver_time']
++            start_time = time()
++        except:
++            print_solver_time = False
++        lp_method = lp._simplex_parameters.meth
++        the_methods = [1, 2, 3]
++        if lp_method in the_methods:
++            the_methods.remove(lp_method)
++        else:
++            lp_method = 1
++        lp.solve()
++        status = get_status(lp)
++        if status != 'optimal':
++            for lp_method in the_methods:
++                set_parameter(lp, parameter_mappings['lp_method'], lp_method)
++                lp.solve()
++                status = get_status(lp)
++                break
++        if print_solver_time:
++            print 'optimize time: %f'%(time() - start_time)
++        return status
++else:
++    ##Interface to pyGLPK 0.3 
++    from glpk import LPX as GLPK
++    __solver_class = GLPK
++    objective_senses = objective_senses[solver_name]
++    variable_kind_dict = eval(variable_kind_dict[solver_name])
++    status_dict = eval(status_dict[solver_name])
++    parameter_mappings = parameter_mappings[solver_name]
++    parameter_defaults = parameter_defaults[solver_name]
++
++    def get_status(lp):
++        status = lp.status
++        if status in status_dict:
++            status = status_dict[status]
++        else:
++            status = 'failed'
++        return status
++
++    def format_solution(lp, cobra_model, **kwargs):
++        try:
++            objective_sign = objective_senses[kwargs['objective_sense']]
++        except:
++            objective_sign = objective_senses[default_objective_sense]
++            
++        status = get_status(lp)
++        if status == 'optimal':
++            objective_value = lp.obj.value
++            x = []
++            x_dict = {}
++            [(x.append(float(c.primal)),
++              x_dict.update({c.name:c.primal}))
++              for c in lp.cols]
++
++            if lp.kind == float:
++                y = []
++                y_dict = {}
++                #return the duals as well as the primals for LPs
++                [(y.append(float(c.dual)),
++                  y_dict.update({c.name:c.dual}))
++                 for c in lp.rows]
++            else:
++                #MIPs don't have duals
++                y = y_dict = None
++            the_solution = Solution(objective_value, x=x, x_dict=x_dict, y=y,
++                                    y_dict=y_dict, status=status)
++        else:
++            the_solution = Solution(None, status=status)
++        return(the_solution)
++
++    def set_parameter(lp, parameter_name, parameter_value):
++        """with pyglpk the parameters are set during the solve phase
++        """
++        warn("py glpk solver parameters are set during solve_problem")
++        pass
++
++    def create_problem(cobra_model,  **kwargs):
++        """Solver-specific method for constructing a solver problem from
++        a cobra.Model.  This can be tuned for performance using kwargs
++
++
++        """
++        the_parameters = parameter_defaults
++        if kwargs:
++            the_parameters = deepcopy(parameter_defaults)
++            the_parameters.update(kwargs)
++        quadratic_component = the_parameters['quadratic_component']
++        new_objective = the_parameters['new_objective']
++        if quadratic_component is not None:
++            raise Exception('%s cannot solve QPs, try a different solver'%solver_name)
++        #Faster to use these dicts than index lists
++        index_to_metabolite = dict(zip(range(len(cobra_model.metabolites)),
++                                       cobra_model.metabolites))
++        index_to_reaction = dict(zip(range(len(cobra_model.reactions)),
++                                     cobra_model.reactions))
++        reaction_to_index = dict(zip(index_to_reaction.values(),
++                                     index_to_reaction.keys()))
++
++
++        lp = __solver_class()        # Create empty problem instance
++        lp.name = 'cobra'     # Assign symbolic name to problem
++        lp.rows.add(len(cobra_model.metabolites))
++        lp.cols.add(len(cobra_model.reactions))
++        linear_constraints = []
++        for r in lp.rows:
++            the_metabolite = index_to_metabolite[r.index]
++            r.name = the_metabolite.id
++            b = float(the_metabolite._bound)
++            c = sense_dict[the_metabolite._constraint_sense]
++            if c == 'E':
++                r.bounds = b, b     # Set metabolite to steady state levels
++            elif c == 'L':
++                r.bounds = None, b
++            elif c == 'G':
++                r.bounds = b, None
++            #Add in the linear constraints
++
++            for the_reaction in the_metabolite._reaction:
++                reaction_index = reaction_to_index[the_reaction]
++                the_coefficient = the_reaction._metabolites[the_metabolite]
++                linear_constraints.append((r.index, reaction_index,
++                                           the_coefficient))
++        #Need to assign lp.matrix after constructing the whole list
++        lp.matrix = linear_constraints
++        objective_coefficients = []
++
++        for c in lp.cols:
++            the_reaction = index_to_reaction[c.index]
++            c.name = the_reaction.id           
++            the_reaction = index_to_reaction[c.index]
++            c.kind = variable_kind_dict[the_reaction.variable_kind]
++            c.bounds = the_reaction.lower_bound, the_reaction.upper_bound
++            objective_coefficients.append(float(the_reaction.objective_coefficient))
++        #Add the new objective coefficients to the problem
++        lp.obj[:] = objective_coefficients
++
++        return(lp)
++
++
++    def update_problem(lp, cobra_model, **kwargs):
++        """A performance tunable method for updating a model problem file
++
++        lp: A gurobi problem object
++
++        cobra_model: the cobra.Model corresponding to 'lp'
++
++        """
++        #When reusing the basis only assume that the objective coefficients or bounds can change
++        #BUG with changing / unchanging the basis
++        index_to_metabolite = dict(zip(range(len(cobra_model.metabolites)),
++                                       cobra_model.metabolites))
++        index_to_reaction = dict(zip(range(len(cobra_model.reactions)),
++                                     cobra_model.reactions))
++        reaction_to_index = dict(zip(index_to_reaction.values(),
++                                     index_to_reaction.keys()))
++
++        try:
++            new_objective = kwargs['new_objective']
++        except:
++            new_objective = None
++        if new_objective is not None:
++            objective_coefficients = []
++            for c in lp.cols:      # Iterate over all rows
++                the_reaction = index_to_reaction[c.index]
++                c.name = the_reaction.id
++                c.bounds = the_reaction.lower_bound, the_reaction.upper_bound
++                objective_coefficients.append(float(the_reaction.objective_coefficient))
++                c.kind = variable_kind_dict[the_reaction.variable_kind]
++            #Add the new objective coefficients to the problem
++            lp.obj[:] = objective_coefficients
++        else:
++            for c in lp.cols:      # Iterate over all rows
++                the_reaction = index_to_reaction[c.index]
++                c.name = the_reaction.id
++                c.bounds = the_reaction.lower_bound, the_reaction.upper_bound
++                c.kind = variable_kind_dict[the_reaction.variable_kind]
++
++
++    ###
++    def solve_problem(lp, **kwargs):
++        """A performance tunable method for updating a model problem file
++
++        """
++        #Update parameter settings if provided
++        the_parameters = parameter_defaults
++        if kwargs:
++            the_parameters = deepcopy(parameter_defaults)
++            the_parameters.update(kwargs)
++        try:
++            print_solver_time = kwargs['print_solver_time']
++            start_time = time()
++        except:
++            print_solver_time = False
++        tolerance_optimality = the_parameters['tolerance_optimality']
++        tolerance_integer = the_parameters['tolerance_integer']
++        lp_method = the_parameters['lp_method']
++        #[set_parameter(lp, parameter_mappings[k], v)
++        # for k, v in kwargs.iteritems() if k in parameter_mappings]
++
++        lp.obj.maximize = objective_senses[the_parameters['objective_sense']] 
++        the_methods = [1, 2, 3]
++        if lp_method in the_methods:
++            the_methods.remove(lp_method)
++        else:
++            lp_method = 1
++
++        if lp.kind == int:
++            #For MILPs, it is faster to solve LP then move to MILP
++            lp.simplex(tol_bnd=tolerance_optimality,
++                       tol_dj=tolerance_optimality, meth=lp_method)  
++            lp.integer(tol_int=tolerance_integer)
++        else:
++            lp.simplex(tol_bnd=tolerance_optimality, tol_dj=tolerance_optimality,
++                       meth=lp_method)
++        status = get_status(lp)
++        if status != 'optimal':
++            for lp_method in the_methods:
++                lp.simplex(tol_bnd=tolerance_optimality,
++                           tol_dj=tolerance_optimality, meth=lp_method)
++                status = get_status(lp)
++                if status == 'optimal':
++                    if lp.kind == int:
++                        lp.integer(tol_int=tolerance_integer)
++                    break
++        if print_solver_time:
++            print 'optimize time: %f'%(time() - start_time)
++        return status
++
++    
++def solve(cobra_model, **kwargs):
++    """
++
++    """
++    #Update objectives if they are new.
++    if 'new_objective' in kwargs and \
++           kwargs['new_objective'] not in ['update problem', None]:
++       update_objective(cobra_model, kwargs['new_objective'])
++
++    if 'the_problem' in kwargs:
++        the_problem = kwargs['the_problem']
++    else:
++        the_problem = None
++    if 'error_reporting' in kwargs:
++        error_reporting = kwargs['error_reporting']
++    else:
++        error_reporting = False
++    if isinstance(the_problem, __solver_class):
++        #Update the problem with the current cobra_model
++        lp = the_problem
++        update_problem(lp, cobra_model, **kwargs)
++    else:
++        #Create a new problem
++        lp = create_problem(cobra_model, **kwargs)
++    #Deprecated way for returning a solver problem created from a cobra_model
++    #without performing optimization
++    if the_problem == 'setup':
++        return lp
++    status = solve_problem(lp)
++    the_solution = format_solution(lp, cobra_model)
++    if status != 'optimal' and error_reporting:
++        print '%s failed: %s'%(solver_name, status)
++    cobra_model.solution = the_solution
++    solution = {'the_problem': lp, 'the_solution': the_solution}
++    return solution
+Index: cobra/oven/patches/patch_explanations.txt
+===================================================================
+--- cobra/oven/patches/patch_explanations.txt	(revision 330)
++++ cobra/oven/patches/patch_explanations.txt	(working copy)
+@@ -1,3 +1,11 @@
++cobra_pie_0.2.alpha01.patch:
++  Adds support for gurobi, cplex, and libglpk-java solvers through jython and moves towards the new style solvers.  
++  Adds sbml support for jython via jsbml.
++  Adds get_model to Reaction and Metabolite/Gene which returns the Model object that contains the calling Object.
++  Adds get_reaction to Metabolite/Gene which returns a list of Reaction Objects that contain the calling Object.
++  Started to remove numpy/scipy dependencies from core objects / functions as they aren't really essential.
++
++
+ DictList_tab_complete  
+ Allows tab completion on a DictList, such as model.reactions.PG<TAB> will
+ autocomplete to model.reactions.PGI
+Index: cobra/oven/patches/cobra_pie_0.2.alpha01.patch
+===================================================================
+--- cobra/oven/patches/cobra_pie_0.2.alpha01.patch	(revision 0)
++++ cobra/oven/patches/cobra_pie_0.2.alpha01.patch	(revision 0)
+@@ -0,0 +1,2748 @@
++Index: cobra/test/solvers.py
++===================================================================
++--- cobra/test/solvers.py	(revision 330)
+++++ cobra/test/solvers.py	(working copy)
++@@ -1,5 +1,6 @@
++ from unittest import TestCase, TestLoader, TextTestRunner
++ import sys
+++from pdb import set_trace
++ # deal with absolute imports by adding the appropriate directory to the path
++ sys.path.insert(0, "../..")
++ from cobra.manipulation import initialize_growth_medium
++@@ -14,7 +15,7 @@
++         self.model = create_test_model()
++         initialize_growth_medium(self.model, 'MgM')
++         self.old_solution = 0.320064
++-        self.infeasible_problem = Model()
+++        self.infeasible_model = Model()
++         metabolite_1 = Metabolite("met1")
++         metabolite_2 = Metabolite("met2")
++         reaction_1 = Reaction("rxn1")
++@@ -23,8 +24,8 @@
++         reaction_2.add_metabolites({metabolite_2: 1})
++         reaction_1.lower_bound = 1
++         reaction_2.upper_bound = 2
++-        self.infeasible_problem.add_reactions([reaction_1, reaction_2])
++-        #self.infeasible_problem.update()
+++        self.infeasible_model.add_reactions([reaction_1, reaction_2])
+++        #self.infeasible_model.update()
++ 
++ 
++ def add_new_test(TestCobraSolver, solver_name, solver):
++@@ -39,22 +40,28 @@
++     def test_setup(self):
++         solver.create_problem(self.model)
++     def test_solve_feasible(self):
++-        solution = solver.solve(self.model)
+++        solver.solve(self.model)
+++        solution = self.model.solution        
++         self.assertEqual(solution.status, "optimal")
++         self.assertAlmostEqual(self.old_solution, \
++-            solution.objective_value, places=4)
+++            solution.f, places=4)
++     def test_solve_infeasible(self):
++-        solution = solver.solve(self.infeasible_problem)
+++        solver.solve(self.infeasible_model)
+++        solution = self.infeasible_model.solution
++         self.assertEqual(solution.status, "infeasible")
+++
++     def test_independent_creation(self):
++         feasible_lp = solver.create_problem(self.model)
++-        infeasible_lp = solver.create_problem(self.infeasible_problem)
++-        feasible_solution = solve_problem(lp)
++-        infeasible_solution = solve_problem(lp)
+++        infeasible_lp = solver.create_problem(self.infeasible_model)
+++        solver.solve_problem(feasible_lp)
+++        solver.solve_problem(infeasible_lp)
+++        feasible_solution = solver.format_solution(feasible_lp, self.model)
+++        infeasible_solution = solver.format_solution(infeasible_lp, self.infeasible_model)
++         self.assertEqual(feasible_solution.status, "optimal")
++         self.assertAlmostEqual(self.old_solution, \
++-            feasible_solution.objective_value, places=4)
+++            feasible_solution.f, places=4)
++         self.assertEqual(infeasible_solution.status, "infeasible")
+++
++     setattr(TestCobraSolver, "test_%s_create" % solver_name, \
++         test_setup)
++     setattr(TestCobraSolver, "test_%s_attributes" % solver_name, \
++@@ -64,7 +71,7 @@
++     setattr(TestCobraSolver, "test_%s_infeasible_solve" % solver_name, \
++         test_solve_infeasible)
++     setattr(TestCobraSolver, "test_%s_independent_creation" % solver_name, \
++-        test_solve_infeasible)
+++        test_independent_creation)
++ 
++ def add_legacy_test(TestCobraSolver, solver_name, solver_function):
++     """Creates a test set for each of the installed solvers using the
++Index: cobra/test/__init__.py
++===================================================================
++--- cobra/test/__init__.py	(revision 330)
+++++ cobra/test/__init__.py	(working copy)
++@@ -1,10 +1,14 @@
+++from __future__ import with_statement, absolute_import
++ from os import name as __name
++-from sys import modules as __modules
++ from warnings import warn
++-if __name == 'java':
++-    raise Exception("%s is not yet supported on jython"%__modules[__name__])
+++test_import_string = 'from cobra.test.%s import test_all'
+++available_tests = ['unit_tests', 'solvers']
+++#if not using jython then add the tests that don't run through jython
+++if __name != 'java':
+++    available_tests += ['flux_analysis']
+++    
++ 
++-del __name, __modules
+++del __name
++ 
++ from os.path import abspath as __abspath
++ from os.path import join as __join
++@@ -24,12 +28,22 @@
++ 
++ def create_test_model(test_pickle=salmonella_pickle):
++     """returns the salmonella model for testing"""
+++    from os import name as __name
++     try:
++         from cPickle import load
++     except:
++         from pickle import load
++-    with open(test_pickle, "rb") as infile:
++-        model = load(infile)
+++
+++    try: 
+++        with open(test_pickle, "rb") as infile:
+++            model = load(infile)
+++    except:
+++        #if the pickle can't be loaded then load the sbml xml
+++        import sys
+++        sys.path.insert(0, "../..")
+++        from cobra.io import read_sbml_model
+++        model = read_sbml_model(salmonella_sbml)
+++        sys.path.pop(0)
++     return model
++ 
++ 
++@@ -38,15 +52,10 @@
++     import sys
++     sys.path.insert(0, "../..")
++     import unittest
++-    from cobra.test.unit_tests import test_all
++-    print '###running general unit tests###'
++-    test_all()
++-    from cobra.test.flux_analysis import test_all
++-    print '\n###running flux_analysis unit tests###'
++-    test_all()
++-    print '\n###running solver unit tests###'
++-    from cobra.test.solvers import test_all
++-    test_all()
+++    for the_test in available_tests:
+++        exec(test_import_string%the_test)
+++        print '###running %s tests###'%the_test
+++        test_all()
++     sys.path.pop(0)
++ 
++ del __abspath, __join, __split, __sep
++Index: cobra/test/flux_analysis.py
++===================================================================
++--- cobra/test/flux_analysis.py	(revision 330)
+++++ cobra/test/flux_analysis.py	(working copy)
++@@ -90,7 +90,9 @@
++                                             the_reactions=cobra_model.reactions[100:140])
++         fva_out = dict([(k.id, v) for k, v in fva_out.items()])
++         for the_reaction, the_range in fva_out.iteritems():
+++            #print the_reaction
++             for k, v in the_range.iteritems():
+++                #print " %s: %s vs %s"%(k, repr(fva_results[the_reaction][k]), repr(v))
++                 self.assertAlmostEqual(fva_results[the_reaction][k], v, places=3)
++         ## blocked_reactions = find_blocked_reactions(cobra_model)
++         ## open_ex_blocked = find_blocked_reactions(cobra_model,
++@@ -99,15 +101,16 @@
++     def test_assess_medium_component_essentiality(self):
++         """
++ 
++-        TODO: Add in a numerical value test
+++
++         """
++-        essentiality_results = {'EX_ser__L_e': 0.28511251509333996, 'EX_cobalt2_e': 0.0, 'EX_glu__L_e': 0.18551423955187463, 'EX_glyc_e': 0.02162967396132975, 'EX_h_e': 0.18551423955211313, 'EX_mobd_e': 0.0, 'EX_val__L_e': 0.18004717981556367, 'EX_so4_e': 0.1800471798156284, 'EX_co2_e': 0.18004717981574314, 'EX_k_e': 5.048709793414476e-29, 'EX_fe3_e': -3.4331226595218434e-27, 'EX_na1_e': 0.18004717981556367, 'EX_cl_e': 1.7495455763604752e-28, 'EX_leu__L_e': 0.1762785172191746, 'EX_arg__L_e': 0.13025755872698241, 'EX_nh4_e': 0.09432269135782297, 'EX_lys__L_e': 0.43718843672718055, 'EX_ala__L_e': 0.4371884367334397, 'EX_thr__L_e': 0.43718843673877533, 'EX_pi_e': 4.1028325973665373e-13, 'EX_mn2_e': 0.0, 'EX_phe__L_e': 0.380007972274807, 'EX_h2o_e': 0.38000797227380473, 'EX_mg2_e': 0.0, 'EX_his__L_e': 0.38000797227522415, 'EX_o2_e': 0.3428169207281707, 'EX_pro__L_e': 0.271070547843646, 'EX_asp__L_e': 0.38000797227507915, 'EX_gly_e': 0.3800079722747013, 'EX_cys__L_e': 0.3800079722760569, 'EX_cu2_e': 9.244463733058732e-31, 'EX_ca2_e': 0.0, 'EX_tyr__L_e': 0.38000797227331706, 'EX_zn2_e': 0.0, 'EX_met__L_e': 0.38000797227265026, 'EX_ile__L_e': 0.3800079722724871}
+++        essentiality_results = {'EX_ser__L_e': 0.28511251509333996, 'EX_cobalt2_e': 0.0,  'EX_glu__L_e': 0.18551423955187463, 'EX_glyc_e': 0.02162967396132975, 'EX_h_e': 0.18551423955211313, 'EX_mobd_e': 0.0, 'EX_val__L_e': 0.18004717981556367, 'EX_so4_e': 0.1800471798156284, 'EX_co2_e': 0.18004717981574314, 'EX_k_e': 5.048709793414476e-29, 'EX_fe3_e': -3.4331226595218434e-27, 'EX_na1_e': 0.18004717981556367, 'EX_cl_e': 1.7495455763604752e-28, 'EX_leu__L_e': 0.1762785172191746, 'EX_arg__L_e': 0.13025755872698241, 'EX_nh4_e': 0.09432269135782297, 'EX_lys__L_e': 0.43718843672718055, 'EX_ala__L_e': 0.4371884367334397, 'EX_thr__L_e': 0.43718843673877533, 'EX_pi_e': 4.1028325973665373e-13, 'EX_mn2_e': 0.0, 'EX_phe__L_e': 0.380007972274807, 'EX_h2o_e': 0.38000797227380473, 'EX_mg2_e': 0.0, 'EX_his__L_e': 0.38000797227522415, 'EX_o2_e': 0.3428169207281707, 'EX_pro__L_e': 0.271070547843646, 'EX_asp__L_e': 0.38000797227507915, 'EX_gly_e': 0.3800079722747013, 'EX_cys__L_e': 0.3800079722760569, 'EX_cu2_e': 9.244463733058732e-31, 'EX_ca2_e': 0.0, 'EX_tyr__L_e': 0.38000797227331706, 'EX_zn2_e': 0.0, 'EX_met__L_e': 0.38000797227265026, 'EX_ile__L_e': 0.3800079722724871}
++         cobra_model = self.model
++-        the_problem='return'
+++        
++         from cobra.flux_analysis import assess_medium_component_essentiality
++         essentiality_dict = assess_medium_component_essentiality(cobra_model, None, 'MgM')
++-        for k, v in essentiality_dict.iteritems():
++-            self.assertAlmostEqual(essentiality_results[k], v, places=3)
+++        for k, v in essentiality_results.iteritems():
+++            #print "%s expected: %s / simulated: %s"%(k, repr(v), repr(essentiality_dict[k]))
+++            self.assertAlmostEqual(essentiality_dict[k], v, places=3)
++ 
++ 
++ 
++Index: cobra/test/unit_tests.py
++===================================================================
++--- cobra/test/unit_tests.py	(revision 330)
+++++ cobra/test/unit_tests.py	(working copy)
++@@ -1,13 +1,15 @@
+++from __future__ import with_statement
++ from unittest import TestCase, TestLoader, TextTestRunner
++-#skipIf is not in python 2.6
+++#skipIf is not in python 2.6 / 2.5
++ try:
++     from unittest import skipIf
+++    from warnings import catch_warnings
++ except:
++     try:
++         from unittest2 import skipIf
++     except:
++         skipIf = None
++-from warnings import catch_warnings
+++
++ import sys
++ from os import unlink
++ sys.path.insert(0, "../..")
++@@ -60,6 +62,10 @@
++         self.assertEqual(len(self.list), 9)
++ 
++     def testAdd(self):
+++        from os import name as __name
+++        if __name == 'java':
+++            print 'cobra.test.unit_tests.testAdd does not yet work with %s'%__name
+++            return
++         obj_list = [Object("test%d" % (i)) for i in range(2, 10)]
++         sum = self.list + obj_list
++         self.assertEqual(self.list[0].id, "test1")
++@@ -127,18 +133,19 @@
++             io.write_sbml_model(self.model, test_output_filename)
++             #cleanup the test file
++             unlink(test_output_filename)
++-    
++-    def test_mat_read_write(self):
++-        test_output_filename = "test_mat_write.mat"
++-        io.save_matlab_model(self.model, test_output_filename)
++-        reread = io.load_matlab_model(test_output_filename)
++-        self.assertEqual(len(self.model.reactions), len(reread.reactions))
++-        self.assertEqual(len(self.model.metabolites), len(reread.metabolites))
++-        for i in range(len(self.model.reactions)):
++-            self.assertEqual(len(self.model.reactions[i]._metabolites), \
++-                len(reread.reactions[i]._metabolites))
++-            self.assertEqual(self.model.reactions[i].id, reread.reactions[i].id)
++-        unlink(test_output_filename)
+++    from os import name as __name
+++    if __name != 'java':
+++        def test_mat_read_write(self):
+++            test_output_filename = "test_mat_write.mat"
+++            io.save_matlab_model(self.model, test_output_filename)
+++            reread = io.load_matlab_model(test_output_filename)
+++            self.assertEqual(len(self.model.reactions), len(reread.reactions))
+++            self.assertEqual(len(self.model.metabolites), len(reread.metabolites))
+++            for i in range(len(self.model.reactions)):
+++                self.assertEqual(len(self.model.reactions[i]._metabolites), \
+++                    len(reread.reactions[i]._metabolites))
+++                self.assertEqual(self.model.reactions[i].id, reread.reactions[i].id)
+++            unlink(test_output_filename)
++ 
++ # make a test suite to run all of the tests
++ loader = TestLoader()
++Index: cobra/flux_analysis/moma.py
++===================================================================
++--- cobra/flux_analysis/moma.py	(revision 330)
+++++ cobra/flux_analysis/moma.py	(working copy)
++@@ -1,9 +1,15 @@
+++from __future__ import with_statement
++ #cobra.flux_analysis.moma.py: Runs the minimization of metabolic
++ #adjustment method described in Segre et al 2002 PNAS 99(23): 15112-7
+++from os import name as __name
+++from sys import modules as __modules
+++from warnings import warn
+++if __name == 'java':
+++    raise Exception("%s is not yet supported on jython"%__modules[__name__])
++ from copy import deepcopy
++ from time import time
++ from math import ceil, floor
++-from numpy import array, zeros, ones, hstack, vstack, matrix, sum
+++from numpy import array, hstack, vstack, matrix, sum
++ from scipy.sparse import eye, lil_matrix, dok_matrix
++ from scipy.sparse import hstack as s_hstack
++ from scipy.sparse import vstack as s_vstack
++Index: cobra/flux_analysis/objective.py
++===================================================================
++--- cobra/flux_analysis/objective.py	(revision 330)
+++++ cobra/flux_analysis/objective.py	(working copy)
++@@ -3,8 +3,11 @@
++ from ..core.Reaction import Reaction
++ from ..manipulation import initialize_growth_medium
++ import sys
++-if sys.maxsize > 2**32:
++-    from numpy import int64, int32
+++if hasattr(sys, 'maxsize') and sys.maxsize > 2**32:
+++    try:
+++        from numpy import int64, int32
+++    except:
+++        int32 = int64 = int
++ else:
++     int32 = int
++     int64 = int
++Index: cobra/flux_analysis/double_deletion.py
++===================================================================
++--- cobra/flux_analysis/double_deletion.py	(revision 330)
+++++ cobra/flux_analysis/double_deletion.py	(working copy)
++@@ -1,13 +1,27 @@
+++from __future__ import with_statement
++ #cobra.flux_analysis.double_deletion.py
++ #runs flux variablity analysis on a Model object.
++ from math import floor,ceil
++-from numpy import vstack,zeros, nan
+++from numpy import vstack,zeros
++ from scipy import sparse
++ from copy import deepcopy
++-from .moma import moma
++ from warnings import warn
++-from cPickle import dump
+++from os import name as __name
+++nan = float('nan')
+++from sys import modules as __modules
+++from warnings import warn
+++if __name == 'java':
+++    raise Exception("%s is not yet supported on jython"%__modules[__name__])
+++    warn("moma is not supported on %s"%__name)
+++    def moma(**kwargs):
+++        warn("moma is not supported on %s"%__name)
+++else:
+++    from .moma import moma    
++ try:
+++    from cPickle import dump
+++except:
+++    from pickle import dump
+++try:
++     from cobra.external.ppmap import ppmap
++     __parallel_mode_available = True
++ except:
++@@ -154,7 +168,8 @@
++     """
++     #BUG: Since this might be called from ppmap, the modules need to
++     #be imported.  Modify ppmap to take depfuncs
++-    from numpy import zeros, nan
+++    from numpy import zeros
+++    nan = float('nan')
++     from cobra.flux_analysis.single_deletion import single_deletion
++     from cobra.manipulation import initialize_growth_medium
++     from cobra.manipulation import delete_model_genes, undelete_model_genes
++Index: cobra/flux_analysis/essentiality.py
++===================================================================
++--- cobra/flux_analysis/essentiality.py	(revision 330)
+++++ cobra/flux_analysis/essentiality.py	(working copy)
++@@ -1,28 +1,41 @@
+++from __future__ import with_statement
++ #cobra.flux_analysis.essentiality.py
++ #runs flux variablity analysis on a Model object.
+++from os import name as __name
++ from warnings import warn
++ from math import floor,ceil
++-from numpy import vstack,zeros
++-from scipy import sparse
++ from copy import deepcopy
++-from cPickle import dump
++ from os import path, mkdir
++ try:
++-    #Allow for parallel simulations if ppmap is available
++-    from cobra.external import ppmap
++-    from double_deletion import double_deletion_parallel
++-    __parallel_mode_available = True
+++    from cPickle import dump
++ except:
+++    from pickle import dump
+++if __name == 'java':
++     __parallel_mode_available = False
++-    from double_deletion import double_deletion
++-from cobra.flux_analysis.moma import moma
+++    warn("moma is not supported on %s"%__name)
+++    warn("flux_analysis.double_deletion is not supported on %s"%__name)
+++    def moma(a, **kwargs):
+++        raise Exception("moma is not supported on %s"%__name)
+++
+++    def double_deletion(a, **kwargs):
+++        raise Exception("flux_analysis.double_deletion is not supported on %s"%__name)
+++else:
+++    try:
+++        #Allow for parallel simulations if ppmap is available
+++        from cobra.external import ppmap
+++        from double_deletion import double_deletion_parallel
+++        __parallel_mode_available = True
+++    except:
+++        __parallel_mode_available = False
+++        from double_deletion import double_deletion
+++    from cobra.flux_analysis.moma import moma
++ from cobra.flux_analysis.single_deletion import single_deletion
++ from cobra.manipulation import initialize_growth_medium
++ def assess_medium_component_essentiality(cobra_model, the_components=None,
++                                          the_medium=None, solver='glpk',
++                                          the_problem='return',
++                                          the_condition=None, method='fba'):
++-    """Deterimes which components in an in silico medium are essential for growth in the
+++    """Determines which components in an in silico medium are essential for growth in the
++     context of the remaining components.
++ 
++     cobra_model: A Model object.
++@@ -53,15 +66,17 @@
++     """
++     warn("assess_medium_component_essentiality needs to be updated to " +\
++          "deal with new style reactions")
++-    from cobra.core.ArrayBasedModel import ArrayBasedModel
+++    #from cobra.core.ArrayBasedModel import ArrayBasedModel
++     if method.lower() == 'moma':
++-        wt_model = ArrayBasedModel(cobra_model.copy())
+++        wt_model = cobra_model.copy()
+++        #wt_model = ArrayBasedModel(cobra_model.copy())
++     if isinstance(cobra_model, tuple):
++         if len(cobra_model) == 3:
++             the_condition = cobra_model[2]
++         the_components = cobra_model[1]
++         cobra_model = cobra_model[0]
++-    cobra_model = ArrayBasedModel(cobra_model.copy())
+++    #cobra_model = ArrayBasedModel(cobra_model.copy())
+++    cobra_model = cobra_model.copy()
++     if not the_components:
++         if the_medium:
++             if hasattr(the_medium, 'keys') or \
++@@ -76,15 +91,15 @@
++     essentiality_dict = {}
++     for the_component in the_components:
++         component_index = cobra_model.reactions.index(the_component)
++-        tmp_lb = float(cobra_model.lower_bounds[component_index])
++-        cobra_model.reactions[component_index].lower_bound = cobra_model.lower_bounds[component_index] = 0
+++        tmp_lb = float(cobra_model.reactions[component_index].lower_bound)
+++        cobra_model.reactions[component_index].lower_bound = 0
++         if method.lower() == 'fba':
++             cobra_model.optimize(solver=solver, the_problem=the_problem)
++             objective_value = cobra_model.solution.f
++         elif method.lower() == 'moma':
++            objective_value = moma(wt_model, cobra_model, solver=solver)['objective_value'] 
++         essentiality_dict[the_component] = objective_value
++-        cobra_model.reactions[component_index].lower_bound = cobra_model.lower_bounds[component_index] = tmp_lb
+++        cobra_model.reactions[component_index].lower_bound = tmp_lb
++     if the_condition:
++         essentiality_dict['the_condition'] = the_condition
++     return(essentiality_dict)
++Index: cobra/flux_analysis/__init__.py
++===================================================================
++--- cobra/flux_analysis/__init__.py	(revision 330)
+++++ cobra/flux_analysis/__init__.py	(working copy)
++@@ -1,19 +1,27 @@
+++try:
+++    from essentiality import *
+++    from variability import *
+++    from single_deletion import single_deletion
+++except Exception, e:
+++    from warnings import warn
+++    warn("essentiality is not accessible: %s"%e)
+++
++ from os import name as __name
++-from sys import modules as __modules
++ from warnings import warn
++ if __name == 'java':
++-    warn("%s is not yet supported on jython"%__modules[__name__])
++-
+++    warn('double_deletion functions and moma are not yet supported on %s'%__name)
++ else:
++-    from ..solvers import *
++-    from essentiality import *
++-    from variability import *
++-    from single_deletion import single_deletion
++-    from double_deletion import double_deletion, double_deletion_parallel
++-del __name, __modules
+++    try:
+++        from double_deletion import double_deletion, double_deletion_parallel
+++    except Exception, e:
+++        from warnings import warn
+++        warn("double_deletion is not accessible: %s"%e)
++ 
+++    
++ 
++ 
++ 
++ 
++ 
+++
+++
++Index: cobra/flux_analysis/variability.py
++===================================================================
++--- cobra/flux_analysis/variability.py	(revision 330)
+++++ cobra/flux_analysis/variability.py	(working copy)
++@@ -1,8 +1,7 @@
+++from __future__ import with_statement
++ #cobra.flux_analysis.variablity.py
++ #runs flux variablity analysis on a Model object.
++ from math import floor,ceil
++-from numpy import hstack,zeros
++-from scipy import sparse
++ from copy import deepcopy
++ from ..core.Metabolite import Metabolite
++ try:
++@@ -15,7 +14,10 @@
++     """Provides an interface to call flux_variability_analysis from ppmap
++     
++     """
++-    from cPickle import dump
+++    try:
+++        from cPickle import dump
+++    except:
+++        from pickle import dump
++     from .variability import flux_variability_analysis
++     results_dict = {}
++     new_objective = keywords.pop('new_objective')
++@@ -226,7 +228,10 @@
++     
++     """
++     from test import salmonella_pickle
++-    from cPickle import load
+++    try:
+++        from cPickle import load
+++    except:
+++        from pickle import load
++     with open(salmonella_pickle) as in_file:
++         cobra_model = load(in_file)
++     fva_out =  flux_variability_analysis(cobra_model,
++Index: cobra/flux_analysis/single_deletion.py
++===================================================================
++--- cobra/flux_analysis/single_deletion.py	(revision 330)
+++++ cobra/flux_analysis/single_deletion.py	(working copy)
++@@ -1,11 +1,19 @@
+++from __future__ import with_statement
++ #cobra.flux_analysis.single_deletion.py
++ #run single gene or reaction deletions on the model
++-from numpy import nan
+++nan = float('nan')
++ from time import time
+++from warnings import warn
++ from copy import deepcopy
++ from ..manipulation import initialize_growth_medium
++ from ..manipulation import delete_model_genes, undelete_model_genes
++-from .moma import moma
+++from os import name as __name
+++if __name == 'java':
+++    warn("moma is not supported on %s"%__name)
+++    def moma(**kwargs):
+++        warn("moma is not supported on %s"%__name)
+++else:
+++    from .moma import moma    
++ def single_deletion(cobra_model, element_list=None,
++                     method='fba', the_problem='return',
++                     element_type='gene', solver='glpk',
++Index: cobra/__init__.py
++===================================================================
++--- cobra/__init__.py	(revision 330)
+++++ cobra/__init__.py	(working copy)
++@@ -6,9 +6,10 @@
++     #"not yet ready for prime time.")
++     import oven.danielhyduke.jython.numpy as numpy
++     import oven.danielhyduke.jython.scipy as scipy
++-    from core import Object, Formula, Metabolite, Gene, Reaction, Model
+++    from core import Object, Formula, Metabolite, Gene, Reaction, Model, DictList
++ else:
++-    from core import *
+++    #from core import *
+++    from core import Object, Formula, Metabolite, Gene, Reaction, Model, DictList
++ del __name
++ __doc__ = """
++ """
++Index: cobra/core/ArrayBasedModel.py
++===================================================================
++--- cobra/core/ArrayBasedModel.py	(revision 330)
+++++ cobra/core/ArrayBasedModel.py	(working copy)
++@@ -114,6 +114,7 @@
++ 
++         """
++         Model.add_metabolites(metabolite_list)
+++        self.constraint_sense = [x._constraint_sense for x in self.metabolites]
++         if self.S is not None and expand_stoichiometric_matrix:
++             s_expansion = len(self.metabolites) - self.S.shape[0]
++             if s_expansion > 0:
++@@ -210,6 +211,7 @@
++         self.lower_bounds = array(lower_bounds)
++         self.upper_bounds = array(upper_bounds)
++         self.objective_coefficients = array(objective_coefficients)
+++
++     def _update_metabolite_vectors(self):
++         """regenerates _b and _constraint_sense
++ 
++@@ -223,10 +225,9 @@
++         [(_b.append(x._bound),
++           _constraint_sense.append(x._constraint_sense))
++          for x in self.metabolites]
++-        self._b = array(_b)
++-        self._constraint_sense = _constraint_sense
+++        self.b = array(_b)
+++        self.constraint_sense = _constraint_sense
++          
++-
++     def _update_matrices(self, reaction_list=None):
++         """
++         reaction_list: None or a list of cobra.Reaction objects that are in
++Index: cobra/core/__init__.py
++===================================================================
++--- cobra/core/__init__.py	(revision 330)
+++++ cobra/core/__init__.py	(working copy)
++@@ -8,6 +8,9 @@
++ from .Model import Model 
++ from os import name as __name
++ if __name != 'java':
++-    from .ArrayBasedModel import ArrayBasedModel 
+++    try:
+++        from .ArrayBasedModel import ArrayBasedModel 
+++    except Exception, e:
+++        from warnings import warn
+++        warn("ArrayBasedModel is not accessible: %s"%e)
++ 
++-
++Index: cobra/core/Model.py
++===================================================================
++--- cobra/core/Model.py	(revision 330)
+++++ cobra/core/Model.py	(working copy)
++@@ -180,8 +180,10 @@
++             self.reactions[reaction_index] = the_reaction
++ 
++     def update(self):
+++        """Non functional.  Model.update is moved to ArrayBasedModel.  Please use
+++        the to_array_based_model property to create an ArrayBasedModel.
+++        
++         """
++-        """
++         raise Exception("Model.update is moved to ArrayBasedModel.  Please use \n"
++                         "the to_array_based_model property to create an ArrayBasedModel.")
++                      
++Index: cobra/core/Reaction.py
++===================================================================
++--- cobra/core/Reaction.py	(revision 330)
+++++ cobra/core/Reaction.py	(working copy)
++@@ -2,6 +2,9 @@
++ #######################
++ #BEGIN Class Reaction
++ #
+++#Is it better to restrict a Reaction to a single model or
+++#should we allow a Reaction to be associated with multiple models?
+++#
++ from collections import defaultdict
++ import re
++ from copy import deepcopy
++@@ -62,13 +65,22 @@
++         [x._reaction.add(self) for x in self._metabolites]
++         [x._reaction.add(self) for x in self._genes]
++ 
+++    def get_model(self):
+++        """Returns the Model object that this Reaction is associated with.
+++
+++        """
+++        return self._model
+++        
+++
++     def remove_from_model(self, model=None):
++         """Removes the association
++ 
++         model: cobra.Model object.  remove the reaction from this model.
++         
++         """
++-        # why is model being taken in as a parameter?
+++        # why is model being taken in as a parameter? This plays
+++        #back to the question of allowing a Metabolite to be associated
+++        #with multiple Models
++         if model != self._model and model is not None:
++             raise Exception('%s not in %s ergo it cannot be removed. (%s)'%(self,
++                                                                   model,
++@@ -133,6 +145,7 @@
++         new_reaction = deepcopy(self)
++         ## self._model = the_model
++         return new_reaction
+++
++     def guided_copy(self, the_model, metabolite_dict, gene_dict=None):
++         """Trying to make a faster copy procedure for cases where large
++         numbers of metabolites might be copied.  Such as when copying reactions.
++@@ -259,7 +272,13 @@
++         return [k for k, v in self._metabolites.items()
++                 if v > 0]
++ 
+++    def get_gene(self):
+++        """Return a list of reactants for the reaction.
++ 
+++        """
+++        return self._genes.keys()
+++
+++
++     def get_coefficient(self, the_metabolite):
++         """Return the stoichiometric coefficient for a metabolite in
++         the reaction.
++Index: cobra/core/Metabolite.py
++===================================================================
++--- cobra/core/Metabolite.py	(revision 330)
+++++ cobra/core/Metabolite.py	(working copy)
++@@ -2,6 +2,9 @@
++ #######################
++ #BEGIN Class Metabolite
++ #
+++#Is it better to restrict a Metabolite to a single model or
+++#should we allow a Metabolite to be associated with multiple models?
+++#
++ from copy import deepcopy
++ import re
++ from .Formula import Formula
++@@ -10,7 +13,7 @@
++     """Metabolite is a class for holding information regarding
++     a metabolite in a cobra.Reaction object.
++ 
++-    TODO: Clean up.  Allow for creation of empty metabolite
+++        
++     """
++     ## __slots__ = ['id', 'formula', 'name', 'compartment',
++     ##              'charge']
++@@ -18,6 +21,7 @@
++     ##    from cobra.core.Metabolite import Metabolite
++     ##    Object.__setstate__(self, the_dict)
++     ##    [self.__setattr__(k, v) for k, v in the_dict]
+++
++     def __init__(self, id=None, formula=None,
++                  name=None, compartment=None):
++         """
++@@ -60,6 +64,7 @@
++         state = Object.__getstate__(self)
++         state['_reaction'] = set()
++         return state
+++
++     def parse_composition(self):
++         """Breaks the chemical formula down by element.
++         Useful for making sure Reactions are balanced.'
++@@ -80,6 +85,7 @@
++         """
++         new_metabolite = deepcopy(self)
++         return new_metabolite
+++
++     def guided_copy(self, the_model):
++         """Trying to make a faster copy procedure for cases where large
++         numbers of metabolites might be copied.  Such as when copying reactions.
++@@ -91,15 +97,35 @@
++         the_copy._model = the_model
++         the_copy._reaction = set()
++         return(the_copy)
++-    
++-    def remove_from_model(self, model=None):
+++
+++    def get_model(self):
+++        """Returns the Model object that contain this Object
+++
+++        """
+++        return self._model
+++
+++    def get_reaction(self):
+++        """Returns a list of Reactions that contain this Object
+++
+++        """
+++        return list(self._reaction)
+++
+++    def remove_from_model(self, model=None, method='subtractive'):
++         """Removes the association
++ 
++-        model: :class:`~cobra.core.Model` object.
+++        model: None or :class:`~cobra.core.Model` object.
++             Remove the reaction from this model.
+++
+++        method: 'subtractive' or 'destructive'.  If 'subtractive' then
+++        the metabolite is removed from all associated reactions.  If
+++        'destructive' then all associated reactions are removed from the Model.
+++
+++    
++         
++         """
++-        # why is model being taken in as a parameter?
+++        # why is model being taken in as a parameter? This plays
+++        #back to the question of allowing a Metabolite to be associated
+++        #with multiple Models
++         if model != self._model and model is not None:
++             raise Exception('%s not in %s ergo it cannot be removed. (%s)'%(self,
++                                                                   model,
++@@ -107,11 +133,16 @@
++                                                             
++         self._model.metabolites.remove(self)
++         self._model = None
++-        for the_reaction in self._reaction:
++-            the_coefficient = the_reaction._metabolites[self]
++-            the_reaction.subtract_metabolites({self: the_coefficient})
+++        if method.lower() == 'subtractive':
+++            for the_reaction in self._reaction:
+++                the_coefficient = the_reaction._metabolites[self]
+++                the_reaction.subtract_metabolites({self: the_coefficient})
+++        elif method.lower() == 'destructive':
+++            [x.remove_from_model() for x in self._reaction()]
+++        else:
+++            raise Exception("method for remove_from_model must be 'subtractive' " +\
+++                            "or 'destructive'.  You entered: '%s'"%method)
++ 
++-
++ #
++ #END Class Metabolite
++ ########################
++Index: cobra/core/Object.py
++===================================================================
++--- cobra/core/Object.py	(revision 330)
+++++ cobra/core/Object.py	(working copy)
++@@ -14,6 +14,7 @@
++         #formatting notes and annotation
++         self.notes = {}
++         self.annotation = {}
+++
++     def __getstate__(self):
++         """To prevent excessive replication during deepcopy.
++         """
++@@ -21,6 +22,7 @@
++         if '_model' in state:
++             state['_model'] = None
++         return state
+++    
++     def guided_copy(self):
++         """Trying to make a faster copy procedure for cases where large
++         numbers of metabolites might be copied.  Such as when copying reactions.
++@@ -32,6 +34,7 @@
++         [setattr(the_copy, k, v)
++          for k, v in self.__dict__.iteritems()]
++         return(the_copy)
+++
++     ## def __setstate__(self, state):
++     ##     self.__dict__.update(state)
++     ## def __getstate__(self):
++@@ -45,6 +48,7 @@
++     #Not the best idea.  This will be removed in the next major
++     #release
++     #
+++
++     def __lt__(self, other):
++         if hasattr(other, 'id'):
++             x = self.id < other.id
++Index: cobra/solvers/glpk.py
++===================================================================
++--- cobra/solvers/glpk.py	(revision 330)
+++++ cobra/solvers/glpk.py	(working copy)
++@@ -1,84 +0,0 @@
++-"""bindings to the glpk solver through pyglpk"""
++-# because both this module and the library are named glpk
++-from __future__ import absolute_import
++-from glpk import LPX
++-
++-from ..core.Solution import Solution
++-
++-
++-# mappers from cobra representation to glpk
++-variable_kind_dict = {
++-    'continuous': float,
++-    'integer': int}
++-# mappers from glpk representations to cobra
++-status_dict = {
++-    'opt': 'optimal',
++-    'nofeas': 'infeasible',
++-    'unbnd': 'unbounded'}
++-
++-
++-def create_problem(cobra_model, objective_sense="maximize", lp=None):
++-    if lp is None:
++-        lp = LPX()  # Create empty problem instance
++-        lp.name = cobra_model.id
++-        lp.rows.add(len(cobra_model.metabolites))
++-        lp.cols.add(len(cobra_model.reactions))
++-
++-    if objective_sense == 'maximize':
++-        lp.obj.maximize = True
++-    elif objective_sense == 'minimize':
++-        lp.obj.maximize = False
++-    else:
++-        raise ValueError("objective_sense not 'maximize' or 'minimize'")
++-
++-    # create metabolites/constraints as rows
++-    for i, r in enumerate(lp.rows):
++-        metabolite = cobra_model.metabolites[i]
++-        r.name = metabolite.id
++-        b = float(metabolite._bound)
++-        c = metabolite._constraint_sense
++-        # constraint sense is set by changing the bounds
++-        if c == 'E':
++-            r.bounds = (b, b)
++-        elif c == 'L':
++-            r.bounds = (None, b)
++-        elif c == 'G':
++-            r.bounds = (b, None)
++-        else:
++-            raise ValueError("%s is not a valid constraint_sense" % c)
++-
++-    # create reactions/variables as columns
++-    for i, c in enumerate(lp.cols):
++-        reaction = cobra_model.reactions[i]
++-        c.name = reaction.id
++-        c.kind = variable_kind_dict[reaction.variable_kind]
++-        c.bounds = (reaction.lower_bound, reaction.upper_bound)
++-        lp.obj[i] = float(reaction.objective_coefficient)
++-
++-    # create S matrix
++-    lp.matrix = [(int(i), int(j), c) \
++-        for (i, j), c in cobra_model.to_array_based_model().S.todok().iteritems()]
++-    return lp
++-
++-
++-def solve_problem(lp):
++-    lp.simplex()
++-    try:
++-        status = status_dict[lp.status]
++-    except:
++-        status = "unknown error: " + str(lp.status)
++-    solution = Solution(status)
++-    solution.status = status
++-    if status == 'optimal':
++-        solution.objective_value = lp.obj.value
++-        solution.x_dict = dict((c.name, c.primal) for c in lp.cols)
++-        # return the duals as well as the primals for LPs
++-        if lp.kind == "float":
++-            solution.y_dict = dict((c.name, c.dual) for c in lp.cols)
++-        else:
++-            solution.y_dict = None
++-    return solution
++-
++-
++-def solve(cobra_model, objective_sense="maximize", **kwargs):
++-    return solve_problem(create_problem(cobra_model, objective_sense))
++Index: cobra/solvers/__init__.py
++===================================================================
++--- cobra/solvers/__init__.py	(revision 330)
+++++ cobra/solvers/__init__.py	(working copy)
++@@ -2,104 +2,101 @@
++ from os import name as __name
++ from sys import modules as __modules
++ from warnings import warn
++-if __name == 'java':
++-    #warn("%s is not yet supported on jython"%__modules[__name__])
++-    def optimize():
++-        print "No solvers for jython yet"
++-else:
++-    __legacy_solver = True
++-    solver_dict = {}
++-    if __legacy_solver:
++-        from .legacy import _optimize_glpk, _optimize_gurobi, _optimize_cplex
++-        solver_dict = {'glpk': _optimize_glpk,
++-                       'gurobi': _optimize_gurobi,
++-                       'cplex': _optimize_cplex}
++-        for solver_module in ['glpk', 'cplex']:
++-            try:
++-                exec('from %s import *'%solver_module)
++-            except:
++-                solver_dict.pop(solver_module)
++-        try:
++-            from gurobipy import *
++-        except:
++-            solver_dict.pop('gurobi')
++ 
+++__legacy_solver = False
+++solver_dict = {}
+++if __legacy_solver:
+++    from .legacy import _optimize_glpk, _optimize_gurobi, _optimize_cplex
+++    package_dict = {'glpk': 'from glpk import LPX',
+++                    'cplex': 'from cplex import Cplex',
+++                    'gurobi': 'from gurobipy import Model'}
+++    if __name == 'java':
+++        from .legacy_jython import _optimize_glpk
+++        package_dict['glpk'] = 'from org.gnu.glpk import GLPK'
+++        package_dict['gurobi'] = 'from gurobi import GRBModel'
++ 
++-    else:
++-        from os import listdir as _listdir
++-        from os import path as _path
++-        for i in _listdir(_path.split(_path.abspath(__file__))[0]):
++-            if i.startswith("_") or i.startswith("."):
++-                continue
++-            if not i.endswith(".py"):
++-                continue
++-            try:
++-                m = i.strip(".py")
++-                exec("from . import %s" % m)
++-                solver_dict[m] = eval(m)
++-            except Exception, e:
++-                pass
++-        del _path
++-        del _listdir
++-        del i
++-        m = None
++-        del m
++ 
++-    def optimize(cobra_model, solver='glpk', error_reporting=False, **kwargs):
++-        """Wrapper to optimization solvers
+++    solver_dict = {'glpk': _optimize_glpk,
+++                   'gurobi': _optimize_gurobi,
+++                   'cplex': _optimize_cplex}
++ 
+++    for solver_name, solver_import in package_dict.iteritems():
+++        try:
+++            exec(solver_import)
+++        except Exception, e:
+++            #print e
+++            solver_dict.pop(solver_name)
+++else:
+++    from os import listdir as _listdir
+++    from os import path as _path
+++    for i in _listdir(_path.split(_path.abspath(__file__))[0]):
+++        if i.startswith("_") or i.startswith(".") or i == 'legacy.py':
+++            continue
+++        if not i.endswith(".py"):
+++            continue
+++        try:
+++            m = i.strip(".py")
+++            exec("from . import %s" % m)
+++            solver_name = m
+++            if solver_name.endswith('_solver'):
+++                solver_name = solver_name[:-len('_solver')]
+++            solver_dict[solver_name] = eval(m)
+++        except Exception, e:
+++            pass
+++    del _path
+++    del _listdir
+++    del i
+++    m = None
+++    del m
++ 
++-        """
++-        #If the default solver is not installed then use one of the others
+++def optimize(cobra_model, solver='glpk', error_reporting=True, **kwargs):
+++    """Wrapper to optimization solvers
+++
+++
+++    """
+++    #If the default solver is not installed then use one of the others
+++    try:
+++        solver_function = solver_dict[solver]
+++    except:
++         try:
++-            solver_function = solver_dict[solver]
+++            solver, solver_function = solver_dict.items()[0]
++         except:
++-            try:
++-                solver, solver_function = solver_dict.items()[0]
++-            except:
++-                raise Exception("It appears that you do not have one of the supported solvers "+\
++-                                "(glpk, gurobi, or cplex) installed")
++-        the_solution = None
++-        if __legacy_solver:
++-            def solve_problem(solver_function, kwargs):
++-                return solver_function(cobra_model, **kwargs)
++-            try:
++-                the_solution = solve_problem(solver_function, kwargs)
++-            except Exception, e:
++-                if error_reporting:
++-                    print e
++-                    print '%s did not work'%solver
++-                solver_keys = solver_dict.keys()
++-                solver_keys.remove(solver)
++-                for solver in solver_keys:
++-                    solver_function = solver_dict[solver]
++-                    try:
++-                        if error_reporting:
++-                            print "now trying %s"%solver
++-                        the_solution = solve_problem(solver_function, kwargs)
++-                        break
++-                    except Exception, e:
++-                        if error_reporting:
++-                            print e
++-                            print '%s did not work'%solver
++-                        continue
+++            raise Exception("It appears that you do not have one of the supported solvers "+\
+++                            "(glpk, gurobi, or cplex) installed")
+++    the_solution = None
+++    if __legacy_solver:
+++        def solve_problem(solver_function, kwargs):
+++            return solver_function(cobra_model, **kwargs)
+++        try:
+++            the_solution = solve_problem(solver_function, kwargs)
+++        except Exception, e:
+++            if error_reporting:
+++                print e
+++                print '%s did not work'%solver
+++            solver_keys = solver_dict.keys()
+++            solver_keys.remove(solver)
+++            for solver in solver_keys:
+++                solver_function = solver_dict[solver]
+++                try:
+++                    if error_reporting:
+++                        print "now trying %s"%solver
+++                    the_solution = solve_problem(solver_function, kwargs)
+++                    break
+++                except Exception, e:
+++                    if error_reporting:
+++                        print e
+++                        print '%s did not work'%solver
+++                    continue
++ 
++-        else:
++-            the_solution = solver_function.solve(cobra_model, **kwargs)
++-            #raise Exception("New style solvers not yet fully implemented")
+++    else:
+++        the_solution = solver_function.solve(cobra_model, **kwargs)
+++        #raise Exception("New style solvers not yet fully implemented")
++ 
++ 
++-        #Add the solution to the model.
++-        #Please note that it will be faster to dress the reactions and metabolites
++-        #with their values within the new style solvers instead of here.
++-        if the_solution is None:
++-            cobra_model.solution = the_solution
++-            return(the_solution)
++-        else:
++-            if __legacy_solver:
++-                cobra_model.solution = the_solution['the_solution']
++-                return(the_solution['the_problem'])
++-            else:
++-                cobra_model.solution = the_solution
+++    #Add the solution to the model.
+++    #if the_solution is None:
+++    #   return(the_solution)
+++    #else:
+++    return(the_solution['the_problem'])
++ 
++-del __name, __modules
+++del __name
++Index: cobra/solvers/gurobi_solver.py
++===================================================================
++--- cobra/solvers/gurobi_solver.py	(revision 0)
+++++ cobra/solvers/gurobi_solver.py	(revision 0)
++@@ -0,0 +1,306 @@
+++##cobra.solvers.gurobi_solver
+++#Interface to the gurobi 5.0.1 python and java solvers
+++#QPs are not yet supported on java
+++from __future__ import absolute_import
+++from warnings import warn
+++from os import name as __name
+++from copy import deepcopy
+++###solver specific parameters
+++from .parameters import status_dict, variable_kind_dict, \
+++     sense_dict, parameter_mappings, parameter_defaults, \
+++     objective_senses, default_objective_sense
+++
+++from ..core.Solution import Solution
+++from ..flux_analysis.objective import update_objective
+++from time import time
+++solver_name = 'gurobi'
+++objective_senses = objective_senses[solver_name]
+++parameter_mappings = parameter_mappings[solver_name]
+++parameter_defaults = parameter_defaults[solver_name]
+++#Functions that are different for java implementation of a solver
+++if __name == 'java':
+++    ## from jarray import array as j_array
+++    ## def array(x, variable_type='d'):
+++    ##     return j_array(x, variable_type)
+++
+++    from gurobi import GRB
+++    variable_kind_dict = eval(variable_kind_dict[solver_name])
+++    status_dict = eval(status_dict[solver_name])
+++
+++    from gurobi import GRBModel, GRBEnv
+++    from gurobi import GRBLinExpr
+++    from gurobi import GRBQuadExpr as QuadExpr
+++    __solver_class = GRBModel
+++    #TODO: Create a pythonesqe class similar to in glpk_solver
+++    def Model(name=''):
+++        grb_environment = GRBEnv(name)
+++        tmp_model = GRBModel(grb_environment)
+++        return tmp_model
+++    def LinExpr(coefficients, variables):
+++        coefficients, variables = map(list, [coefficients, variables])
+++        tmp_expression = GRBLinExpr()
+++        tmp_expression.addTerms(coefficients, variables)
+++        return tmp_expression
+++
+++    def get_status(lp):
+++        status = lp.get(GRB.IntAttr.Status)
+++        if status in status_dict:
+++            status = status_dict[status]
+++        else:
+++            status = 'failed'
+++        return status
+++
+++    def set_parameter(lp, parameter_name, parameter_value):
+++        """Sets model parameters and attributes.
+++        
+++        """
+++        grb_environment = lp.getEnv()
+++        try:
+++            if hasattr(GRB.DoubleParam, parameter_name):
+++                grb_environment.set(eval('GRB.DoubleParam.%s'%parameter_name),
+++                                         parameter_value)
+++            elif hasattr(GRB.IntParam, parameter_name):
+++                grb_environment.set(eval('GRB.IntParam.%s'%parameter_name),
+++                                         parameter_value)
+++            elif hasattr(GRB.StringParam, parameter_name):
+++                grb_environment.set(eval('GRB.StringParam.%s'%parameter_name),
+++                                    parameter_value)
+++            elif hasattr(GRB.IntAttr, parameter_name):
+++                if parameter_name == 'ModelSense':
+++                    parameter_value = objective_senses[parameter_value]
+++                lp.set(eval('GRB.IntAttr.%s'%parameter_name),
+++                                    parameter_value)
+++            else:
+++                warn("%s is not a DoubleParam, IntParam, StringParam, IntAttr"%parameter_name)
+++                ## raise Exception("%s is not a DoubleParam, IntParam, StringParam, IntAttr"%parameter_name)
+++        except Exception, e:
+++            warn("%s %s didn't work %s"%(parameter_name, parameter_value, e))
+++
+++    def format_solution(lp, cobra_model, **kwargs):
+++        """
+++        """
+++        status = get_status(lp)
+++        if status != 'optimal':
+++            the_solution = Solution(None, status=status)
+++        else:
+++            x_dict = dict(((v.get(GRB.StringAttr.VarName),
+++                            v.get(GRB.DoubleAttr.X))
+++                           for v in lp.getVars()))
+++            x = [x_dict[v.id] for v in cobra_model.reactions]
+++            objective_value = lp.get(GRB.DoubleAttr.ObjVal)
+++            if lp.get(GRB.IntAttr.IsMIP) != 0:
+++                y = y_dict = None #MIP's don't have duals
+++            else:
+++                y_dict = dict(((c.get(GRB.StringAttr.ConstrName), c.get(GRB.DoubleAttr.Pi))
+++                              for c in lp.getConstrs()))
+++                y = list([y_dict[v.id] for v in cobra_model.metabolites])
+++            the_solution = Solution(objective_value, x=x, x_dict=x_dict, y=y,
+++                                    y_dict=y_dict, status=status)
+++        return(the_solution)
+++
+++else:
+++    ## from numpy import array
+++    from gurobipy import Model, LinExpr, GRB, QuadExpr
+++    variable_kind_dict = eval(variable_kind_dict[solver_name])
+++    status_dict = eval(status_dict[solver_name])
+++    __solver_class = Model
+++    def get_status(lp):
+++        status = lp.status
+++        if status in status_dict:
+++            status = status_dict[status]
+++        else:
+++            status = 'failed'
+++        return status
+++
+++    def format_solution(lp, cobra_model, **kwargs):
+++        status = get_status(lp)
+++        if status != 'optimal':
+++            the_solution = Solution(None, status=status)
+++        else:
+++            objective_value = lp.ObjVal            
+++            x_dict = dict(((v.VarName, v.X)
+++                           for v in lp.getVars()))
+++            x = [x_dict[v.id] for v in cobra_model.reactions]
+++            if lp.isMIP:
+++                y = y_dict = None #MIP's don't have duals
+++            else:
+++                y_dict = dict(((c.ConstrName, c.Pi)
+++                              for c in lp.getConstrs()))
+++                y = list([y_dict[v.id] for v in cobra_model.metabolites])
+++            the_solution = Solution(objective_value, x=x, x_dict=x_dict, y=y,
+++                                    y_dict=y_dict, status=status)
+++        return(the_solution)
+++
+++    def set_parameter(lp, parameter_name, parameter_value):
+++        if parameter_name == 'ModelSense':
+++            lp.setAttr(parameter_name, objective_senses[parameter_value])
+++        else:
+++            lp.setParam(parameter_name, parameter_value)
+++
+++
+++
+++
+++###
+++sense_dict = eval(sense_dict[solver_name])
+++def create_problem(cobra_model,  **kwargs):
+++    """Solver-specific method for constructing a solver problem from
+++    a cobra.Model.  This can be tuned for performance using kwargs
+++
+++
+++    """
+++    lp = Model("")
+++    #Silence the solver
+++    set_parameter(lp, 'OutputFlag', 0)
+++
+++    the_parameters = parameter_defaults
+++    if kwargs:
+++        the_parameters = deepcopy(parameter_defaults)
+++        the_parameters.update(kwargs)
+++
+++    [set_parameter(lp, parameter_mappings[k], v)
+++         for k, v in the_parameters.iteritems() if k in parameter_mappings]
+++    quadratic_component = the_parameters['quadratic_component']
+++    objective_sense = objective_senses[the_parameters['objective_sense']]
+++
+++
+++    # Create variables
+++    #TODO:  Speed this up
+++    variable_list = [lp.addVar(float(x.lower_bound),
+++                               float(x.upper_bound),
+++                               float(x.objective_coefficient),
+++                               variable_kind_dict[x.variable_kind],
+++                               x.id)
+++                     for x in cobra_model.reactions]
+++    reaction_to_variable = dict(zip(cobra_model.reactions,
+++                                    variable_list))
+++    # Integrate new variables
+++    lp.update()
+++    #Set objective to quadratic program
+++    if quadratic_component is not None:
+++        if not hasattr(quadratic_component, 'todok'):
+++            raise Exception('quadratic component must have method todok')
+++
+++        quadratic_objective = QuadExpr()
+++        for (index_0, index_1), the_value in quadratic_component.todok().items():
+++            quadratic_objective.addTerms(the_value,
+++                                   variable_list[index_0],
+++                                   variable_list[index_1])
+++        #Does this override the linear objective coefficients or integrate with them?
+++        lp.setObjective(quadratic_objective, sense=objective_sense)
+++    #Constraints are based on mass balance
+++    #Construct the lin expression lists and then add
+++    #TODO: Speed this up as it takes about .18 seconds
+++    #HERE
+++    for the_metabolite in cobra_model.metabolites:
+++        constraint_coefficients = []
+++        constraint_variables = []
+++        for the_reaction in the_metabolite._reaction:
+++            constraint_coefficients.append(the_reaction._metabolites[the_metabolite])
+++            constraint_variables.append(reaction_to_variable[the_reaction])
+++        #Add the metabolite to the problem
+++        lp.addConstr(LinExpr(constraint_coefficients, constraint_variables),
+++                     sense_dict[the_metabolite._constraint_sense.upper()],
+++                     the_metabolite._bound,
+++                     the_metabolite.id)
+++
+++
+++
+++    return(lp)
+++###
+++def update_problem(lp, cobra_model, **kwargs):
+++    """A performance tunable method for updating a model problem file
+++
+++    lp: A gurobi problem object
+++
+++    cobra_model: the cobra.Model corresponding to 'lp'
+++
+++    """
+++    #When reusing the basis only assume that the objective coefficients or bounds can change
+++    try:
+++        quadratic_component = kwargs['quadratic_component']
+++        if quadratic_component is not None:
+++            warn("update_problem does not yet take quadratic_component as a parameter")
+++    except:
+++        quadratic_component = None
+++ 
+++    if 'copy_problem' in kwargs and kwargs['copy_problem']:
+++        lp = lp.copy()
+++    if 'reuse_basis' in kwargs and not kwargs['reuse_basis']:
+++        lp.reset()
+++    for the_variable, the_reaction in zip(lp.getVars(),
+++                                          cobra_model.reactions):
+++        the_variable.lb = float(the_reaction.lower_bound)
+++        the_variable.ub = float(the_reaction.upper_bound)
+++        the_variable.obj = float(the_reaction.objective_coefficient)
+++
+++###
+++def solve_problem(lp, **kwargs):
+++    """A performance tunable method for updating a model problem file
+++
+++    """
+++    #Update parameter settings if provided
+++    if kwargs:
+++        [set_parameter(lp, parameter_mappings[k], v)
+++         for k, v in kwargs.iteritems() if k in parameter_mappings]
+++
+++    try:
+++        print_solver_time = kwargs['print_solver_time']
+++        start_time = time()
+++    except:
+++        print_solver_time = False
+++    lp.update()
+++    #Different methods to try if lp_method fails
+++    the_methods = [0, 2, 1]
+++    lp.optimize()
+++    status = get_status(lp)
+++    if status != 'optimal':
+++        #Try to find a solution using a different method
+++        set_parameter(lp, parameter_mappings['tolerance_markowitz'], 1e-2)
+++        for the_method in the_methods:
+++            set_parameter(lp, parameter_mappings['lp_method'], the_method)
+++            lp.optimize()
+++            status = get_status(lp)
+++            if status == 'optimal':
+++                break
+++
+++    if print_solver_time:
+++        print 'optimize time: %f'%(time() - start_time)
+++    return status
+++
+++    
+++def solve(cobra_model, **kwargs):
+++    """
+++
+++    """
+++        #Update objectives if they are new.
+++    if 'new_objective' in kwargs and \
+++           kwargs['new_objective'] not in ['update problem', None]:
+++       update_objective(cobra_model, kwargs['new_objective'])
+++
+++    if 'the_problem' in kwargs:
+++        the_problem = kwargs['the_problem']
+++    else:
+++        the_problem = None
+++    if 'error_reporting' in kwargs:
+++        error_reporting = kwargs['error_reporting']
+++    else:
+++        error_reporting = False
+++
+++    if isinstance(the_problem, __solver_class):
+++        #Update the problem with the current cobra_model
+++        lp = the_problem
+++        update_problem(lp, cobra_model, **kwargs)
+++    else:
+++        #Create a new problem
+++        lp = create_problem(cobra_model, **kwargs)
+++    #Deprecated way for returning a solver problem created from a cobra_model
+++    #without performing optimization
+++    if the_problem == 'setup':
+++            return lp
+++    status = solve_problem(lp)
+++    the_solution = format_solution(lp, cobra_model)
+++    if status != 'optimal' and error_reporting:
+++        print '%s failed: %s'%(solver_name, status)
+++    cobra_model.solution = the_solution
+++    solution = {'the_problem': lp, 'the_solution': the_solution}
+++    return solution
++Index: cobra/solvers/parameters.py
++===================================================================
++--- cobra/solvers/parameters.py	(revision 0)
+++++ cobra/solvers/parameters.py	(revision 0)
++@@ -0,0 +1,125 @@
+++#This centralizes some of the common elements that are differently named across solvers.
+++#These are stored as strings here to prevent problems associated with calling
+++#solver objects for solver packages that aren't available
+++from copy import deepcopy
+++__objective_sense_cplex = {'maximize': 'Cplex.objective.sense.maximize',
+++                           'minimize': 'Cplex.objective.sense.maximize'}
+++__objective_sense_glpk = {'maximize': True,
+++                          'minimize': False}
+++__objective_sense_glpk_java = {'maximize': 'GLPKConstants.GLP_MAX',
+++                               'minimize': 'GLPKConstants.GLP_MIN'}
+++__objective_sense_gurobi = {'maximize': -1,
+++                            'minimize': 1}
+++objective_senses = {'cplex': __objective_sense_cplex,
+++                    'glpk': __objective_sense_glpk,
+++                    'glpk_java': __objective_sense_glpk_java,
+++                    'gurobi': __objective_sense_gurobi}
+++default_objective_sense = 'maximize'
+++#Mappings from solver-specific status values to cobra pie status values
+++## __status_cplex = "{Cplex.solution.status.MIP_infeasible: 'infeasible', " +\
+++##                  "Cplex.solution.status.MIP_optimal: 'optimal', " +\
+++##                  "Cplex.solution.status.MIP_optimal_tolerance: 'optimal'," +\
+++##                  "Cplex.solution.status.MIP_unbounded:  'unbounded', "+\
+++##                  "Cplex.solution.status.infeasible: 'infeasible', " +\
+++##                  "Cplex.solution.status.optimal: 'optimal',  " +\
+++##                  "Cplex.solution.status.optimal_tolerance: 'optimal', " +\
+++##                  "Cplex.solution.status.unbounded: 'unbounded', }"
+++__status_cplex = "{'MIP_infeasible': 'infeasible', 'integer optimal solution': 'optimal', " +\
+++                  "'MIP_optimal_tolerance': 'optimal',  'MIP_unbounded':  'unbounded', "+\
+++                  "'infeasible': 'infeasible', 'optimal': 'optimal',  " +\
+++                  "'optimal_tolerance': 'optimal', 'unbounded': 'unbounded' }"
+++
+++__status_glpk = "{'opt': 'optimal', 'nofeas': 'infeasible', 'unbnd': 'unbounded'}"
+++__status_glpk_java = "{GLPKConstants.GLP_OPT: 'optimal', GLPKConstants.GLP_FEAS: 'feasible', GLPKConstants.GLP_INFEAS: 'infeasible', GLPKConstants.GLP_NOFEAS: 'infeasible', GLPKConstants.GLP_UNBND: 'unbounded', GLPKConstants.GLP_UNDEF: 'undefined'}"
+++__status_gurobi = "{GRB.OPTIMAL: 'optimal', GRB.INFEASIBLE: 'infeasible', GRB.UNBOUNDED: 'unbounded'}"
+++
+++status_dict = {'cplex': __status_cplex,
+++               'glpk': __status_glpk,
+++               'glpk_java': __status_glpk_java,
+++               'gurobi': __status_gurobi}
+++
+++#Mappings from solver-specific variable kinds to cobra pie
+++__kind_cplex = "{'continuous': Cplex.variables.type.continuous, 'integer': Cplex.variables.type.integer}"
+++__kind_cplex_java = "{'continuous':  IloNumVarType.Float, 'integer': IloNumVarType.Int}"
+++__kind_glpk = "{'continuous': float, 'integer': int}"
+++__kind_glpk_java = "{'binary': GLPKConstants.GLP_BV, 'continuous': GLPKConstants.GLP_CV, 'integer': GLPKConstants.GLP_IV}"
+++__kind_gurobi = "{'continuous': GRB.CONTINUOUS, 'integer': GRB.INTEGER}"
+++
+++variable_kind_dict = {'cplex': __kind_cplex,
+++                      'cplex_java': __kind_cplex_java,
+++                      'glpk': __kind_glpk,
+++                      'glpk_java': __kind_glpk_java, 
+++                      'gurobi': __kind_gurobi}
+++
+++#Mappings from solver-specific constraint senses to cobra pie
+++sense_dict = {'cplex': "{'E': 'E', 'L': 'L', 'G': 'G'}",
+++              'glpk': "{'E': 'E', 'L': 'L', 'G': 'G'}",
+++              'gurobi': "{'E': GRB.EQUAL, 'L': GRB.LESS_EQUAL, 'G': GRB.GREATER_EQUAL}"}
+++
+++
+++#Mappings from cobra pie parameters names to solver specific parameter names
+++__mappings_cplex = {'lp_method': 'parameters.lpmethod.set',
+++                    'lp_parallel': 'parameters.threads.set',
+++                    'objective_sense': 'objective.set_sense',
+++                    'time_limit': 'parameters.timelimit.set',
+++                    'tolerance_barrier': 'parameters.barrier.convergetol.set',
+++                    'tolerance_feasibility': 'parameters.simplex.tolerances.feasibility.set',
+++                    'tolerance_markowitz': 'parameters.simplex.tolerances.markowitz.set',
+++                    'tolerance_optimality': 'parameters.simplex.tolerances.optimality.set'}
+++__mappings_cplex_java = {'lp_method': 'RootAlg'}
+++__mappings_glpk = {}
+++__mappings_glpk_java = {'objective_sense': 'objective_sense',
+++                        'lp_method': 'meth',
+++                        'output_verbosity': 'msg_lev',
+++                        'tolerance_dual': 'tol_dj',
+++                        'tolerance_integer': 'tol_int',
+++                        'tolerance_optimality': 'tol_bnd'
+++                        }
+++__mappings_gurobi = {'log_file': 'LogFile',
+++                     'lp_method': 'Method',
+++                     'objective_sense': 'ModelSense',
+++                     'output_verbosity': 'OutputFlag',
+++                     'quadratic_precision': 'Quad',
+++                     'time_limit': 'TimeLimit',
+++                     'tolerance_feasibility': 'FeasibilityTol',
+++                     'tolerance_markowitz': 'MarkowitzTol',
+++                     'tolerance_optimality': 'OptimalityTol' }
+++parameter_mappings = {'cplex': __mappings_cplex,
+++                      'cplex_java': __mappings_cplex_java,
+++                      'glpk': __mappings_glpk,
+++                      'glpk_java': __mappings_glpk_java,
+++                      'gurobi': __mappings_gurobi}
+++
+++
+++#Default solver parameters
+++__common_defaults = {'new_objective': None, 'objective_sense': 'maximize',
+++                      'min_norm': 0, 'the_problem': None, 
+++                      'tolerance_optimality': 1e-6, 'tolerance_feasibility': 1e-6,
+++                      'tolerance_integer': 1e-9, 
+++                      'error_reporting': None, 'print_solver_time': False,
+++                      'quadratic_component': None}
+++                      
+++
+++
+++__parameters_cplex = deepcopy(__common_defaults)
+++__parameters_cplex.update({'lp_method': 1,
+++                           'lp_parallel': 0,
+++                           'tolerance_barrier': 1e-8,
+++                           'update_problem_reaction_bounds': True})
+++__parameters_glpk = deepcopy(__common_defaults)
+++__parameters_glpk.update({'lp_method': 1})
+++__parameters_glpk_java = deepcopy(__common_defaults)
+++__parameters_glpk_java.update({'lp_method': 1,
+++                               'output_verbosity': 0,
+++                               'tolerance_dual': 1e-8})
+++__parameters_gurobi = deepcopy(__common_defaults)
+++__parameters_gurobi.update({'output_verbosity': 0,
+++                          'lp_method': 0,
+++                          'log_file': '',
+++                          'tolerance_barrier': 1e-8})
+++
+++
+++parameter_defaults = {'cplex': __parameters_cplex,
+++                      'glpk': __parameters_glpk,
+++                      'glpk_java': __parameters_glpk_java,
+++                      'gurobi': __parameters_gurobi}
++Index: cobra/solvers/legacy.py
++===================================================================
++--- cobra/solvers/legacy.py	(revision 330)
+++++ cobra/solvers/legacy.py	(working copy)
++@@ -309,8 +309,6 @@
++ 
++     if print_solver_time:
++         print 'cplex time: %f'%(time() - start_time)
++-    x = []
++-    x_dict = {}
++     #TODO: It might be able to speed this up a little.
++     if status == 'optimal':
++         objective_value = lp.solution.get_objective_value()
++@@ -334,7 +332,7 @@
++         if error_reporting:
++             print 'cplex failed: %s'%lp.status
++ 
++-    the_solution = Solution(objective_value, x=x, x_dict=x_dict,
+++    cobra_model.solution = the_solution = Solution(objective_value, x=x, x_dict=x_dict,
++                             status=status, y=y, y_dict=y_dict)
++     solution = {'the_problem': lp, 'the_solution': the_solution}
++     return solution    
++@@ -565,7 +563,7 @@
++         objective_value = None
++         if error_reporting:
++             print 'gurobi failed: %s'%lp.status  
++-    the_solution = Solution(objective_value, x=x, x_dict=x_dict,
+++    cobra_model.solution = the_solution = Solution(objective_value, x=x, x_dict=x_dict,
++                             y=y, y_dict=y_dict,
++                             status=status)
++     solution = {'the_problem': lp, 'the_solution': the_solution}
++@@ -810,7 +808,7 @@
++         x = y = x_dict = y_dict = objective_value = None
++         if error_reporting:
++             print 'glpk failed: %s'%lp.status
++-    the_solution = Solution(objective_value, x=x, x_dict=x_dict,
+++    cobra_model.solution = the_solution = Solution(objective_value, x=x, x_dict=x_dict,
++                             y=y, y_dict=y_dict,
++                             status=status)
++     solution = {'the_problem': lp, 'the_solution': the_solution}
++Index: cobra/solvers/cplex_solver.py
++===================================================================
++--- cobra/solvers/cplex_solver.py	(revision 0)
+++++ cobra/solvers/cplex_solver.py	(revision 0)
++@@ -0,0 +1,491 @@
+++#cobra.solvers.cplex_solver
+++#Interface to ilog/cplex 12.4 python / jython interfaces
+++#QPs are not yet supported under jython
+++from __future__ import absolute_import
+++from pdb import set_trace
+++from os import name as __name
+++from copy import deepcopy
+++from warnings import warn
+++###solver specific parameters
+++from cobra.solvers.parameters import status_dict, variable_kind_dict, \
+++     sense_dict, parameter_mappings, parameter_defaults, \
+++     objective_senses, default_objective_sense
+++
+++from cobra.core.Solution import Solution
+++from cobra.flux_analysis.objective import update_objective
+++from time import time
+++solver_name = 'cplex'
+++parameter_defaults = parameter_defaults[solver_name]
+++sense_dict = eval(sense_dict[solver_name])
+++
+++#Functions that are different for java implementation of a solver
+++if __name == 'java':
+++    from ilog.cplex import IloCplex
+++    from ilog.cplex.IloCplex import DoubleParam, IntParam, StringParam
+++    from ilog.concert import IloNumVarType 
+++    #__solver_class = IloCplex
+++    status_dict = eval(status_dict[solver_name])
+++    class Problem(IloCplex):
+++        def __init__(self):
+++            IloCplex.__init__(self)
+++            self._lp_matrix = self.addLPMatrix()
+++            self.objective_value = None
+++        def add_linear_expression(self, linear_expression, metabolite):
+++            b = metabolite._bound
+++            c = metabolite._constraint_sense
+++            the_id = metabolite.id
+++            if c == 'E':
+++                p = self.addEq(linear_expression, b, the_id)
+++            elif c == 'L':
+++                p = self.addLe(linear_expression, b, the_id)
+++            elif c == 'G':
+++                p = self.addGe(linear_expression, b, the_id)
+++            else:
+++                raise Exception("Constraint sense '%s' for metabolite %s is not valid"%(c,
+++                                                                                        the_id))
+++            return(p)
+++
+++    __solver_class = Problem
+++    parameter_mappings = parameter_mappings['%s_%s'%(solver_name,
+++                                                     __name)]
+++    variable_kind_dict = eval(variable_kind_dict['%s_%s'%(solver_name,
+++                                                          __name)])
+++    objective_senses = objective_senses[solver_name]
+++    ## from jarray import array as j_array
+++    ## def array(x, variable_type='d'):
+++    ##     return j_array(x, variable_type)
+++
+++
+++    def get_status(lp):
+++        status = repr(lp.status).lower()
+++        if status in status_dict:
+++            status = status_dict[status]
+++        else:
+++            status = 'failed'
+++        return status
+++
+++    def set_parameter(lp, parameter_name, parameter_value):
+++        if hasattr(DoubleParam, parameter_name):
+++            parameter_type = 'DoubleParam'
+++        elif hasattr(IntParam, parameter_name):
+++            parameter_type = 'IntParam'
+++        elif hasattr(StringParam, parameter_name):
+++            parameter_type = 'StringParam'
+++        else:
+++            raise Exception("%s is not a DoubleParam, IntParam, or StringParam"%parameter_name)
+++        lp.setParam(eval('%s.%s'%(parameter_type, parameter_name)),
+++                    parameter_value)
+++
+++    def format_solution(lp, cobra_model, **kwargs):
+++        """
+++        TODO
+++        """
+++        status = get_status(lp)
+++        try:
+++            x = lp.getValues(lp.variables)
+++            x_dict = dict(zip(cobra_model.reactions, x))
+++            objective_value = lp.getObjValue()
+++        except:
+++            x = x_dict = objective_value = None
+++            #print status
+++
+++        try:
+++            y = lp.getDuals(lp.variables)
+++            y_dict = dict(zip(cobra_model.metabolites, y))
+++        except:
+++            y = y_dict = None
+++        return(Solution(objective_value, x=x, x_dict=x_dict, y=y,
+++                        y_dict=y_dict, status=status))
+++
+++    def create_problem(cobra_model,  **kwargs):
+++        """Solver-specific method for constructing a solver problem from
+++        a cobra.Model.  This can be tuned for performance using kwargs
+++
+++        TODO: This will need to be specific for python / jython
+++        """
+++        the_parameters = parameter_defaults
+++        if kwargs:
+++            the_parameters = deepcopy(parameter_defaults)
+++            the_parameters.update(kwargs)
+++
+++        lp = Problem()
+++
+++        if 'log_file' not in the_parameters:
+++            lp.setWarning(None)
+++            lp.setOut(None)
+++        [set_parameter(lp, parameter_mappings[k], v)
+++         for k, v in the_parameters.iteritems() if k in parameter_mappings]
+++        quadratic_component = the_parameters['quadratic_component']
+++        new_objective = the_parameters['new_objective']
+++        error_reporting = the_parameters['error_reporting']
+++        objective_sense = the_parameters['objective_sense']
+++        if 'relax_b' in the_parameters:
+++            warn('need to reimplement relax_b')
+++            relax_b = False
+++        else:
+++            relax_b = False
+++
+++        #Using the new objects
+++        #NOTE: This might be slow
+++        objective_coefficients = []
+++        lower_bounds = []
+++        upper_bounds = []
+++        variable_names = []
+++        variable_kinds = []
+++        [(objective_coefficients.append(x.objective_coefficient),
+++          lower_bounds.append(x.lower_bound),
+++          upper_bounds.append(x.upper_bound),
+++          variable_names.append(x.id),
+++          variable_kinds.append(variable_kind_dict[x.variable_kind]))
+++         for x in cobra_model.reactions]
+++
+++        #Only add the variable types if one or more variables is an integer, just
+++        #in case the java interface has the same bug as the python interface where
+++        #the problem type switches to integer if variable types are supplied even
+++        #if all are continuous
+++        if variable_kind_dict['integer'] in variable_kinds:
+++            lp.variables = lp.numVarArray(len(cobra_model.reactions), lower_bounds,
+++                                          upper_bounds, variable_kinds, variable_names)
+++        else:
+++            lp.variables = lp.numVarArray(len(cobra_model.reactions), lower_bounds, upper_bounds,
+++                                          variable_names)
+++        
+++        lp.variable_dict = dict(zip(cobra_model.reactions, lp.variables))
+++        if objective_sense == 'maximize':
+++            __lp_add_objective = lp.addMaximize
+++        else:
+++            __lp_add_objective = lp.addMinimize
+++
+++        __lp_add_objective(lp.scalProd(lp.variables, objective_coefficients))
+++        
+++
+++        
+++        lp.constraints = []
+++        lp.constraint_dict = {}
+++        for the_metabolite in cobra_model.metabolites:
+++            linear_expression = lp.sum([lp.prod(k._metabolites[the_metabolite],
+++                                                lp.variable_dict[k])
+++                                        for k in the_metabolite._reaction])
+++            expression_pointer = lp.add_linear_expression(linear_expression, the_metabolite)
+++            lp.constraints.append(expression_pointer)
+++            lp.constraint_dict[the_metabolite] = expression_pointer
+++        
+++        if quadratic_component is not None:
+++            raise Exception("cplex through java isn't configured for QPs yet")
+++            if not hasattr(quadratic_component, 'todok'):
+++                raise Exception('quadratic component must have method todok')
+++            quadratic_component_scaled = quadratic_component.todok()
+++
+++            lp.parameters.emphasis.numerical.set(1)
+++            for k, v in quadratic_component_scaled.items():
+++                lp.objective.set_quadratic_coefficients(int(k[0]), int(k[1]), v)
+++
+++        if error_reporting == 'time':
+++            print 'setup new problem: ' + repr(time()-start_time)
+++            start_time = time()
+++
+++        ## #Set the problem type as cplex doesn't appear to do this correctly
+++        ## problem_type = Cplex.problem_type.LP
+++        ## if Cplex.variables.type.integer in variable_kinds:
+++        ##     if quadratic_component is not None:
+++        ##         problem_type = Cplex.problem_type.MIQP
+++        ##     else:
+++        ##         problem_type = Cplex.problem_type.MILP
+++        ## elif quadratic_component is not None:
+++        ##     problem_type = Cplex.problem_type.QP
+++        ## lp.set_problem_type(problem_type)
+++        return(lp)
+++
+++else:
+++    ###Python functions
+++    parameter_mappings = parameter_mappings[solver_name]
+++    objective_senses = objective_senses[solver_name]
+++    from cplex import Cplex, SparsePair
+++    class Problem(Cplex):
+++        def __init__(self):
+++            Cplex.__init__(self)
+++    __solver_class = Problem
+++    variable_kind_dict = eval(variable_kind_dict[solver_name])
+++
+++    def get_status(lp):
+++        status = lp.solution.get_status_string().lower()
+++        if status in status_dict:
+++            status = status_dict[status]
+++        else:
+++            status = 'failed'
+++        return status
+++
+++    def format_solution(lp, cobra_model, **kwargs):
+++        status = get_status(lp)
+++        #TODO: It might be able to speed this up a little.
+++        if status == 'optimal':
+++            objective_value = lp.solution.get_objective_value()
+++            #This can be sped up a little
+++            x_dict = dict(zip(lp.variables.get_names(),
+++                         lp.solution.get_values()))
+++            x = lp.solution.get_values()
+++            #MIP's don't have duals
+++            if lp.get_problem_type() in (Cplex.problem_type.MIQP,
+++                                         Cplex.problem_type.MILP):
+++
+++                y = y_dict = None
+++            else:
+++                y_dict = dict(zip(lp.linear_constraints.get_names(),
+++                                  lp.solution.get_dual_values()))
+++                y = lp.solution.get_dual_values()
+++        else:
+++            x = y = x_dict = y_dict = objective_value = None
+++
+++        the_solution = Solution(objective_value, x=x, x_dict=x_dict,
+++                                status=status, y=y, y_dict=y_dict)
+++        return the_solution    
+++   
+++    def set_parameter(lp, parameter_name, parameter_value):
+++        """with pyglpk the parameters are set during the solve phase
+++        """
+++        if parameter_name == 'objective.set_sense':
+++            if parameter_value in objective_senses:
+++                parameter_value = eval(objective_senses[parameter_value])
+++        try:
+++            eval('lp.%s(%s)'%(parameter_name, repr(parameter_value)))
+++        except Exception, e:
+++            print "Couldn't set parameter %s: %s"%(parameter_name, repr(e))
+++
+++
+++
+++    def create_problem(cobra_model,  **kwargs):
+++        """Solver-specific method for constructing a solver problem from
+++        a cobra.Model.  This can be tuned for performance using kwargs
+++
+++
+++        """
+++        the_parameters = parameter_defaults
+++        if kwargs:
+++            the_parameters = deepcopy(parameter_defaults)
+++            the_parameters.update(kwargs)
+++
+++        lp = __solver_class()
+++        if 'log_file' not in the_parameters:
+++            lp.set_results_stream(None)
+++            lp.set_warning_stream(None)
+++        [set_parameter(lp, parameter_mappings[k], v)
+++         for k, v in the_parameters.iteritems() if k in parameter_mappings]
+++        quadratic_component = the_parameters['quadratic_component']
+++        new_objective = the_parameters['new_objective']
+++        error_reporting = the_parameters['error_reporting']
+++        if 'relax_b' in the_parameters:
+++            warn('need to reimplement relax_b')
+++            relax_b = False
+++        else:
+++            relax_b = False
+++
+++        #Using the new objects
+++        #NOTE: This might be slow
+++        objective_coefficients = []
+++        lower_bounds = []
+++        upper_bounds = []
+++        variable_names = []
+++        variable_kinds = []
+++        [(objective_coefficients.append(x.objective_coefficient),
+++          lower_bounds.append(x.lower_bound),
+++          upper_bounds.append(x.upper_bound),
+++          variable_names.append(x.id),
+++          variable_kinds.append(variable_kind_dict[x.variable_kind]))
+++         for x in cobra_model.reactions]
+++        #Cplex decides that the problem is a MIP if variable_kinds are supplied
+++        #even if there aren't any integers.
+++        if variable_kind_dict['integer'] in variable_kinds:
+++            lp.variables.add(obj=objective_coefficients,
+++                             lb=lower_bounds,
+++                             ub=upper_bounds,
+++                             names=variable_names,
+++                             types=variable_kinds)
+++        else:
+++            lp.variables.add(obj=objective_coefficients,
+++                             lb=lower_bounds,
+++                             ub=upper_bounds,
+++                             names=variable_names)
+++
+++       ## if relax_b:
+++            ## range_values = zeros(len(cobra_model.metabolites))
+++            ## b_values = array([x._bound for x in cobra_model.metabolties])
+++            ## for the_nonzero in list(b_values.nonzero()[0]):
+++            ##     range_values[the_nonzero] = -relax_b
+++
+++        constraint_sense = []
+++        constraint_names = []
+++        constraint_limits = []
+++        [(constraint_sense.append(x._constraint_sense),
+++          constraint_names.append(x.id),
+++          constraint_limits.append(x._bound))
+++         for x in cobra_model.metabolites]
+++
+++        the_linear_expressions = []
+++        #NOTE: This won't work with metabolites that aren't in any reaction
+++        for the_metabolite in cobra_model.metabolites:
+++            variable_list = []
+++            coefficient_list = []
+++            for the_reaction in the_metabolite._reaction:
+++                variable_list.append(the_reaction.id)
+++                coefficient_list.append(the_reaction._metabolites[the_metabolite])
+++            the_linear_expressions.append(SparsePair(ind=variable_list,
+++                                                     val=coefficient_list))
+++        if quadratic_component is not None:
+++            if not hasattr(quadratic_component, 'todok'):
+++                raise Exception('quadratic component must have method todok')
+++            quadratic_component_scaled = quadratic_component.todok()
+++
+++            lp.parameters.emphasis.numerical.set(1)
+++            for k, v in quadratic_component_scaled.items():
+++                lp.objective.set_quadratic_coefficients(int(k[0]), int(k[1]), v)
+++
+++
+++        if relax_b:
+++            lp.linear_constraints.add(lin_expr=the_linear_expressions,
+++                                      rhs=constraint_limits,
+++                                      range_values=list(range_values),
+++                                      senses=constraint_sense,
+++                                      names=constraint_names)
+++
+++        else:
+++            lp.linear_constraints.add(lin_expr=the_linear_expressions,
+++                                      rhs=constraint_limits,
+++                                      senses=constraint_sense,
+++                                      names=constraint_names)
+++
+++        if error_reporting == 'time':
+++            print 'setup new problem: ' + repr(time()-start_time)
+++            start_time = time()
+++
+++        #Set the problem type as cplex doesn't appear to do this correctly
+++        problem_type = Cplex.problem_type.LP
+++        if Cplex.variables.type.integer in variable_kinds:
+++            if quadratic_component is not None:
+++                problem_type = Cplex.problem_type.MIQP
+++            else:
+++                problem_type = Cplex.problem_type.MILP
+++        elif quadratic_component is not None:
+++            problem_type = Cplex.problem_type.QP
+++        lp.set_problem_type(problem_type)
+++        return(lp)
+++
+++###
+++
+++def update_problem(lp, cobra_model, **kwargs):
+++    """A performance tunable method for updating a model problem file
+++
+++    lp: A gurobi problem object
+++
+++    cobra_model: the cobra.Model corresponding to 'lp'
+++
+++    """
+++    #When reusing the basis only assume that the objective coefficients or bounds can change
+++    #BUG with changing / unchanging the basis
+++    try:
+++        new_objective = kwargs['new_objective']
+++    except:
+++        new_objective = None
+++    try:
+++        update_problem_reaction_bounds = kwargs['update_problem_reaction_bounds']
+++    except:
+++        update_problem_reaction_bounds = True
+++    try:
+++        quadratic_component = kwargs['quadratic_component']
+++        if quadratic_component is not None:
+++            warn("update_problem does not yet take quadratic_component as a parameter")
+++    except:
+++        quadratic_component = None
+++    
+++    if 'copy_problem' in kwargs and kwargs['copy_problem']:
+++        lp = Cplex(lp)
+++
+++    if new_objective is not None:
+++        lp.objective.set_linear([(x.id, float(x.objective_coefficient))
+++                                 for x in cobra_model.reactions])
+++    if update_problem_reaction_bounds:
+++        lp.variables.set_upper_bounds([(x.id, float(x.upper_bound))
+++                                        for x in cobra_model.reactions])
+++        lp.variables.set_lower_bounds([(x.id, float(x.lower_bound))
+++                                        for x in cobra_model.reactions])
+++
+++
+++
+++###
+++def solve_problem(lp, **kwargs):
+++    """A performance tunable method for updating a model problem file
+++
+++    """
+++    #Update parameter settings if provided
+++    if kwargs:
+++        [set_parameter(lp, parameter_mappings[k], v)
+++         for k, v in kwargs.iteritems() if k in parameter_mappings]
+++    try:
+++        print_solver_time = kwargs['print_solver_time']
+++        start_time = time()
+++    except:
+++        print_solver_time = False
+++
+++    try:
+++        the_problem = kwargs['the_problem']
+++    except:
+++        the_problem = False
+++    if isinstance(the_problem, __solver_class):
+++        try:
+++            the_basis = the_problem.solution.basis.get_basis()
+++            lp.start.set_basis(the_basis[0],the_basis[1])
+++            lp.parameters.preprocessing.presolve.set(0)
+++        except:
+++            print 'no basis in the_problem'
+++    
+++    lp.solve()
+++    #If the solver takes more than 0.1 s with a hot start it is likely stuck
+++    status = get_status(lp)
+++    if status != 'optimal':
+++        #Cycle through the different solver options, if a solution is not found
+++        for lp_method in (1, 2, 3, 4, 5, 6):
+++            set_parameter(lp, parameter_mappings['lp_method'], lp_method)
+++            lp.solve()
+++            status = get_status(lp)
+++            if status == 'optimal':
+++                break
+++
+++    if print_solver_time:
+++        print 'optimize time: %f'%(time() - start_time)
+++    return status
+++
+++    
+++def solve(cobra_model, **kwargs):
+++    """
+++
+++    """
+++        #Update objectives if they are new.
+++    if 'new_objective' in kwargs and \
+++           kwargs['new_objective'] not in ['update problem', None]:
+++       update_objective(cobra_model, kwargs['new_objective'])
+++
+++    if 'the_problem' in kwargs:
+++        the_problem = kwargs['the_problem']
+++    else:
+++        the_problem = None
+++    if 'error_reporting' in kwargs:
+++        error_reporting = kwargs['error_reporting']
+++    else:
+++        error_reporting = False
+++    if isinstance(the_problem, __solver_class):
+++        #Update the problem with the current cobra_model
+++        lp = the_problem
+++        update_problem(lp, cobra_model, **kwargs)
+++    else:
+++        #Create a new problem
+++        lp = create_problem(cobra_model, **kwargs)
+++    #Deprecated way for returning a solver problem created from a cobra_model
+++    #without performing optimization
+++    if the_problem == 'setup':
+++        return lp
+++    status = solve_problem(lp)
+++    the_solution = format_solution(lp, cobra_model)
+++    if status != 'optimal' and error_reporting:
+++        print '%s failed: %s'%(solver_name, status)
+++    cobra_model.solution = the_solution
+++    solution = {'the_problem': lp, 'the_solution': the_solution}
+++    return solution
++Index: cobra/solvers/gurobi.py
++===================================================================
++--- cobra/solvers/gurobi.py	(revision 330)
+++++ cobra/solvers/gurobi.py	(working copy)
++@@ -1,88 +0,0 @@
++-from gurobipy import GRB, Model, LinExpr, GRB, QuadExpr, Column
++-from numpy import array
++-
++-from ..core.Solution import Solution
++-
++-
++-# mappers from cobra representation to gurobi
++-sense_dict = {
++-    'E': GRB.EQUAL,
++-    'L': GRB.LESS_EQUAL,
++-    'G': GRB.GREATER_EQUAL}
++-variable_kind_dict = {
++-    'continuous': GRB.CONTINUOUS,
++-    'integer': GRB.INTEGER}
++-parameter_dict = {  # TODO USE
++-    "tolerance_feasibility": "FeasibilityTol",
++-    "tolerance_optimality": "OptimalityTol"}
++-default_parameters = {
++-}
++-
++-# mappers from gurobi representations to cobra
++-status_dict = {
++-    GRB.OPTIMAL: 'optimal',
++-    GRB.INFEASIBLE: 'infeasible',
++-    GRB.UNBOUNDED: 'unbounded'}
++-
++-
++-def create_problem(cobra_model, objective_sense="maximize"):
++-    lp = Model("cobra")
++-    lp.Params.OutputFlag = 0
++-
++-    if objective_sense == 'maximize':
++-        objective_sign = -1.0
++-    elif objective_sense == 'minimize':
++-        objective_sign = 1.0
++-    else:
++-        raise ValueError("objective_sense must be 'maximize' or 'minimize'")
++-
++-    # create metabolites/constraints
++-    metabolite_constraints = {}
++-    for metabolite in cobra_model.metabolites:
++-        metabolite_constraints[metabolite] = \
++-            lp.addConstr(0.0, sense_dict[metabolite._constraint_sense],
++-            metabolite._bound, metabolite.id)
++-    lp.update()
++-
++-    # create reactions/variables along with S matrix
++-    for j, reaction in enumerate(cobra_model.reactions):
++-        constraints = [metabolite_constraints[i] \
++-            for i in reaction._metabolites]
++-        stoichiometry = reaction._metabolites.values()
++-        lp.addVar(
++-            lb=float(reaction.lower_bound),
++-            ub=float(reaction.upper_bound),
++-            obj=objective_sign * reaction.objective_coefficient,
++-            name=reaction.id,
++-            vtype=variable_kind_dict[reaction.variable_kind],
++-            column=Column(stoichiometry, constraints))
++-    lp.update()
++-    return lp
++-
++-
++-def update_problem(cobra_model, lp, objective_sense="maximize"):
++-    pass
++-    # TODO implement
++-
++-
++-def solve_problem(lp):
++-    lp.optimize()
++-    try:
++-        status = status_dict[lp.status]
++-    except KeyError:
++-        status = "unkown error: " + lp.status
++-    solution = Solution(status)
++-    solution.status = status
++-    if status == "optimal":
++-        solution.objective_value = lp.ObjVal * -1  # TODO fix sign
++-        solution.x_dict = dict((v.VarName, v.X) for v in lp.getVars())
++-        if lp.isMIP:
++-            solution.y_dict = None  # MIP's don't have duals
++-        else:
++-            solution.y_dict = \
++-                dict((c.ConstrName, c.Pi) for c in lp.getConstrs())
++-    return solution
++-
++-
++-def solve(cobra_model, objective_sense="maximize", **kwargs):
++-    return solve_problem(create_problem(cobra_model, objective_sense))
++Index: cobra/solvers/glpk_solver.py
++===================================================================
++--- cobra/solvers/glpk_solver.py	(revision 0)
+++++ cobra/solvers/glpk_solver.py	(revision 0)
++@@ -0,0 +1,556 @@
+++##cobra.solvers.glpk_solver
+++#This script provides wrappers for libglpk-java 1.0.22 and pyglpk 0.3
+++from __future__ import absolute_import
+++from warnings import warn
+++from os import name as __name
+++from copy import deepcopy
+++###solver specific parameters
+++from .parameters import status_dict, variable_kind_dict, \
+++     sense_dict, parameter_mappings, parameter_defaults, \
+++     objective_senses, default_objective_sense
+++
+++from ..core.Solution import Solution
+++from ..flux_analysis.objective import update_objective
+++from time import time
+++solver_name = 'glpk'
+++sense_dict = eval(sense_dict[solver_name])
+++#Functions that are different for java implementation of a solver
+++if __name == 'java':
+++    ## from jarray import array as j_array
+++    ## def array(x, variable_type='d'):
+++    ##     return j_array(x, variable_type)
+++
+++    from org.gnu.glpk import GLPK, GLPKConstants, glp_smcp, glp_iocp
+++    variable_kind_dict = eval(variable_kind_dict['%s_%s'%(solver_name,
+++                                                __name)])
+++    status_dict = eval(status_dict['%s_%s'%(solver_name,
+++                                                __name)])
+++    objective_senses = objective_senses['%s_%s'%(solver_name,
+++                                                __name)]
+++    parameter_mappings = parameter_mappings['%s_%s'%(solver_name,
+++                                                     __name)]
+++    parameter_defaults = parameter_defaults['%s_%s'%(solver_name,
+++                                                     __name)]
+++
+++    class Problem():
+++        """Create a more pythonesqe class to wrap the key
+++        features of the libglpk-java functions.
+++        
+++        """
+++        def __init__(self):
+++            """the attributes g, lp, mip should be made private
+++            """
+++            self._g = GLPK
+++            self._lp= GLPK.glp_create_prob()
+++            self._simplex_parameters = glp_smcp()
+++            self._mip_parameters = None
+++            self._g.glp_init_smcp(self._simplex_parameters)
+++            self.status = self.objective_value = None
+++            self._mip = False
+++        def set_name(self, name=''):
+++            self._g.glp_set_prob_name(self._lp, name)
+++
+++        def solve(self):
+++            try:
+++                self._g.glp_simplex(self._lp,
+++                                   self._simplex_parameters)
+++                if self._mip:
+++                    #perform the MIP
+++                    setattr(self._mip_parameters, 'msg_lev',
+++                             self._simplex_parameters.msg_lev)
+++                    self._g.glp_intopt(self._lp, self._mip_parameters)
+++                self.status = self.get_status()
+++                self.objective_value = self.get_objective_value()
+++            except:
+++                self.status = 'failed'
+++            return self.status
+++
+++        def get_status(self):
+++            if self._mip:
+++                status = self._g.glp_mip_status(self._lp)
+++            else:
+++                status = self._g.glp_get_status(self._lp)
+++            return status_dict[status]
+++        
+++        def set_objective_sense(self, parameter_value='maximize'):
+++            self._g.glp_set_obj_dir(self._lp,
+++                                   eval(objective_senses[parameter_value]))
+++
+++        def set_parameter(self, parameter_name, parameter_value, warning=False):
+++            if parameter_name == 'objective_sense':
+++                self.set_objective_sense()
+++            else:
+++                if parameter_name == 'meth' and parameter_value not in [1,2,3]:
+++                    parameter_value = 1
+++                try:
+++                    setattr(self._simplex_parameters, parameter_name,
+++                            parameter_value)
+++                except Exception, e1:
+++                    try:
+++                        setattr(self._mip_parameters, parameter_name,
+++                                parameter_value)
+++                    except Exception, e2:
+++                        if warning:
+++                            print "Could not set simplex parameter " +\
+++                                  "%s: %s"%(parameter_name, repr(e1))
+++                            
+++                            if self._mip_parameters is not None:
+++                                print "Could not set mip parameter " +\
+++                                      "%s: %s"%(parameter_name, repr(e2))
+++        def get_objective_value(self):
+++            if self._mip:
+++                tmp_value = self._g.glp_mip_obj_val(self._lp)
+++            else:
+++                tmp_value = self._g.glp_get_obj_val(self._lp)
+++            return tmp_value
+++
+++        def create_problem(self, cobra_model):
+++            g = self._g
+++            lp = self._lp
+++            number_of_reactions = len(cobra_model.reactions)
+++            number_of_metabolites = len(cobra_model.metabolites)
+++            g.glp_add_cols(lp, number_of_reactions)
+++            reaction_to_index = {}
+++            objective_dict = {}
+++            #Add in the variables
+++            tmp_kinds = []
+++            for i, the_reaction in enumerate(cobra_model.reactions):
+++                i_offset = i + 1
+++                reaction_to_index[the_reaction] = i_offset
+++                if the_reaction.objective_coefficient != 0:
+++                    objective_dict[i_offset] = the_reaction.objective_coefficient
+++                g.glp_set_col_name(lp, i_offset, the_reaction.id)
+++                tmp_kinds.append(the_reaction.variable_kind)
+++                the_kind = variable_kind_dict[the_reaction.variable_kind]
+++                lower_bound = the_reaction.lower_bound
+++                upper_bound = the_reaction.upper_bound
+++                #Note. It is possible to have unbounded or one-bound variables
+++                if lower_bound == upper_bound:
+++                    bound_kind = GLPKConstants.GLP_FX
+++                else:
+++                    bound_kind = GLPKConstants.GLP_DB
+++                g.glp_set_col_kind(lp, i_offset, the_kind)
+++                g.glp_set_col_bnds(lp, i_offset,
+++                                   bound_kind, the_reaction.lower_bound,
+++                                   the_reaction.upper_bound)
+++            tmp_kinds = set(tmp_kinds)
+++            if 'integer' in tmp_kinds or 'binary' in tmp_kinds:
+++                self._mip = True
+++                self._mip_parameters = glp_iocp()
+++                _g.glp_init_iocp(self._mip_parameters)
+++            #create constraints
+++            g.glp_add_rows(lp, number_of_metabolites)
+++            row_indices = []
+++            column_indices = []
+++            constraint_values = []
+++            for i, the_metabolite in enumerate(cobra_model.metabolites):
+++                i_offset = i + 1
+++                g.glp_set_row_name(lp, i_offset, the_metabolite.id)
+++                bound_type = GLPKConstants.GLP_FX
+++                lower_bound = upper_bound = the_metabolite._bound
+++                constraint_sense = sense_dict[the_metabolite._constraint_sense]
+++                if constraint_sense == 'L':
+++                    bound_type = GLPKConstants.GLP_LO
+++                elif constraint_sense == 'G':
+++                    bound_type = GLPKConstants.GLP_UP
+++                elif constraint_sense == 'U':
+++                    bound_type = GLPKConstants.GLP_FR
+++                elif hasattr(lower_bound, '__iter__'):
+++                    lower_bound, upper_bound = lower_bound[:2]
+++                    bound_type = GLPKConstants.GLP_DB
+++                    
+++
+++                g.glp_set_row_bnds(lp, i_offset, bound_type,
+++                                   lower_bound, upper_bound)
+++
+++                [(row_indices.append(i_offset),
+++                  column_indices.append(reaction_to_index[k]),
+++                  constraint_values.append(k._metabolites[the_metabolite]))
+++                 for k in the_metabolite._reaction]
+++
+++            #Load the constraints into the lp.  Need to use
+++            #typed arrays.
+++            number_of_constraints = len(row_indices)
+++            i_array = g.new_intArray(number_of_constraints)
+++            j_array = g.new_intArray(number_of_constraints)
+++            v_array = g.new_doubleArray(number_of_constraints)
+++            for a, (i, j, v) in enumerate(zip(row_indices,
+++                                              column_indices,
+++                                              constraint_values)):
+++                g.intArray_setitem(i_array, a+1, i)
+++                g.intArray_setitem(j_array, a+1, j)
+++                g.doubleArray_setitem(v_array, a+1, v)
+++            g.glp_load_matrix(lp, number_of_constraints, i_array,
+++                              j_array, v_array)
+++            g.delete_intArray(i_array)
+++            g.delete_intArray(j_array)
+++            g.delete_doubleArray(v_array)
+++            
+++    
+++            g.glp_set_obj_name(lp, "z")
+++            self.set_objective_sense()
+++            [g.glp_set_obj_coef(lp, k, v)
+++              for k, v in objective_dict.iteritems()]
+++
+++            
+++
+++
+++
+++
+++    __solver_class = Problem
+++
+++    def set_parameter(lp, parameter_name, parameter_value):
+++        lp.set_parameter(parameter_name, parameter_value)
+++
+++
+++    def get_status(lp):
+++        return lp.get_status()
+++
+++    def format_solution(lp, cobra_model, **kwargs):
+++        """
+++
+++        """
+++        status = get_status(lp)
+++        if not lp._mip:
+++            try:
+++                x = [lp._g.glp_get_col_prim(lp._lp, i + 1)
+++                     for i in range(len(cobra_model.reactions))]
+++                x_dict = dict(zip(cobra_model.reactions, x))
+++
+++                y = [lp._g.glp_get_row_dual(lp._lp, i + 1)
+++                     for i in range(len(cobra_model.metabolites))]
+++                y_dict = dict(zip(cobra_model.metabolites, y))
+++            
+++                objective_value = lp.objective_value
+++            except Exception, e:
+++                print repr(e)
+++                y = y_dict = x = x_dict = objective_value = None
+++                #print status
+++        else:
+++            try:
+++                x = [lp._g.glp_mip_col_val(lp._lp, i + 1)
+++                     for i in range(cobra_model.reactions)]
+++                x_dict = dict(zip(cobra_model.reactions, x))
+++                y = y_dict = None
+++                objective_value = lp.objective_value
+++            except:
+++                y = y_dict = x = x_dict = objective_value = None
+++
+++        return(Solution(objective_value, x=x, x_dict=x_dict, y=y,
+++                        y_dict=y_dict, status=status))
+++    def create_problem(cobra_model,  **kwargs):
+++        """Solver-specific method for constructing a solver problem from
+++        a cobra.Model.  This can be tuned for performance using kwargs
+++
+++
+++        """
+++        the_parameters = parameter_defaults
+++        if kwargs:
+++            the_parameters = deepcopy(parameter_defaults)
+++            the_parameters.update(kwargs)
+++        quadratic_component = the_parameters['quadratic_component']
+++        new_objective = the_parameters['new_objective']
+++        if quadratic_component is not None:
+++            raise Exception('%s cannot solve QPs, try a different solver'%solver_name)
+++        lp = Problem()        # Create empty problem instance
+++        lp.create_problem(cobra_model)
+++        [set_parameter(lp, parameter_mappings[k], v)
+++         for k, v in the_parameters.iteritems() if k in parameter_mappings]
+++        return(lp)
+++    
+++    def update_problem(lp, cobra_model, **kwargs):
+++        """
+++        Assumes that neither Metabolites nor Reaction have been
+++        added or removed.
+++
+++        Currently only deals with reaction bounds and objective
+++        coefficients.
+++
+++        """
+++        g = lp._g
+++        l = lp._lp
+++        for i, the_reaction in enumerate(cobra_model.reactions):
+++            lower_bound = float(the_reaction.lower_bound)
+++            upper_bound = float(the_reaction.upper_bound)
+++            objective_coefficient = float(the_reaction.objective_coefficients)
+++            if lower_bound == upper_bound:
+++                bound_type = GLPKConstants.GLP_FX
+++            else:
+++                bound_type = GLPKConstants.GLP_DB
+++            g.glp_set_col_bnds(l, i + 1, bound_type, lower_bound, upper_bound)
+++            g.glp_set_obj_coef(l, i + 1, objective_coefficient)
+++
+++        
+++    def solve_problem(lp, **kwargs):
+++        """A performance tunable method for updating a model problem file
+++
+++        """
+++        #Update parameter settings if provided
+++        if kwargs:
+++            [set_parameter(lp, parameter_mappings[k], v)
+++             for k, v in kwargs.iteritems() if k in parameter_mappings]
+++        try:
+++            print_solver_time = kwargs['print_solver_time']
+++            start_time = time()
+++        except:
+++            print_solver_time = False
+++        lp_method = lp._simplex_parameters.meth
+++        the_methods = [1, 2, 3]
+++        if lp_method in the_methods:
+++            the_methods.remove(lp_method)
+++        else:
+++            lp_method = 1
+++        lp.solve()
+++        status = get_status(lp)
+++        if status != 'optimal':
+++            for lp_method in the_methods:
+++                set_parameter(lp, parameter_mappings['lp_method'], lp_method)
+++                lp.solve()
+++                status = get_status(lp)
+++                break
+++        if print_solver_time:
+++            print 'optimize time: %f'%(time() - start_time)
+++        return status
+++else:
+++    ##Interface to pyGLPK 0.3 
+++    from glpk import LPX as GLPK
+++    __solver_class = GLPK
+++    objective_senses = objective_senses[solver_name]
+++    variable_kind_dict = eval(variable_kind_dict[solver_name])
+++    status_dict = eval(status_dict[solver_name])
+++    parameter_mappings = parameter_mappings[solver_name]
+++    parameter_defaults = parameter_defaults[solver_name]
+++
+++    def get_status(lp):
+++        status = lp.status
+++        if status in status_dict:
+++            status = status_dict[status]
+++        else:
+++            status = 'failed'
+++        return status
+++
+++    def format_solution(lp, cobra_model, **kwargs):
+++        try:
+++            objective_sign = objective_senses[kwargs['objective_sense']]
+++        except:
+++            objective_sign = objective_senses[default_objective_sense]
+++            
+++        status = get_status(lp)
+++        if status == 'optimal':
+++            objective_value = lp.obj.value
+++            x = []
+++            x_dict = {}
+++            [(x.append(float(c.primal)),
+++              x_dict.update({c.name:c.primal}))
+++              for c in lp.cols]
+++
+++            if lp.kind == float:
+++                y = []
+++                y_dict = {}
+++                #return the duals as well as the primals for LPs
+++                [(y.append(float(c.dual)),
+++                  y_dict.update({c.name:c.dual}))
+++                 for c in lp.rows]
+++            else:
+++                #MIPs don't have duals
+++                y = y_dict = None
+++            the_solution = Solution(objective_value, x=x, x_dict=x_dict, y=y,
+++                                    y_dict=y_dict, status=status)
+++        else:
+++            the_solution = Solution(None, status=status)
+++        return(the_solution)
+++
+++    def set_parameter(lp, parameter_name, parameter_value):
+++        """with pyglpk the parameters are set during the solve phase
+++        """
+++        warn("py glpk solver parameters are set during solve_problem")
+++        pass
+++
+++    def create_problem(cobra_model,  **kwargs):
+++        """Solver-specific method for constructing a solver problem from
+++        a cobra.Model.  This can be tuned for performance using kwargs
+++
+++
+++        """
+++        the_parameters = parameter_defaults
+++        if kwargs:
+++            the_parameters = deepcopy(parameter_defaults)
+++            the_parameters.update(kwargs)
+++        quadratic_component = the_parameters['quadratic_component']
+++        new_objective = the_parameters['new_objective']
+++        if quadratic_component is not None:
+++            raise Exception('%s cannot solve QPs, try a different solver'%solver_name)
+++        #Faster to use these dicts than index lists
+++        index_to_metabolite = dict(zip(range(len(cobra_model.metabolites)),
+++                                       cobra_model.metabolites))
+++        index_to_reaction = dict(zip(range(len(cobra_model.reactions)),
+++                                     cobra_model.reactions))
+++        reaction_to_index = dict(zip(index_to_reaction.values(),
+++                                     index_to_reaction.keys()))
+++
+++
+++        lp = __solver_class()        # Create empty problem instance
+++        lp.name = 'cobra'     # Assign symbolic name to problem
+++        lp.rows.add(len(cobra_model.metabolites))
+++        lp.cols.add(len(cobra_model.reactions))
+++        linear_constraints = []
+++        for r in lp.rows:
+++            the_metabolite = index_to_metabolite[r.index]
+++            r.name = the_metabolite.id
+++            b = float(the_metabolite._bound)
+++            c = sense_dict[the_metabolite._constraint_sense]
+++            if c == 'E':
+++                r.bounds = b, b     # Set metabolite to steady state levels
+++            elif c == 'L':
+++                r.bounds = None, b
+++            elif c == 'G':
+++                r.bounds = b, None
+++            #Add in the linear constraints
+++
+++            for the_reaction in the_metabolite._reaction:
+++                reaction_index = reaction_to_index[the_reaction]
+++                the_coefficient = the_reaction._metabolites[the_metabolite]
+++                linear_constraints.append((r.index, reaction_index,
+++                                           the_coefficient))
+++        #Need to assign lp.matrix after constructing the whole list
+++        lp.matrix = linear_constraints
+++        objective_coefficients = []
+++
+++        for c in lp.cols:
+++            the_reaction = index_to_reaction[c.index]
+++            c.name = the_reaction.id           
+++            the_reaction = index_to_reaction[c.index]
+++            c.kind = variable_kind_dict[the_reaction.variable_kind]
+++            c.bounds = the_reaction.lower_bound, the_reaction.upper_bound
+++            objective_coefficients.append(float(the_reaction.objective_coefficient))
+++        #Add the new objective coefficients to the problem
+++        lp.obj[:] = objective_coefficients
+++
+++        return(lp)
+++
+++
+++    def update_problem(lp, cobra_model, **kwargs):
+++        """A performance tunable method for updating a model problem file
+++
+++        lp: A gurobi problem object
+++
+++        cobra_model: the cobra.Model corresponding to 'lp'
+++
+++        """
+++        #When reusing the basis only assume that the objective coefficients or bounds can change
+++        #BUG with changing / unchanging the basis
+++        index_to_metabolite = dict(zip(range(len(cobra_model.metabolites)),
+++                                       cobra_model.metabolites))
+++        index_to_reaction = dict(zip(range(len(cobra_model.reactions)),
+++                                     cobra_model.reactions))
+++        reaction_to_index = dict(zip(index_to_reaction.values(),
+++                                     index_to_reaction.keys()))
+++
+++        try:
+++            new_objective = kwargs['new_objective']
+++        except:
+++            new_objective = None
+++        if new_objective is not None:
+++            objective_coefficients = []
+++            for c in lp.cols:      # Iterate over all rows
+++                the_reaction = index_to_reaction[c.index]
+++                c.name = the_reaction.id
+++                c.bounds = the_reaction.lower_bound, the_reaction.upper_bound
+++                objective_coefficients.append(float(the_reaction.objective_coefficient))
+++                c.kind = variable_kind_dict[the_reaction.variable_kind]
+++            #Add the new objective coefficients to the problem
+++            lp.obj[:] = objective_coefficients
+++        else:
+++            for c in lp.cols:      # Iterate over all rows
+++                the_reaction = index_to_reaction[c.index]
+++                c.name = the_reaction.id
+++                c.bounds = the_reaction.lower_bound, the_reaction.upper_bound
+++                c.kind = variable_kind_dict[the_reaction.variable_kind]
+++
+++
+++    ###
+++    def solve_problem(lp, **kwargs):
+++        """A performance tunable method for updating a model problem file
+++
+++        """
+++        #Update parameter settings if provided
+++        the_parameters = parameter_defaults
+++        if kwargs:
+++            the_parameters = deepcopy(parameter_defaults)
+++            the_parameters.update(kwargs)
+++        try:
+++            print_solver_time = kwargs['print_solver_time']
+++            start_time = time()
+++        except:
+++            print_solver_time = False
+++        tolerance_optimality = the_parameters['tolerance_optimality']
+++        tolerance_integer = the_parameters['tolerance_integer']
+++        lp_method = the_parameters['lp_method']
+++        #[set_parameter(lp, parameter_mappings[k], v)
+++        # for k, v in kwargs.iteritems() if k in parameter_mappings]
+++
+++        lp.obj.maximize = objective_senses[the_parameters['objective_sense']] 
+++        the_methods = [1, 2, 3]
+++        if lp_method in the_methods:
+++            the_methods.remove(lp_method)
+++        else:
+++            lp_method = 1
+++
+++        if lp.kind == int:
+++            #For MILPs, it is faster to solve LP then move to MILP
+++            lp.simplex(tol_bnd=tolerance_optimality,
+++                       tol_dj=tolerance_optimality, meth=lp_method)  
+++            lp.integer(tol_int=tolerance_integer)
+++        else:
+++            lp.simplex(tol_bnd=tolerance_optimality, tol_dj=tolerance_optimality,
+++                       meth=lp_method)
+++        status = get_status(lp)
+++        if status != 'optimal':
+++            for lp_method in the_methods:
+++                lp.simplex(tol_bnd=tolerance_optimality,
+++                           tol_dj=tolerance_optimality, meth=lp_method)
+++                status = get_status(lp)
+++                if status == 'optimal':
+++                    if lp.kind == int:
+++                        lp.integer(tol_int=tolerance_integer)
+++                    break
+++        if print_solver_time:
+++            print 'optimize time: %f'%(time() - start_time)
+++        return status
+++
+++    
+++def solve(cobra_model, **kwargs):
+++    """
+++
+++    """
+++    #Update objectives if they are new.
+++    if 'new_objective' in kwargs and \
+++           kwargs['new_objective'] not in ['update problem', None]:
+++       update_objective(cobra_model, kwargs['new_objective'])
+++
+++    if 'the_problem' in kwargs:
+++        the_problem = kwargs['the_problem']
+++    else:
+++        the_problem = None
+++    if 'error_reporting' in kwargs:
+++        error_reporting = kwargs['error_reporting']
+++    else:
+++        error_reporting = False
+++    if isinstance(the_problem, __solver_class):
+++        #Update the problem with the current cobra_model
+++        lp = the_problem
+++        update_problem(lp, cobra_model, **kwargs)
+++    else:
+++        #Create a new problem
+++        lp = create_problem(cobra_model, **kwargs)
+++    #Deprecated way for returning a solver problem created from a cobra_model
+++    #without performing optimization
+++    if the_problem == 'setup':
+++        return lp
+++    status = solve_problem(lp)
+++    the_solution = format_solution(lp, cobra_model)
+++    if status != 'optimal' and error_reporting:
+++        print '%s failed: %s'%(solver_name, status)
+++    cobra_model.solution = the_solution
+++    solution = {'the_problem': lp, 'the_solution': the_solution}
+++    return solution
++Index: cobra/oven/patches/patch_explanations.txt
++===================================================================
++--- cobra/oven/patches/patch_explanations.txt	(revision 330)
+++++ cobra/oven/patches/patch_explanations.txt	(working copy)
++@@ -1,3 +1,11 @@
+++cobra_pie_0.2.alpha01.patch:
+++  Adds support for gurobi, cplex, and libglpk-java solvers through jython and moves towards the new style solvers.  
+++  Adds sbml support for jython via jsbml.
+++  Adds get_model to Reaction and Metabolite/Gene which returns the Model object that contains the calling Object.
+++  Adds get_reaction to Metabolite/Gene which returns a list of Reaction Objects that contain the calling Object.
+++  Started to remove numpy/scipy dependencies from core objects / functions as they aren't really essential.
+++
+++
++ DictList_tab_complete  
++ Allows tab completion on a DictList, such as model.reactions.PG<TAB> will
++ autocomplete to model.reactions.PGI
+Index: cobra/io/sbml.py
+===================================================================
+--- cobra/io/sbml.py	(revision 330)
++++ cobra/io/sbml.py	(working copy)
+@@ -3,15 +3,27 @@
+ #System modules
+ from .. import Model, Reaction, Metabolite, Formula
+ from os.path import isfile
++from os import name as __name
+ from copy import deepcopy
+-from numpy import zeros
+-from scipy.sparse import lil_matrix
+ from time import time
+ import re
+-#Add in the switch for importing the java sbml if this is run in jython
+-from libsbml import SBMLDocument, SpeciesReference, KineticLaw, Parameter
+-from libsbml import readSBML, writeSBML
+-from libsbml import UNIT_KIND_MOLE, UNIT_KIND_GRAM, UNIT_KIND_SECOND, UNIT_KIND_DIMENSIONLESS
++#
++if __name == 'java':
++    from org.sbml.jsbml import SBMLDocument, SpeciesReference, KineticLaw, Parameter
++    from org.sbml.jsbml import SBMLReader, SBMLWriter
++    __tmp_reader = SBMLReader()
++    __tmp_writer = SBMLWriter()
++    readSBML = __tmp_reader.readSBMLFromFile
++    writeSBML = __tmp_writer.writeSBMLToFile
++    from org.sbml.jsbml.Unit import Kind as __Kind
++    UNIT_KIND_MOLE = __Kind.MOLE
++    UNIT_KIND_GRAM = __Kind.GRAM
++    UNIT_KIND_SECOND = __Kind.SECOND
++    UNIT_KIND_DIMENSIONLESS = __Kind.DIMENSIONLESS
++else:
++    from libsbml import SBMLDocument, SpeciesReference, KineticLaw, Parameter
++    from libsbml import readSBML, writeSBML
++    from libsbml import UNIT_KIND_MOLE, UNIT_KIND_GRAM, UNIT_KIND_SECOND, UNIT_KIND_DIMENSIONLESS
+ def parse_legacy_id(the_id, the_compartment=None, the_type='metabolite',
+                     use_hyphens=False):
+     """Deals with a bunch of problems due to bigg.ucsd.edu not following SBML standards
+@@ -399,7 +411,8 @@
+             
+         #Add in the kineticLaw
+         sbml_law = KineticLaw(sbml_level, sbml_version)
+-        sbml_law.setId('FLUX_VALUE')
++        if hasattr(sbml_law, 'setId'):
++            sbml_law.setId('FLUX_VALUE')
+         sbml_law.setFormula('FLUX_VALUE')
+         reaction_parameter_dict = {'LOWER_BOUND': [the_reaction.lower_bound, reaction_units],
+                                    'UPPER_BOUND': [the_reaction.upper_bound, reaction_units],
+Index: cobra/io/__init__.py
+===================================================================
+--- cobra/io/__init__.py	(revision 330)
++++ cobra/io/__init__.py	(working copy)
+@@ -1,21 +1,18 @@
+ from os import name as __name
+-from sys import modules as __modules
+-from warnings import warn
+-if __name == 'java':
+-    warn("%s is not yet supported on jython"%__modules[__name__])
++try:
++    from .sbml import create_cobra_model_from_sbml_file as read_sbml_model
++    from .sbml import read_legacy_sbml
++    from .sbml import write_cobra_model_to_sbml_file as write_sbml_model
++except ImportError, error:
++    from warnings import warn
++    warn("cobra.io.sbml will not be functional: ImportError %s" % error)
+ 
+-else:
+-    try:
+-        from .sbml import create_cobra_model_from_sbml_file as read_sbml_model
+-        from .sbml import read_legacy_sbml
+-        from .sbml import write_cobra_model_to_sbml_file as write_sbml_model
+-    except ImportError, error:
+-        from warnings import warn
+-        warn("cobra.io.sbml will not be functional: ImportError %s" % error)
++
++if __name != 'java':
+     from .mat import load_matlab_model
+     from .mat import save_matlab_model
+ 
+-del __name, __modules
++del __name
+ 
+ 
+ 
+Index: cobra/documentation/doctrees/cobra.core.doctree
+===================================================================
+Cannot display: file marked as a binary type.
+svn:mime-type = application/octet-stream
+Index: cobra/documentation/doctrees/cobra.doctree
+===================================================================
+Cannot display: file marked as a binary type.
+svn:mime-type = application/octet-stream
+Index: cobra/documentation/doctrees/environment.pickle
+===================================================================
+Cannot display: file marked as a binary type.
+svn:mime-type = application/octet-stream
+Index: cobra/examples/07_ice_cream_milp.py
+===================================================================
+--- cobra/examples/07_ice_cream_milp.py	(revision 330)
++++ cobra/examples/07_ice_cream_milp.py	(working copy)
+@@ -2,21 +2,8 @@
+ #
+ # Advanced user example showing how to set up and solve an MILP
+ #
+-
+ from cobra import Model, Metabolite, Reaction
+-try:
+-    import glpk
+-    solver = 'glpk'
+-except:
+-    try:
+-        from cplex import Cplex
+-        solver = 'cplex'
+-    except:
+-        try:
+-            from gurobipy import Model as gurobi_model
+-            solver = 'gurobi'
+-        except:
+-            raise Exception("Couldn't import glpk, cplex, or gurobi")
++solver = 'cplex'  #With libglpk-java there is an untraced memory bug.
+ 
+ cone_selling_price = 7.
+ cone_production_cost = 3.
+@@ -125,7 +112,7 @@
+ print
+ print('Here is what happens in the continuous (LP) case...')
+ 
+-the_program = cobra_model.optimize(objective_sense='maximize',solver=solver)
++the_program = cobra_model.optimize(objective_sense='maximize', solver=solver)
+ print
+ print('Status is: %s'%cobra_model.solution.status)
+ print('Objective value is: %1.2f'%cobra_model.solution.f)
Index: cobra/io/sbml.py
===================================================================
--- cobra/io/sbml.py	(revision 330)
+++ cobra/io/sbml.py	(working copy)
@@ -3,15 +3,27 @@
 #System modules
 from .. import Model, Reaction, Metabolite, Formula
 from os.path import isfile
+from os import name as __name
 from copy import deepcopy
-from numpy import zeros
-from scipy.sparse import lil_matrix
 from time import time
 import re
-#Add in the switch for importing the java sbml if this is run in jython
-from libsbml import SBMLDocument, SpeciesReference, KineticLaw, Parameter
-from libsbml import readSBML, writeSBML
-from libsbml import UNIT_KIND_MOLE, UNIT_KIND_GRAM, UNIT_KIND_SECOND, UNIT_KIND_DIMENSIONLESS
+#
+if __name == 'java':
+    from org.sbml.jsbml import SBMLDocument, SpeciesReference, KineticLaw, Parameter
+    from org.sbml.jsbml import SBMLReader, SBMLWriter
+    __tmp_reader = SBMLReader()
+    __tmp_writer = SBMLWriter()
+    readSBML = __tmp_reader.readSBMLFromFile
+    writeSBML = __tmp_writer.writeSBMLToFile
+    from org.sbml.jsbml.Unit import Kind as __Kind
+    UNIT_KIND_MOLE = __Kind.MOLE
+    UNIT_KIND_GRAM = __Kind.GRAM
+    UNIT_KIND_SECOND = __Kind.SECOND
+    UNIT_KIND_DIMENSIONLESS = __Kind.DIMENSIONLESS
+else:
+    from libsbml import SBMLDocument, SpeciesReference, KineticLaw, Parameter
+    from libsbml import readSBML, writeSBML
+    from libsbml import UNIT_KIND_MOLE, UNIT_KIND_GRAM, UNIT_KIND_SECOND, UNIT_KIND_DIMENSIONLESS
 def parse_legacy_id(the_id, the_compartment=None, the_type='metabolite',
                     use_hyphens=False):
     """Deals with a bunch of problems due to bigg.ucsd.edu not following SBML standards
@@ -399,7 +411,8 @@
             
         #Add in the kineticLaw
         sbml_law = KineticLaw(sbml_level, sbml_version)
-        sbml_law.setId('FLUX_VALUE')
+        if hasattr(sbml_law, 'setId'):
+            sbml_law.setId('FLUX_VALUE')
         sbml_law.setFormula('FLUX_VALUE')
         reaction_parameter_dict = {'LOWER_BOUND': [the_reaction.lower_bound, reaction_units],
                                    'UPPER_BOUND': [the_reaction.upper_bound, reaction_units],
Index: cobra/io/__init__.py
===================================================================
--- cobra/io/__init__.py	(revision 330)
+++ cobra/io/__init__.py	(working copy)
@@ -1,21 +1,18 @@
 from os import name as __name
-from sys import modules as __modules
-from warnings import warn
-if __name == 'java':
-    warn("%s is not yet supported on jython"%__modules[__name__])
+try:
+    from .sbml import create_cobra_model_from_sbml_file as read_sbml_model
+    from .sbml import read_legacy_sbml
+    from .sbml import write_cobra_model_to_sbml_file as write_sbml_model
+except ImportError, error:
+    from warnings import warn
+    warn("cobra.io.sbml will not be functional: ImportError %s" % error)
 
-else:
-    try:
-        from .sbml import create_cobra_model_from_sbml_file as read_sbml_model
-        from .sbml import read_legacy_sbml
-        from .sbml import write_cobra_model_to_sbml_file as write_sbml_model
-    except ImportError, error:
-        from warnings import warn
-        warn("cobra.io.sbml will not be functional: ImportError %s" % error)
+
+if __name != 'java':
     from .mat import load_matlab_model
     from .mat import save_matlab_model
 
-del __name, __modules
+del __name
 
 
 
Index: cobra/documentation/doctrees/cobra.core.doctree
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: cobra/documentation/doctrees/cobra.doctree
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: cobra/documentation/doctrees/environment.pickle
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: cobra/mlab/mlab.py
===================================================================
--- cobra/mlab/mlab.py	(revision 330)
+++ cobra/mlab/mlab.py	(working copy)
@@ -3,7 +3,7 @@
 import cPickle, numpy, os, cobra, warnings
 from copy import deepcopy
 from scipy.sparse import dok_matrix
-from cobra import Model, Reaction, Metabolite, Formula
+from .. import Model, Reaction, Metabolite, Formula, ArrayBasedModel
 
 from mlabwrap import mlab as matlab
 
@@ -250,10 +250,10 @@
         the_metabolite.name = n
         the_metabolite._constraint_sense = c
         the_metabolite.formula = Formula(f)
-        the_metabolite.charge = int(ch)
+
         the_compartments[the_metabolite.compartment] = the_metabolite.compartment
         if ch is not None:
-            the_metabolite.notes['CHARGE'] = int(ch)
+            the_metabolite.charge = the_metabolite.notes['CHARGE'] = int(ch)
         if cas is not None and cas != '':
             the_metabolite.notes['CASID'] = cas
         if kegg is not None and kegg != '':
@@ -313,7 +313,7 @@
             the_compartments[the_key] = compartment_dict[the_key]
     the_model.add_reactions(cobra_reactions)
     the_model.compartments = the_compartments
-    the_model.update()
+    the_model.solution = None
     return the_model
 
 
@@ -328,7 +328,10 @@
         raise Exception('mlabwrap and MATLAB are required to use these functions. '+\
                         'They only function on Mac OS X and GNU/Linux')
     from cobra.mlab import python_list_to_matlab_cell, scipy_sparse_to_mlab_sparse
-    cobra_model.update()
+    if hasattr(cobra_model, 'to_array_based_model'):
+        cobra_model = cobra_model.to_array_based_model()
+    else:
+        cobra_model.update()
     matlab_struct = matlab.struct()
     #Things that need a conversion:  S, rxnGeneMat,
     matlab_struct.mets = python_list_to_matlab_cell([x.id for x in cobra_model.metabolites],
@@ -351,16 +354,16 @@
                                                            for x in cobra_model.reactions],
                                                            transpose=True)
 
-    if hasattr(cobra_model, '_constraint_sense'):
-        matlab_struct.csense = reduce(lambda x,y: x+y, cobra_model._constraint_sense)
+    if hasattr(cobra_model, 'constraint_sense'):
+        matlab_struct.csense = reduce(lambda x,y: x+y, cobra_model.constraint_sense)
     #matlab_struct.csense = python_list_to_matlab_cell(['E']*len(cobra_model.metabolites), transpose = True)
     #TODO: inefficient conversion but who cares? matlab's on its way out
-    matlab_struct.S = scipy_sparse_to_mlab_sparse(cobra_model._S)
+    matlab_struct.S = scipy_sparse_to_mlab_sparse(cobra_model.S)
     #Things that can be directly copied
-    matlab_struct.b = cobra_model._b
-    matlab_struct.c = cobra_model._objective_coefficients
-    matlab_struct.lb = cobra_model._lower_bounds
-    matlab_struct.ub = cobra_model._upper_bounds
+    matlab_struct.b = cobra_model.b
+    matlab_struct.c = cobra_model.objective_coefficients
+    matlab_struct.lb = cobra_model.lower_bounds
+    matlab_struct.ub = cobra_model.upper_bounds
     matlab_struct.rev = [x.reversibility for x in cobra_model.reactions]
     matlab_struct.description = cobra_model.description
     return(matlab_struct)
Index: cobra/examples/07_ice_cream_milp.py
===================================================================
--- cobra/examples/07_ice_cream_milp.py	(revision 330)
+++ cobra/examples/07_ice_cream_milp.py	(working copy)
@@ -2,21 +2,8 @@
 #
 # Advanced user example showing how to set up and solve an MILP
 #
-
 from cobra import Model, Metabolite, Reaction
-try:
-    import glpk
-    solver = 'glpk'
-except:
-    try:
-        from cplex import Cplex
-        solver = 'cplex'
-    except:
-        try:
-            from gurobipy import Model as gurobi_model
-            solver = 'gurobi'
-        except:
-            raise Exception("Couldn't import glpk, cplex, or gurobi")
+solver = 'cplex'  #With libglpk-java there is an untraced memory bug.
 
 cone_selling_price = 7.
 cone_production_cost = 3.
@@ -110,22 +97,18 @@
 Cone_production.objective_coefficient = -1*cone_production_cost
 Popsicle_production.objective_coefficient = -1*popsicle_production_cost
 
-reaction_dict = dict([(x.id, x) for x in cobra_model.reactions])
 
 production_capacity_constraint = Metabolite(id='production_capacity_constraint')
 production_capacity_constraint._constraint_sense = 'L'
 production_capacity_constraint._bound = starting_budget;
 
-the_reaction = reaction_dict['Cone_production']
-the_reaction.add_metabolites({production_capacity_constraint: cone_production_cost })
+Cone_production.add_metabolites({production_capacity_constraint: cone_production_cost })
+Popsicle_production.add_metabolites({production_capacity_constraint: popsicle_production_cost })
 
-the_reaction = reaction_dict['Popsicle_production']
-the_reaction.add_metabolites({production_capacity_constraint: popsicle_production_cost })
-
 print
 print('Here is what happens in the continuous (LP) case...')
 
-the_program = cobra_model.optimize(objective_sense='maximize',solver=solver)
+the_program = cobra_model.optimize(objective_sense='maximize', solver=solver)
 print
 print('Status is: %s'%cobra_model.solution.status)
 print('Objective value is: %1.2f'%cobra_model.solution.f)
@@ -142,9 +125,7 @@
 print
 print('Who wants 1/3 of a cone, WTF???  Cones and popsicles are units aka integers, reformulate as MILP')
 Cone_production.variable_kind = 'integer'
-Cone_production.upper_bound = 50000;
 Popsicle_production.variable_kind = 'integer'
-Popsicle_production.upper_bound = 50000;
 
 the_program = cobra_model.optimize(objective_sense='maximize', solver=solver)
 print
