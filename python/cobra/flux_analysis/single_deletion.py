#cobra.flux_analysis.single_deletion.py
#run single gene or reaction deletions on the model
from numpy import nan
from time import time
from copy import deepcopy
from cobra.manipulation import initialize_growth_medium
from cobra.manipulation import delete_model_genes, undelete_model_genes
from cobra.flux_analysis.moma import moma
#TODO: Add in an option for using matrices instead of objects because it
#appears that there might be a performance penalty (especially for repetitions)
#when using objects.
#
#
#
#older optimized matrix method:
#    single deletion time: 7.301675 seconds
#
#new unoptimized object method:
#    single deletion time: 10.307247 seconds
#
#  The major penalties are related to copying / indexing new models
def single_deletion(cobra_model, element_list=None,
                    method='fba', the_problem='return',
                    element_type='gene', solver='glpk',
                    error_reporting=None):
    """Wrapper for single_gene_deletion and the single_reaction_deletion
    functions

    
    cobra_model: a cobra.Model object

    element_list: Is None or a list of elements (genes or reactions) to
    delete.

    method: 'fba' or 'moma'

    the_problem: Is None, 'return', or an LP model object for the solver.

    element_type: 'gene' or 'reaction'

    solver: 'glpk', 'gurobi', or 'cplex'.

    discard_problems: Boolean.  If True do not save problems.  This will
    help with memory issues related to gurobi.

    Returns a list of dictionaries: growth_rate_dict, solution_status_dict,
    problem_dict where the key corresponds to each element in element_list.

    """
    if element_type == 'gene':
        the_solution = single_gene_deletion(cobra_model, element_list,
                                    method=method, the_problem=the_problem,
                                    solver=solver,
                                    error_reporting=error_reporting)

    else:
        the_solution = single_reaction_deletion(cobra_model, element_list,
                                        method=method, the_problem=the_problem,
                                        solver=solver,
                                                error_reporting=error_reporting)
    return the_solution

def single_reaction_deletion(cobra_model, reaction_list=None,
                             method='fba', the_problem='return',
                             solver='glpk', error_reporting=None,
                             discard_problems=True):
    """Performs optimization simulations to realize the objective defined
    from cobra_model._objective_coefficients after deleting each reaction
    from the model.
    
    cobra_model: a cobra.Model object

    reaction_list: Is None or a list of reactions to disable.  If None then
    disable each reaction in cobra_model.reactions and optimize for the
    objective function defined from cobra_model._objective_coefficients.

    method: 'fba' is the only option at the moment.

    the_problem: Is None, 'reuse', or an LP model object for the solver.

    solver: 'glpk', 'gurobi', or 'cplex'.

    discard_problems: Boolean.  If True do not save problems.  This will
    help with memory issues related to gurobi.
    
    Returns a list of dictionaries: growth_rate_dict, solution_status_dict,
    problem_dict where the key corresponds to each reaction in reaction_list.

    """
    raise Exception('single_reaction_deletion is not up to date')
    if the_problem == 'reuse':
        the_problem = 'return'
    wt_model = cobra_model.copy() #Model in original wild-type (wt) conditions
    mutant_model = cobra_model.copy() #Model with mutated capabilities
    if not reaction_list:
        reaction_list = mutant_model.reactions
    #Should add in a section that allows this solution to be'
    #used as the basis to hot start the solution.
    the_problem = wt_model.optimize(the_problem = the_problem, solver=solver,
                                     error_reporting=error_reporting)
    wt_f = wt_model.solution.f
    wt_status = wt_model.solution.status
    wt_x = deepcopy(wt_model.solution.x)
    wt_x_dict = deepcopy(wt_model.solution.x_dict)
    #MOMA constructs combined quadratic models thus we cannot reuse a model
    #generated by the cobra_model.optimize call
    if method.lower() == 'moma':
        the_problem = 'return'

    wt_problem = the_problem
    growth_rate_dict = {}
    solution_status_dict = {}
    problem_dict = {}
    for the_reaction in reaction_list:
        #delete the reaction
        #if the deletion alters the bounds then run simulation
        reaction_index = mutant_model.reactions.index(the_reaction)
        if mutant_model._lower_bounds[reaction_index] == 0 and \
               mutant_model._upper_bounds[reaction_index] == 0:
            #If the reaction was originally disabled then disabling it will
            #have no impact on the solution.
            growth_rate_dict[the_reaction] = wt_f
            solution_status_dict[the_reaction] = wt_status
            if discard_problems:
                problem_dict[the_reaction] = 'discarded'
            else:
                problem_dict[the_reaction] = wt_problem
        else:
            #Record the bounds for the the reactions.  Then zero
            #the flux through the reactions before optimization.
            tmp_lb = mutant_model._lower_bounds[reaction_index]
            cobra_model.reactions[reaction_index].lower_bound = mutant_model._lower_bounds[reaction_index] = 0
            tmp_ub = mutant_model._upper_bounds[reaction_index]
            cobra_model.reactions[reaction_index].upper_bound = mutant_model._upper_bounds[reaction_index] = 0
            if method.lower() == 'fba':
                the_problem = mutant_model.optimize(the_problem=wt_problem, solver=solver,
                                                    error_reporting=error_reporting)
                growth_rate_dict[the_reaction] = mutant_model.solution.f
                solution_status_dict[the_reaction] = mutant_model.solution.status
            elif method.lower() == 'moma':
                try:
                    moma_solution = moma(wt_model, mutant_model, solver=solver, the_problem=the_problem)
                    the_problem = moma_solution.pop('the_problem')
                    growth_rate_dict[the_reaction] = float(moma_solution.pop('objective_value'))
                    solution_status_dict[the_reaction] = moma_solution.pop('status')
                    del moma_solution
                except:
                    growth_rate_dict[the_reaction] = nan
                    the_problem = None
                    solution_status_dict[the_reaction] = 'failed'

            if discard_problems:
                problem_dict[the_reaction] = 'discarded'
            else:
                problem_dict[the_reaction] = the_problem
            if not the_problem:
                the_problem = wt_problem
            #Reinstate the reaction's bounds
            cobra_model.reactions[reaction_index].lower_bound = mutant_model._lower_bounds[reaction_index] = tmp_lb
            cobra_model.reactions[reaction_index].upper_bound = mutant_model._upper_bounds[reaction_index] = tmp_ub

    return(growth_rate_dict, solution_status_dict, problem_dict)


def single_gene_deletion(cobra_model, gene_list=None,
                         method='fba', the_problem='reuse', solver='glpk',
                         error_reporting=None):
    """Performs optimization simulations to realize the objective defined
    from cobra_model._objective_coefficients after deleting each gene in
    gene_list from the model.
    
    cobra_model: a cobra.Model object

    gene_list: Is None or a list of genes to delet.  If None then
    disable each reaction associated with each gene in cobra_model.genes.

    method: 'fba' or 'moma'

    the_problem: Is None or 'reuse'.

    solver: 'glpk', 'gurobi', or 'cplex'.

    Returns a list of dictionaries: growth_rate_dict, solution_status_dict,
    problem_dict where the key corresponds to each reaction in reaction_list.

    TODO: Add in a section that allows copying and collection of problem for
    debugging purposes.

    """
    wt_model = cobra_model.copy() #Original wild-type (wt) model.
    wt_model.id = 'Wild-Type'
    #MOMA constructs combined quadratic models thus we cannot reuse a model
    #generated by the cobra_model.optimize call
    if method.lower() == 'moma':
        the_problem = 'return'
        mutant_model = wt_model.copy() #Need a second model for moma
    else:
        mutant_model = wt_model
    discard_problems = False
    if the_problem:
        the_problem = 'return'
        discard_problems = True
   
    the_problem = wt_model.optimize(the_problem=the_problem, solver=solver,
                                       error_reporting=error_reporting)
    wt_f = wt_model.solution.f
    wt_status = wt_model.solution.status
    wt_x = deepcopy(wt_model.solution.x)
    wt_x_dict = deepcopy(wt_model.solution.x_dict)

    wt_problem = the_problem
    if not gene_list:
        gene_list = mutant_model.genes

    growth_rate_dict = {}
    solution_status_dict = {}
    problem_dict = {}
    combined_model = None
    for the_gene in gene_list:
        #delete the gene
        #if the deletion alters the bounds then run simulation
        delete_model_genes(mutant_model, the_gene)
        mutant_model.id = the_gene
        if mutant_model._trimmed:
            if method.lower() == 'fba':
                the_problem = mutant_model.optimize(the_problem=wt_problem,
                                                    solver=solver,
                                                    error_reporting=error_reporting)
                growth_rate_dict[the_gene] = mutant_model.solution.f
                solution_status_dict[the_gene] = mutant_model.solution.status
            elif method.lower() == 'moma':
                try:
                    #TODO: Need to figure out why reusing the problem and the combined_model do not
                    #speed things up here.
                    moma_solution = moma(wt_model, mutant_model, solver=solver, the_problem=the_problem,
                                         combined_model=combined_model)
                    the_problem = moma_solution.pop('the_problem')
                    growth_rate_dict[the_gene] = float(moma_solution.pop('objective_value'))
                    solution_status_dict[the_gene] = moma_solution.pop('status')
                    combined_model = moma_solution.pop('combined_model')
                except:
                    growth_rate_dict[the_gene] = nan
                    the_problem = None
                    solution_status_dict[the_gene] = 'failed'

            if discard_problems:
                problem_dict[the_gene] = 'discarded'
            else:
                problem_dict[the_gene] = the_problem
            if not the_problem:
                the_problem = wt_problem
            #reset the model
            undelete_model_genes(mutant_model)
        #else just use the wt_f and x
        else:
            if discard_problems:
                problem_dict[the_gene] = 'discarded'
            else:
                problem_dict[the_gene] = wt_problem
            growth_rate_dict[the_gene] = wt_f
            solution_status_dict[the_gene] = wt_status
    
    
    return(growth_rate_dict, solution_status_dict, problem_dict)

if __name__ == '__main__':
    from cPickle import load
    from time import time
    from math import floor
    method='moma'
    the_problem='return'
    element_type='gene'
    error_reporting=None
    test_directory = '../test/data/'
    from cobra.manipulation import initialize_growth_medium
    with open(test_directory + 'salmonella.pickle') as in_file:
        cobra_model = load(in_file)


    initialize_growth_medium(cobra_model, 'LB')
    #Expected growth rates for the salmonella model with deletions in LB medium
    growth_dict = {'moma': {'tpiA':1.61, 'metN':2.39, 'atpA':1.40, 'eno':0.33},
                   'fba': {'tpiA':2.41, 'metN':2.43, 'atpA':1.87, 'eno':1.81}}
    solver_list = ['glpk',
                   'gurobi',
                   'cplex']
    try:
        import glpk
    except:
        solver_list.remove('glpk')
    try:
        from gurobipy import Model
    except:
        solver_list.remove('gurobi')
    try:
        from cplex import Cplex
    except:
        solver_list.remove('cplex')

    for solver in solver_list:
        print 'testing solver: ' + solver
        for method, the_growth_rates in growth_dict.items():
            if method == 'moma':
                print "Can't do MOMA now.  Try back later."
                continue
            print '\twith method: ' + method 
            element_list = the_growth_rates.keys()
            start_time = time()
            rates, statuses, problems = single_deletion(cobra_model,
                                                        element_list=element_list,
                                                        method=method,
                                                        the_problem=the_problem,
                                                        element_type=element_type,
                                                        solver=solver,
                                                        error_reporting=error_reporting)
            for the_gene, v in statuses.items():
                if v != 'optimal':
                    print '\t\tdeletion %s was not optimal'%the_gene
            for the_gene, v in rates.items():
                v = floor(100*v)/100
                if v != the_growth_rates[the_gene]:
                    print '\t\tFAILED: %s simulation (%1.3f) != expectation (%1.2f)'%(the_gene,
                                                                                     v,
                                                                                     the_growth_rates[the_gene])
                else:
                    print '\t\tPASSED: %s simulation (%1.3f) ~= expectation (%1.2f)'%(the_gene,
                                                                                     v,
                                                                                     the_growth_rates[the_gene])


            print '\t\tsingle deletion time: %f seconds'%(time() - start_time)

    ## if False:
    ##     wt_model = cobra_model.copy() #Original wild-type (wt) model.
    ##     wt_model.id = 'Wild-Type'
    ##     mutant_model = wt_model.copy() #Model to mutate
    ##     discard_problems = False
    ##     if the_problem:
    ##         the_problem = 'return'
    ##         discard_problems = True

    ##     the_problem = wt_model.optimize(the_problem=the_problem, solver=solver,
    ##                                        error_reporting=error_reporting)
    ##     wt_f = wt_model.solution.f
    ##     wt_status = wt_model.solution.status
    ##     wt_x = deepcopy(wt_model.solution.x)
    ##     wt_x_dict = deepcopy(wt_model.solution.x_dict)
    ##     #MOMA constructs combined quadratic models thus we cannot reuse a model
    ##     #generated by the cobra_model.optimize call
    ##     if method.lower() == 'moma':
    ##         the_problem = 'return'

    ##     wt_problem = the_problem
    ##     gene_list = element_list
        

    ##     growth_rate_dict = {}
    ##     solution_status_dict = {}
    ##     problem_dict = {}
    ##     combined_model = None
    ##     for the_gene in gene_list:
    ##         #delete the gene
    ##         #if the deletion alters the bounds then run simulation
    ##         delete_model_genes(mutant_model, the_gene)
    ##         mutant_model.id = the_gene
    ##         if mutant_model._trimmed:
    ##             if method.lower() == 'fba':
    ##                 the_problem = mutant_model.optimize(the_problem=wt_problem,
    ##                                                     solver=solver,
    ##                                                     error_reporting=error_reporting)
    ##                 growth_rate_dict[the_gene] = mutant_model.solution.f
    ##                 solution_status_dict[the_gene] = mutant_model.solution.status
    ##     for the_reaction in mutant_model.reactions:
    ##         lb = the_problem.variables.get_lower_bounds(the_reaction.id)
    ##         ub = the_problem.variables.get_upper_bounds(the_reaction.id)
    ##         if lb != the_reaction.lower_bound or ub != the_reaction.upper_bound:
    ##             print '%s lb: %f\t%f\tub: %f\t%f'%(the_reaction.id,
    ##                                                 the_reaction.lower_bound,
    ##                                                 lb,
    ##                                                 the_reaction.upper_bound,
    ##                                                 ub)
    ##     for the_metabolite in mutant_model.metabolites[:100]:
    ##         for the_reaction in the_metabolite._reaction:
    ##             the_coefficient = the_problem.linear_constraints.get_coefficients(the_metabolite.id,
    ##                                                                               the_reaction.id)
    ##             print '%s in %s b: %f'%(the_metabolite.id,
    ##                                     the_reaction.id,
    ##                                     the_coefficient)
