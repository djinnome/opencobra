#cobra.flux_analysis.single_deletion.py
#run single gene or reaction deletions on the model
from numpy import nan
from time import time
from copy import deepcopy
from cobra.manipulation import initialize_growth_medium
from cobra.manipulation import delete_model_genes, undelete_model_genes
from cobra.flux_analysis.moma import moma
def single_deletion(cobra_model, element_list=None,
                    method='fba', the_problem='return',
                    element_type='gene', solver='glpk',
                    error_reporting=None):
    """Wrapper for single_gene_deletion and the single_reaction_deletion
    functions

    
    cobra_model: a cobra.Model object

    element_list: Is None or a list of elements (genes or reactions) to
    delete.

    method: 'fba' or 'moma'

    the_problem: Is None, 'return', or an LP model object for the solver.

    element_type: 'gene' or 'reaction'

    solver: 'glpk', 'gurobi', or 'cplex'.

    discard_problems: Boolean.  If True do not save problems.  This will
    help with memory issues related to gurobi.

    Returns a list of dictionaries: growth_rate_dict, solution_status_dict,
    problem_dict where the key corresponds to each element in element_list.

    """
    if element_type == 'gene':
        the_solution = single_gene_deletion(cobra_model, element_list,
                                    method=method, the_problem=the_problem,
                                    solver=solver,
                                    error_reporting=error_reporting)

    else:
        the_solution = single_reaction_deletion(cobra_model, element_list,
                                        method=method, the_problem=the_problem,
                                        solver=solver,
                                                error_reporting=error_reporting)
    return the_solution

def single_reaction_deletion(cobra_model, element_list=None,
                             method='fba', the_problem='return',
                             solver='glpk', error_reporting=None,
                             discard_problems=True):
    """Performs optimization simulations to realize the objective defined
    from cobra_model._objective_coefficients after deleting each reaction
    from the model.
    
    cobra_model: a cobra.Model object

    element_list: Is None or a list of cobra.Reactions in cobra_model to disable.
    If None then disable each reaction in cobra_model.reactions and optimize for the
    objective function defined from cobra_model._objective_coefficients.

    method: 'fba' is the only option at the moment.

    the_problem: Is None, 'reuse', or an LP model object for the solver.

    solver: 'glpk', 'gurobi', or 'cplex'.

    discard_problems: Boolean.  If True do not save problems.  This will
    help with memory issues related to gurobi.
    
    Returns a list of dictionaries: growth_rate_dict, solution_status_dict,
    problem_dict where the key corresponds to each reaction in reaction_list.

    """
    #element_list so we can merge single_reaction_deletion and single_gene_deletion

    wt_model = cobra_model.copy() #Original wild-type (wt) model.
    wt_model.id = 'Wild-Type'
    #MOMA constructs combined quadratic models thus we cannot reuse a model
    #generated by the cobra_model.optimize call
    if method.lower() == 'moma':
        the_problem = 'return'
        mutant_model = wt_model.copy() #Need a second model for moma
    else:
        mutant_model = cobra_model
    discard_problems = False
    if the_problem:
        the_problem = 'return'
        discard_problems = True
    the_problem = wt_model.optimize(the_problem=the_problem, solver=solver,
                                       error_reporting=error_reporting)
    wt_f = wt_model.solution.f
    wt_status = wt_model.solution.status
    wt_x = deepcopy(wt_model.solution.x)
    wt_x_dict = deepcopy(wt_model.solution.x_dict)

    wt_problem = the_problem
    if element_list is None:
        element_list = mutant_model.reactions
    elif not hasattr(element_list[0], 'id'):
        element_list = map(mutant_model.reactions.get_by_id, element_list)
    else:
        if mutant_model is not cobra_model:
            element_list = [x.id for x in element_list]
            element_list = map(mutant_model.genes.get_by_id, element_list)

    growth_rate_dict = {}
    solution_status_dict = {}
    problem_dict = {}
    combined_model = None
    for the_element in element_list:
        #delete the gene
        #if the deletion alters the bounds then run simulation
        old_lower_bound, old_upper_bound = map(float, [the_element.lower_bound,
                                                       the_element.upper_bound])
        mutant_model.id = the_element.id
        if old_lower_bound != 0 and old_upper_bound != 0:
            the_element.lower_bound = 0
            the_element.upper_bound = 0
            if method.lower() == 'fba':
                the_problem = mutant_model.optimize(the_problem=wt_problem,
                                                    solver=solver,
                                                    error_reporting=error_reporting)
                growth_rate_dict[the_element] = mutant_model.solution.f
                solution_status_dict[the_element] = mutant_model.solution.status
            elif method.lower() == 'moma':
                try:
                    #TODO: Need to figure out why reusing the problem and the combined_model do not
                    #speed things up here.
                    moma_solution = moma(wt_model, mutant_model, solver=solver, the_problem=the_problem,
                                         combined_model=combined_model)
                    the_problem = moma_solution.pop('the_problem')
                    growth_rate_dict[the_element] = float(moma_solution.pop('objective_value'))
                    solution_status_dict[the_element] = moma_solution.pop('status')
                    combined_model = moma_solution.pop('combined_model')
                except:
                    growth_rate_dict[the_element] = nan
                    the_problem = None
                    solution_status_dict[the_element] = 'failed'

            if discard_problems:
                problem_dict[the_element] = 'discarded'
            else:
                problem_dict[the_element] = the_problem
            if not the_problem:
                the_problem = wt_problem
            #reset the model
            the_element.lower_bound = old_lower_bound
            the_element.upper_bound = old_upper_bound
        #else just use the wt_f and x
        else:
            if discard_problems:
                problem_dict[the_element] = 'discarded'
            else:
                problem_dict[the_element] = wt_problem
            growth_rate_dict[the_element] = wt_f
            solution_status_dict[the_element] = wt_status
    
    
    return(growth_rate_dict, solution_status_dict, problem_dict)

def single_gene_deletion(cobra_model, element_list=None,
                         method='fba', the_problem='reuse', solver='glpk',
                         error_reporting=None):
    """Performs optimization simulations to realize the objective defined
    from cobra_model._objective_coefficients after deleting each gene in
    gene_list from the model.
    
    cobra_model: a cobra.Model object

    element_list: Is None or a list of genes to delete.  If None then
    disable each reaction associated with each gene in cobra_model.genes.

    method: 'fba' or 'moma'

    the_problem: Is None or 'reuse'.

    solver: 'glpk', 'gurobi', or 'cplex'.

    Returns a list of dictionaries: growth_rate_dict, solution_status_dict,
    problem_dict where the key corresponds to each reaction in reaction_list.

    TODO: Add in a section that allows copying and collection of problem for
    debugging purposes.

    """
    wt_model = cobra_model.copy() #Original wild-type (wt) model.
    wt_model.id = 'Wild-Type'
    #MOMA constructs combined quadratic models thus we cannot reuse a model
    #generated by the cobra_model.optimize call
    if method.lower() == 'moma':
        the_problem = 'return'
        mutant_model = wt_model.copy() #Need a second model for moma
    else:
        mutant_model = cobra_model
    discard_problems = False
    if the_problem:
        the_problem = 'return'
        discard_problems = True
   
    the_problem = wt_model.optimize(the_problem=the_problem, solver=solver,
                                       error_reporting=error_reporting)
    wt_f = wt_model.solution.f
    wt_status = wt_model.solution.status
    wt_x = deepcopy(wt_model.solution.x)
    wt_x_dict = deepcopy(wt_model.solution.x_dict)

    if element_list is None:
        element_list = mutant_model.genes
    elif not hasattr(element_list[0], 'id'):
        element_list = map(mutant_model.genes.get_by_id, element_list)
    else:
        if mutant_model is not cobra_model:
            element_list = [x.id for x in element_list]
            element_list = map(mutant_model.genes.get_by_id, element_list)
    wt_problem = the_problem

    growth_rate_dict = {}
    solution_status_dict = {}
    problem_dict = {}
    combined_model = None
    for the_element in element_list:
        #delete the gene
        #if the deletion alters the bounds then run simulation
        delete_model_genes(mutant_model, the_element)
        mutant_model.id = the_element.id
        if mutant_model._trimmed:
            if method.lower() == 'fba':
                the_problem = mutant_model.optimize(the_problem=wt_problem,
                                                    solver=solver,
                                                    error_reporting=error_reporting)
                growth_rate_dict[the_element.id] = mutant_model.solution.f
                solution_status_dict[the_element.id] = mutant_model.solution.status
            elif method.lower() == 'moma':
                try:
                    #TODO: Need to figure out why reusing the problem and the combined_model do not
                    #speed things up here.
                    moma_solution = moma(wt_model, mutant_model, solver=solver, the_problem=the_problem,
                                         combined_model=combined_model)
                    the_problem = moma_solution.pop('the_problem')
                    growth_rate_dict[the_element.id] = float(moma_solution.pop('objective_value'))
                    solution_status_dict[the_element.id] = moma_solution.pop('status')
                    combined_model = moma_solution.pop('combined_model')
                except:
                    growth_rate_dict[the_element.id] = nan
                    the_problem = None
                    solution_status_dict[the_element.id] = 'failed'

            if discard_problems:
                problem_dict[the_element.id] = 'discarded'
            else:
                problem_dict[the_element.id] = the_problem
            if not the_problem:
                the_problem = wt_problem
            #reset the model
            undelete_model_genes(mutant_model)
        #else just use the wt_f and x
        else:
            if discard_problems:
                problem_dict[the_element.id] = 'discarded'
            else:
                problem_dict[the_element.id] = wt_problem
            growth_rate_dict[the_element.id] = wt_f
            solution_status_dict[the_element.id] = wt_status
    
    
    return(growth_rate_dict, solution_status_dict, problem_dict)

if __name__ == '__main__':
    from cPickle import load
    from time import time
    from math import floor
    from cobra.test import salmonella_pickle
    method='moma'
    the_problem='return'
    element_type='gene'
    error_reporting=None
    from cobra.manipulation import initialize_growth_medium
    with open(salmonella_pickle) as in_file:
        cobra_model = load(in_file)


    initialize_growth_medium(cobra_model, 'LB')
    #Expected growth rates for the salmonella model with deletions in LB medium
    the_loci =  ['STM4081', 'STM0247', 'STM3867', 'STM2952']
    the_genes = tpiA, metN, atpA, eno = map(cobra_model.genes.get_by_id, the_loci)
    id_to_name = dict([(x.id, x.name) for x in the_genes])
    growth_dict = {'moma': {tpiA.id:1.61, metN.id:2.39, atpA.id:1.40, eno.id:0.33},
                   'fba':{tpiA.id:2.41, metN.id:2.43, atpA.id:1.87, eno.id:1.81}}

    solver_list = ['glpk',
                   'gurobi',
                   'cplex']
    try:
        import glpk
    except:
        solver_list.remove('glpk')
    try:
        from gurobipy import Model
    except:
        solver_list.remove('gurobi')
    try:
        from cplex import Cplex
    except:
        solver_list.remove('cplex')

    for solver in solver_list:
        print 'testing solver: ' + solver
        for method, the_growth_rates in growth_dict.items():
            if method == 'moma':
                print "Can't do MOMA now.  Try back later."
                continue
            print '\twith method: ' + method 
            element_list = the_growth_rates.keys()
            start_time = time()
            rates, statuses, problems = single_deletion(cobra_model,
                                                        element_list=element_list,
                                                        method=method,
                                                        the_problem=the_problem,
                                                        element_type=element_type,
                                                        solver=solver,
                                                        error_reporting=error_reporting)
            for the_gene, v in statuses.items():
                if v != 'optimal':
                    print '\t\tdeletion %s was not optimal'%the_gene
            for the_gene, v in rates.items():
                v = floor(100*v)/100
                if v != the_growth_rates[the_gene]:
                    print '\t\tFAILED: %s simulation (%1.3f) != expectation (%1.2f)'%(id_to_name[the_gene],
                                                                                     v,
                                                                                     the_growth_rates[the_gene])
                else:
                    print '\t\tPASSED: %s simulation (%1.3f) ~= expectation (%1.2f)'%(id_to_name[the_gene],
                                                                                     v,
                                                                                     the_growth_rates[the_gene])


            print '\t\tsingle deletion time: %f seconds'%(time() - start_time)

 
