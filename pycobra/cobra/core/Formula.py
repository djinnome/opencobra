#cobra.core.Formula.py
#######################
#BEGIN Class Formula
#
import re
from copy import deepcopy
from Object import Object
class Formula(Object):
    """Formula is a class for holding information regarding
    a Metabolite formula.

    This will replace the current way of dealing with molecular
    formulae in cobra.Metabolite objects

    Legal formula string characters include letters, numbers, and *.
    If a formula string starts with a number then it is assumed that
    all element counts are multiplied by this number.

    """
    def __init__(self, formula=None):
        Object.__init__(self, formula)
        self.formula = formula
        self.weight = None
        self.elements = {}
        if self.formula is not None:
            self.parse_composition()

    def __add__(self, other_formula):
        """Combine two molecular formulas.

        other_formula: cobra.Formula or String representation of a chemical Formula.
        
        """
        elements = deepcopy(self.elements)
        if isinstance(other_formula, str):
            other_formula = Formula(other_formula)
        for element, element_count in other_formula.elements.items():
            if element in elements:
                elements[element] += element_count
            else:
                elements[element] = element_count
        new_formula = Formula()
        new_formula.id = new_formula.formula = reduce(lambda x, y: x + y,
                                        ['%s%i'%(k,v)
                                         for k, v in elements.items()])
        new_formula.elements = elements
        new_formula.calculate_formula_weight()
        return new_formula
    
    def parse_composition(self):
        """Breaks the chemical formula down by element.
        Useful for making sure Reactions are balanced.'

        TODO: Find a stable python package for parsing chemical formulas.
        """
        starting_coefficient_re = re.compile('^\d+')
        if self.elements == '' or self.formula == None:
            self.elements = {}
        elif '*' in self.formula:
            tmp_formula = reduce(lambda x, y: x + y,
                                 map(Formula, self.formula.split('*')))
            self.elements = tmp_formula.elements
            self.calculate_formula_weight()
        elif starting_coefficient_re.match(self.formula):
            #Check to see if the formula starts with an integer.  If
            #it does then multiply all el
            #This is often the case for some salt hydrates (e.g. Na2WO4*2H2O)
            formula = starting_coefficient_re.split(self.formula)[-1]
            coefficient = int(self.formula.split(formula)[0])
            tmp_formula = Formula(formula)
            [tmp_formula.elements.update({k: coefficient*v})
             for k, v in tmp_formula.elements.items()]
            self.elements = tmp_formula.elements
            self.calculate_formula_weight()
        else:
            element_number_re = re.compile('\d+')
            #This will probably be better accomplished by breaking
            #on anything that preceeds a capital letter and 
            elements = element_number_re.split(self.formula)
            if elements[-1] == '':
                #remove the empty element generated by the last item in
                #the_metabolite string being a number
                elements.pop()
            element_counts = map(float, element_number_re.findall(self.formula))
            if element_counts > elements:
                print 'Have more element counts than elements in formula: ' +\
                      self.formula
                #return
            while len(element_counts) != len(elements):
                element_counts.append(1.0)
            #Split apart any elements that weren't separated by
            #a number and assign their count as 1
            element_re=re.compile('[A-Z][a-z]*')
            tmp_element_list = []
            tmp_count_list = []
            for i_element in range(len(elements)):
                #Find all atoms in self.formula with the format Xx*
                split_element = element_re.findall(elements[i_element])
                if len(split_element) == 1:
                    tmp_element_list.append(split_element)
                    tmp_count_list.append([element_counts[i_element]])
                else:
                    tmp_elements = [split_element.pop()]
                    tmp_counts = [element_counts[i_element]]
                    #The last element in the split_element is what has
                    #the following count so no need to update element_counts yet
                    split_element.reverse()
                    for the_element in split_element:
                        tmp_elements.append(the_element)
                        tmp_counts.append(1)
                    tmp_elements.reverse()
                    tmp_counts.reverse()
                    tmp_element_list.append(tmp_elements)
                    tmp_count_list.append(tmp_counts)
            elements = []
            element_counts = []
            for the_element in tmp_element_list:
                elements += the_element
            for the_count in tmp_count_list:
                element_counts += the_count
            #Zip the elements / counts into dictionary format
            self.elements = dict(zip(elements, element_counts))
            self.calculate_formula_weight()

    def calculate_formula_weight(self, weight_dict=None):
        """Calculate the formula weight.

        weight_dict: None or a dictionary of elements and weights.
        
        """

        if weight_dict is None:
            weight_dict = elements_and_molecular_weights
        #Deal with historical laziness associated with not
        #calculating the compositions of large molecules and
        #instead using an R or X.
        if ('R' in self.formula and 'R' not in weight_dict) or\
           ('X' in self.formula and 'X' not in weight_dict):
            self.weight = None
            return
        self.weight = 0.
        self.weight = sum([the_count*weight_dict[the_element]
                           for the_element, the_count in self.elements.items()])
            

#
#END Class Formula
########################
elements_and_molecular_weights = {'Ag': 107.87,
                                  'Al': 26.982,
                                  'As': 74.992,
                                  'Au': 196.97,
                                  'B': 10.81,
                                  'Br': 79.904,
                                  'C': 12.011,
                                  'Ca': 40.08,
                                  'Cd': 112.41,
                                  'Cl': 35.453,
                                  'Co': 58.933,
                                  'Cu': 63.546,
                                  'Fe': 55.847,
                                  'H': 1.0079,
                                  'Hg': 200.59,
                                  'I': 126.90,
                                  'K': 39.098,
                                  'Mg': 24.305,
                                  'Mn': 54.938,
                                  'Mo': 95.94,
                                  'N': 14.007,
                                  'Na': 22.990,
                                  'Ni': 58.71,
                                  'O': 15.999,
                                  'P': 30.974,
                                  'S': 32.06,
                                  'Se': 78.96,
                                  'W': 183.85,
                                  'Zn': 65.38}
